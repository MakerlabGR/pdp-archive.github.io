---
layout: solution
codename: olivetrees
---

## Επεξήγηση εκφώνησης
Μας δίνονται ένας πίνακας με $$M$$ στήλες και $$N$$ γραμμές. 
Κάθε στήλη $$i$$ έχει $$Z_i$$ κατειλημμένα κελιά στη βάση της και ακολουθούν 
τα $$N-Z_i$$ κενά κελιά στην κορυφή της. 
Ζητείται να υπολογιστεί το εμβαδό του μεγαλύτερου παραλληλογράμμου που σχηματίζεται 
αποκλειστικά από κενά κελιά.

Δεν χρειάζεται να κρατήσουμε το πλήθος των κατειλημμένων κελιών, 
οπότε κρατάμε από κάθε στήλη $$i$$ μόνο το ύψος $$H_i$$, 
δηλαδή τον αριθμό κενών κελιών που περιέχει.

**Παρατήρηση 1** Στο μέγιστο παραλληλόγραμμο που ξεκινάει από την στήλη $$i$$ και τελειώνει στην στήλη $$j$$, 
η άνω του πλευρά (με πλάτος $$j-i+1$$) ταυτίζεται με την άνω πλευρά του πίνακα και το ύψος του είναι η ελάχιστη 
από τις τιμές $$H_i, H_{i+1}, \ldots H_j$$. 

Στην συνέχεια θα παρουσιάσουμε μια λύση *brute force*, δηλαδή εξαντλητικής διερεύνησης 
με πολυπλοκότητα $$\mathcal{O}(M^3)$$ και μια βελτιωμένη σε $$\mathcal{O}(M^2)$$. 
Θα ακολουθήσει η βέλτιστη λύση με πολυπλοκότητα $$\mathcal{O}(M)$$.
Τέλος θα παρουσιαστούν τρεις ακόμα υποβέλτιστες λύσεις που βασίζονται 
σε πιό σύνθετες τεχνικές, τεχνικές οι οποίες είναι χρήσιμες γενικά για επίλυση προβλημάτων, 
δεν είναι όμως απαραίτητο να τις γνωρίζει κάποιος που θέλει 
να λάβει μέρος στην Α φάση του διαγωνισμού.
Οι λύσεις αυτές είναι άμεσες βελτιώσεις της brute force λύσης. Η πρώτη έχει πολυπλοκότητα 
$$\mathcal{O}(M \cdot \sqrt{M})$$, η δεύτερη $$\mathcal{O}(M\cdot \log^2{M})$$ 
και η τελευταία $$\mathcal{O}(M\cdot \log{M})$$.

## Λύση με brute force - $$\mathcal{O}(M^3)$$

Για όλους τους συνδυασμούς $$i$$ και $$j$$ (άκρα της βάσης του παραλληλογράμμου) υπολόγισε το εμβαδό που παράγεται. 
Χρησιμοποιούνται δυο *for* για να δώσουν όλους τους δυνατούς συνδυασμούς τιμών στα $$i$$,$$j$$.  
Το ύψος του παραλληλογράμμου είναι το ελάχιστο ύψος όλων των στηλών από $$i$$ έως και $$j$$ και το 
εσωτερικό *for* φροντίζει να το βρει.
Ο χρόνος που απαιτείται για την εύρεση όλων των συνδυασμών $$i,j$$ είναι $$\mathcal{O}(M^2)$$ και η επιπλέον αναζήτηση 
του ελάχιστου ύψους χρειάζεται επιπλέον χρόνο $$\mathcal{O}(M)$$ άρα συνολικός χρόνος $$\mathcal{O}(M^3)$$.

{% include code.md solution_name='brute_nxnxn.cc' %}

## Λύση με brute force - $$\mathcal{O}(M^2)$$

Στον παραπάνω κώδικα το εξωτερικό *for* καθορίζει το $$i$$ και το ενδιάμεσο το $$j$$. 
Προφανώς $$\min{\{H_i \cdots H_j\}} \geq \min{\{H_i \cdots H_{j+1}\}}$$ άρα 
όταν έχουμε το ελάχιστο ύψος στο διάστημα $$[H_i,H_j]$$ μπορούμε με μια και μόνο σύγκριση να βρούμε το 
ελάχιστο ύψος στο διάστημα $$[H_i,H_{j+1}]$$ καταργώντας το τρίτο *for*. 
Ο χρόνος εκτέλεσης βελτιώνεται σε $$\mathcal{O}(M^2)$$. 

{% include code.md solution_name='brute_nxn1.cc' start=17 end=23 %}

Οι παραπάνω λύσεις "ορίζουν" τα άκρα του παραλληλογράμμου και υπολόγιζαν το ύψος. Εναλλακτικά μπορούμε να 
"ορίσουμε" το ύψος του παραλληλογράμμου σε $$H_i$$ (δηλαδή να δοκιμάσουμε κάθε στήλη) και να αναζητήσουμε 
τα άκρα του, ολισθαίνοντας δυο δείκτες $$\texttt{left}, \texttt{right}$$ αριστερά και δεξιά του $$i$$ 
όσο βρίσκουμε "συμβατές" στήλες με τη $$i$$, δηλαδή στήλες που έχουν ύψος τουλάχιστον $$H_i$$.  
Όταν δεν μπορούμε να επεκτείνουμε άλλο τους δυο δείκτες, έχουμε το 
βρει το μεγαλύτερα παραλληλόγραμμο με ύψος $$H_i$$ που περιέχει τη στήλη $$i$$.

Την παραλλαγή αυτή θα τη βρείτε [εδώ]({% include link_to_source.md solution_name='brute_nxn2.cc' %})
 
## Βέλτιστη λύση - Monotonic Stack - $$\mathcal{O}(M)$$

**Παρατήρηση 2** Κάθε στήλη $$i$$ μπορεί να επεκταθεί προς τα δεξιά όσο οι επόμενες έχουν ύψος τουλάχιστον $$H_i$$. 
Αν εμφανιστεί στήλη $$j \gt i$$ με $$H_j \lt H_i$$ τότε η στήλη $$i$$ δεν επεκτείνεται 
άλλο προς τα δεξιά και καταργείται.

**Παρατήρηση 3** Κάθε στήλη $$j$$ που οδήγεισε σε κατάργηση κάποια αριστερότερη στήλη $$i$$, επεκτείνεται αριστερά 
μέχρι το σημείο που επεκτεινόταν η $$i$$. Παράδειγμα, έστω ότι έχουμε συναντήσει μια στήλη με ύψος $$H_i$$ π
ου επεκτείνεται αριστερά έως τη θέση $$k$$ (προφανώς $$k\leq i$$) και ακολούθως έρχεται μια στήλη με ύψος $$H_j\lt H_i$$. 
 Τότε η στήλη με ύψος $$i$$ καταργείται και η στήλη με ύψος $$H_j$$ επεκτείνεται αριστερά στη θέση $$k$$ (εφόσον 
 η στήλη ύψους $$H_i$$ που κατήργεισε ήταν ψηλότερη από την $$H_j$$).
 
Διατρέχουμε τις στήλες από αριστερά προς τα δεξιά κρατώντας σε μια στοίβα (stack) τα ενεργά ύψη. 
Ως ενεργά θεωρούμε τα ύψη που μπορούν να επεκταθούν δεξιότερα. 
Μόλις εμφανιστεί ένα μικρότερο ύψος από αυτό που υπάρχει στην κορυφή της στοίβας, καταργούμε όσα μεγαλύτερα ύψη
βρίσκονται ήδη στην κορυφή της στίβας διότι δεν επεκτείνονται άλλο. Με τη μέθοδο αυτή καταλήγουμε να έχουμε μια 
μονότονη (αύξoυσα στην περίπτωση μας) διάταξη των υψών στη στοίβα, γι'αυτό και η ονομασία monotonic stack.

Στη συνέχεια θα εξηγηθεί η λειτουργία του αλγορίθμου με το 1<sup>o</sup> παράδειγμα της εκφώνησης. 

|       | **olivetrees** |
| :--- | :--- |
| Θέση στήλης<br>Ύψος στήλης | 1 2 3 4 5 6 7<br>2 1 4 5 1 3 3 |
{:.table_with_borders.table_with_monospace_font}

* Διαβάζουμε το ύψος $$2$$ που ξεκινά από τη στήλη $$1$$ και το βάζουμε στη στοίβα.
* Διαβάζουμε το ύψος $$1$$ και καθώς είναι μικρότερο από το ύψος $$2$$ στην κορυφή της στοίβας, 
το $$2$$ δεν μπορεί να επεκταθεί άλλο.
 Το εμβαδό που σχημάτισε το ύψος $$2$$ είναι $$2\times 1$$ καθώς επεκτάθηκε σε μια μόνο στήλη. 
 Τώρα μπορούμε να προσθέσουμε το ύψος $$1$$ στη στοίβα. 
Το ύψος $$1$$ ξεκινά από τη στήλη $$1$$ (παρόλο που το βρήκαμε στη στήλη $$2$$ 
στο αρχείο εισόδου) καθότι είναι μικρότερο από το ύψος $$2$$ που πετάξαμε 
και μπορεί να επεκταθεί μέχρι τη στήλη που ξεκινούσε το ύψος $$2$$.
* Διαβάζουμε το ύψος $$4$$ (ξεκινά από τη στήλη $$3$$) και το προσθέτουμε στη στοίβα.
* Διαβάζουμε το ύψος $$5$$ (ξεκινά από τη στήλη $$4$$) και το προσθέτουμε στη στοίβα.
* Διαβάζουμε το ύψος $$1$$ (της στήλης $$5$$) και καθώς είναι μικρότερο από το $$5$$ 
που βρίσκεται στην κορυφή της στοίβας, 
θα το διαγράψει. Το $$5$$ κατάφερε να καλύψει εμβαδό $$5\times 1$$. 
Κατόπιν παρατηρούμε ότι στην κορυφή της στοίβας 
υπάρχει το $$4$$ που και αυτό θα διαγραφεί. Το εμβαδό που πέτυχε είναι $$4 \times 2$$ 
εφόσον επεκτάθηκε έως την $$4$$ στήλη.
Τώρα στη στοίβα υπάρχει το ύψος $$1$$ που είναι ίσο με το τωρινό μας ύψος. 
Δεν χρειάζεται να προσθέσουμε και το τωρινό $$1$$, θα ήταν πλεονασμός.
* Διαβάζουμε το ύψος $$3$$ (ξεκινά στη στήλη $$6$$) και το βάζουμε στη στοίβα.
* Διαβάζουμε το ύψος $$3$$ (ξεκινά στη στήλη $$7$$). Δεν χρειάζεται να το βάλουμε 
στη στοίβα καθώς υπάρχει ήδη.
* Εξαντλήθηκαν οι στήλες μας αλλά έχουν μείνει στη στοίβα κάποια ύψη. 
Τα ύψη αυτά "επέξησαν" έως και τη στήλη $$M$$ ($$7$$ στο παράδειγμα μας) άρα υπολογίζουμε 
 το εμβαδό καθενός από αυτά πριν το διαγράψουμε από τη στοίβα.

{% include code.md solution_name='stack_n.cc' %}

## Λύση με sqrt decomposition - $$\mathcal{O}(M \cdot \sqrt{M})$$

Η ακόλουθη λύση βασίζεται στην τεχνική sqrt-decomposition και δεν έχει προαπαιτούμενες γνώσεις για να διαβαστεί. 
Αν θέλετε να μάθετε παραπάνω δείτε [εδώ](https://cp-algorithms.com/data_structures/sqrt_decomposition.html) και 
[εδώ](https://usaco.guide/plat/sqrt?lang=cpp).

Το μειονέκτημα της brute force λύσης είναι ότι εξετάζουμε πολλές φορές ένα ένα τα ύψη των γειτονικών στηλών καθώς 
ολισθαίνουμε τους δύο δείκτες μας για να βρούμε όλες τις στήλες $$j$$ με $$H_j \ge H_i$$. 
Αν μοιράσουμε τις $$M$$ στήλες σε ομάδες (buckets) από $$\sqrt{M}$$ γειτονικές στήλες και 
προϋπολογίσουμε το ελάχιστο ύψος σε κάθε ομάδα, 
μπορούμε να ολισθαίνουμε τους δείκτες μας κατά $$\sqrt{M}$$ στήλες σε χρόνο $$\mathcal{O}(1)$$ 
επιταχύνοντας την προηγούμενη λύση[^1]. Παρατηρήστε πως τα $$M$$ ύψη χωρίζονται 
σε $$S$$ ομάδες μεγέθους $$\sqrt{M}$$ όπου σε κάθε ομάδα $$i$$ έχει προϋπολογιστεί η ελάχιστη τιμή $$B_i$$:
  
$$\underbrace{H_0, H_1, \dots, H_{\sqrt{M}-1}}_{B_0}, \underbrace{H_{\sqrt{M}, \dots, H_2\cdot\sqrt{M}-1}}_{B_1}, \dots, \underbrace{H_{\sqrt{M}\cdot S -1}, \dots, H_{M-1}}_{B_{S-1}}$$

Αν η αρχή ή/και το τέλους του μεγαλύτερου παραλληλογράμμου που 
περιέχει τη στήλη $$i$$ και έχει ύψος $$H_i$$ δεν βρίσκονται ακριβώς πάνω στα όρια της ομάδας του, θα χρειαστεί 
να εξετάσουμε τις στήλες της ομάδας μία μία σειριακά. Αυτό όμως δεν αλλάζει την πολυπλοκότητα καθώς σε κάθε 
αναζήτηση, μόνο δυο ομάδες των $$\sqrt{M}$$ στηλών μπορούν να αναζητηθούν σειριακά ενώ για τις 
ενδιάμεσες το πολύ $$\sqrt{M}$$ ομάδες, οι ελάχιστες τιμές είναι προϋπολογισμένες.   
Συνολικός χρόνος επίλυσης $$\mathcal{O}(M \cdot \sqrt{M})$$.

{% include code.md solution_name='sqrt_NsqrtN.cc' start=9 end=36 %}
{% include code.md solution_name='sqrt_NsqrtN.cc' start=57 end=82 %}

Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='sqrt_NsqrtN.cc' %})

## Δυαδική αναζήτηση σε RMQ segment tree - $$\mathcal{O}(M \cdot \log^2{M})$$

Η αναζήτηση της μικρότερης τιμής σε ένα συνεχόμενο τμήμα (segment) γνωστών άκρων ενός πίνακα, ονομάζεται RMQ (Range Minimum Query).
Ερωτήματα RMQ μπορούν να απαντηθούν με τη SQRT decomposition (που ομοιάζει με τον παραπάνω κώδικα), με 
δέντρα διαστημάτων[^3] (segment trees) αλλά και με άλλους τρόπους όπως ο αραιός πίνακας[^2] που θα δούμε στην επόμενη λύση. 
Η χρήση ενός segment tree μας επιτρέπει να προϋπολογίσουμε με την τεχνική διαίρει 
και βασίλευε τον πίνακα των υψών και να αποθηκεύσουμε 
τις ελάχιστες τιμές των διαστημάτων που προκύπτουν, στους κόμβους του segment tree. Κάθε αναζήτηση για την ελάχιστη 
τιμή σε οποιοδήποτε διάστημα $$[\texttt{left}, \texttt{right}]$$ γίνεται σε χρόνο $$\mathcal{O}(\log{M})$$.

Έστω ότι η στήλη $$i$$ μπορεί να επεκταθεί έως και τη $$j$$ σχηματίζοντας το μεγαλύτερο παραλληλόγραμμο. 
Όλες οι αναζητήσεις από τη στήλη $$i$$ έως και τη θέση $$j$$ θα δίνουν αποτέλεσμα RMQ τουλάχιστο $$H_i$$ 
ενώ όλες οι αναζητήσεις πέρα του $$j$$ θα δίνουν RMQ μικρότερο από $$H_i$$. 
Αυτό πολύ απλά σημαίνει ότι έχουμε μονοτονία και μπορεί να εφαρμοστεί δυαδική 
αναζήτηση για να βρεθεί η στήλη $$j$$. Κάνοντας δυαδική αναζήτηση από τη στήλη $$i$$ προς τα δυο άκρα του πίνακα, 
βρίσκουμε πόσο επεκτείνεται το παραλληλόγραμμο αριστερά και δεξιά της. 
Για κάθε στήλη κάνουμε δυαδική αναζήτηση η οποία θα κάνει αναζήτηση στο segment tree,
άρα για κάθε στήλη θέλουμε $$\mathcal{O}(\log^2{M})$$ χρόνο. 
Συνολική πολυπλοκότητα $$\mathcal{O}(M \cdot \log^2{M})$$.
 
{% include code.md solution_name='st_nlog2n.cc' start=40 end=63 %}

Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='st_nlog2n.cc' %})

## RMQ με αραιό πίνακα (sparse table) - $$\mathcal{O}(M \cdot \log{M})$$

Αναζήτηση RMQ μπορεί να γίνει και με αραιό πίνακα (sparse table)[^2], δηλαδή για όλες τις $$M$$ θέσεις του πίνακα, 
να προϋυπολογίσουμε τις ελάχιστες τιμές για διαστήματα πλάτους $$2^0, 2^1, 2^2, 2^3, \dots , 2^{\lfloor\log_2{M}\rfloor}$$ συνεχόμενων τιμών 
που ξεκινούν από κάθε θέση $$i$$. Ο προϋπολογισμός απαιτεί μνήμη και χρόνο της τάξης $$\mathcal{O}(M \cdot \log{M})$$.
Έχοντας προϋπολογίσει τις RMQ τιμές των παραπάνω διαστημάτων, θα μπορούσαμε να απαντάμε σε χρόνο $$\mathcal{O}(1)$$ 
ερωτήματα RMQ για οποιοδήποτε διάστημα $$[\texttt{left}, \texttt{right}]$$ όταν γνωρίζουμε τα άκρα του. 
Στην περίπτωση μας όμως τα άκρα του διαστήματος με $$\texttt{RMQ}\geq H_i$$ δεν είναι γνωστά και τα αναζητούμε. 
Θα μπορούσαμε να τα βρούμε κάνοντας δυαδική αναζήτηση 
και καταλήγοντας σε πολυπλοκότητα όμοια με την προηγούμενη λύση, όμως υπάρχει καλύτερη λύση. 
Ας υποθέσουμε ότι το άκρο του μεγαλύτερου παραλληλογράμμου που προκύπτει επεκτείνωντας τη στήλη $$i$$ προς τα δεξιά 
έχει απόσταση $$x$$ από τη στήλη $$i$$. Ο αριθμός $$x$$ είναι άγνωστος, όμως 
έχει την ιδιότητα ότι όλα τα ερωτήματα RMQ μεταξύ του $$i$$ και του $$x$$ δίνουν τιμές τουλάχιστο $$H_i$$ ενώ όλα 
τα μεγαλύτερα διαστήματα έχουν μικρότερες τιμές (ή δεν ορίζονται). Κάθε ακέραιος αριθμός $$x$$ αναπαρίσταται ως 
άθρoισμα δυνάμεων του δυο (το γνωστό μας δυαδικό σύστημα). Αρκεί λοιπόν να ξεκινήσουμε από τη μέγιστη προϋπολογισμένη 
δύναμη του $$2$$ στον αραιό πίνακα και να την χρησιμοποιήσουμε αν δεν μας δίνει $$RMQ\lt H_i$$ για να επεκτείνουμε 
το παραλληλόγραμμο μας. Αν η χρήση της δύναμης του $$2$$ μας δίνει $$RMQ\lt H_i$$ σημαίνει ότι ξεπεράσαμε το $$x$$. 
Με τον τρόπο αυτό ενσωματώνουμε τη δυαδική αναζήτηση 
με τα RMQ ερωτήματα και για κάθε στήλη $$i$$ χρειαζόμαστε χρόνο 
$$\mathcal{O}(\log{M})$$ για να βρούμε το μεγαλύτερo παραλληλόγραμμο της. 
Συνολική πολυπλοκότητα $$\mathcal{O}(M \cdot \log{M})$$.

{% include code.md solution_name='sparse_nlogn.cc' start=25 end=47 %}

Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='sparse_nlogn.cc' %})

[^1]: Έστω ότι χωρίσουμε τα $$M$$ στοιχεία σε ομάδες μεγέθους $$K$$, τότε η διάσχιση όλων των ομάδων θα χρειαζόταν χρόνο $$\mathcal{O}(\frac{M}{K})$$ ενώ η σειριακή διάσχιση μίας ομάδας θα χρειαζόταν χρόνο $$\mathcal{O}(K)$$. Είναι επιθυμητό η σειριακή διάσχιση μίας ομάδας $$K$$ στοιχείων να έχει ίδια πολυπλοκότητα με τη διάσχιση όλων των $$\frac{M}{K}$$ ομάδων, άρα $$\frac{M}{K}=K,K \gt 0,M \gt 0\Rightarrow M=K^2 \Rightarrow K=\sqrt{M}$$

[^2]: [sparse table](https://cp-algorithms.com/data_structures/sparse-table.html)

[^3]: [Segment Tree](https://kallinikos.github.io/Segment-Trees)
