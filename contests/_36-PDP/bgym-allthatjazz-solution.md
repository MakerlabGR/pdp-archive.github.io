---
layout: solution
codename: allthatjazz
---

## Επεξήγηση εκφώνησης

Ζητείται να βρούμε τον μέγιστο αριθμό συναυλιών (πλήθος διαδοχικών αριθμών $$D_i$$) που χωρούν σε οποιοδήποτε "παράθυρο" $$K$$ ημερών. Έστω ότι ξεκινάμε να μετράμε από την ημερομηνία $$D_i$$ ($$1\le i \le N$$), τότε μας ενδιαφέρει 
να βρούμε την τελευταία (δεξιότερη) ημερομηνία $$D_m$$ όπου $$i\le m$$ και $$D_m - D_i + 1 \le K$$.
Προϋπόθεση βέβαια είναι οι μέρες $$D_i$$ να είναι ταξινομημένες σε αύξουσα σειρά.

## Εξαντλητική αναζήτηση $$\mathcal{O}(Q \cdot N^2)$$

Για κάθε δυνατή ημερομηνία έναρξης $$D_i$$, αναζητούμε την μέγιστη ημερομηνία $$D_m$$ ώστε $$D_m-D_i \lt K$$.

Θα χρησιμοποιήσουμε τρεις εμφωλευμένους βρόγχους: τον εξωτερικό για τα $$Q$$ ερωτήματα, τον ενδιάμεσο για την δοκιμή κάθε 
δυνατού $$i$$ και το εσωτερικό για την εύρεση του $$m$$. Ο απαιτούμενος χρόνος είναι της τάξης $$\mathcal{O}(Q \cdot N^2)$$

{% include code.md solution_name='brute.cc' %}

## Λύση με χρήση δυαδικής αναζήτησης $$\mathcal{O}(Q \cdot N \cdot \log{N})$$

Στην πρoηγούμενη λύση μπορούμε να βελτιώσουμε τον εσωτερικό βρόγχο από $$N$$ βήματα σε $$\log{N}$$ με τη χρήση δυαδικής αναζήτησης (καθώς ο πίνακας $$D$$ είναι ταξινομημένος). Η *stl* της *C++* παρέχει έτοιμες συναρτήσεις για δυαδική 
αναζήτηση, όπως τη ```lower_bound``` και την ```upper_bound```.

H ```lower_bound```	εντοπίζει την αριστερότερη θέση που βρίσκεται αριθμός ίσος ή μεγαλύτερος από την τιμή αναζήτησης, ενώ η ```upper_bound``` επιστρέφει την αριστερότερη θέση με αριθμό *μεγαλύτερο* από την τιμή αναζήτησης.   
Και οι δυο συναρτήσεις όταν εφαρμοστούν σε πίνακα, επιστρέφουν αντικείμενο τύπου *random iterator*. Αφαιρώντας από τον επιστρεφόμενο *iterator*, τον *iterator* της πρώτης θέσης του πίνακα ```D.begin()```, έχουμε τη θέση στον πίνακα $$D$$ σε ακέραια τιμή.

{% include code.md solution_name='bsearch.cc' start=17 end=21 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='bsearch.cc' %})

## Βέλτιστη λύση με τη χρήση δύο δεικτών $$\mathcal{O}(Q \cdot N)$$

Στις προηγούμενες λύσεις, για κάθε αρχή παρακολούθησης συναυλιών $$D_i$$, αναζητούσαμε την τελευταία 
συναυλία που μπορούσαμε να παρακολουθήσουμε ώστε να μην υπερβούμε τις $$K$$ μέρες που έχουμε στη διάθεση μας από την αρχή (δηλαδή από την $$D_i$$). Αυτό το κάναμε ξανά και ξανά καθώς το $$i$$ αυξανόταν με αποτέλεσμα να ξαναελέγχουμε τις 
ίδιες θέσεις πολλές φορές.
Ας παρατηρήσουμε όμως, ότι αν ξεκινήσουμε από τη μέρα $$i+1$$, δεν υπάρχει περίπτωση να μην φτάσουμε έως και την ημέρα 
$$m$$ που είχαμε φτάσει ξεκινώντας από τη θέση $$i$$. Αρκεί λοιπόν να διατηρήσουμε δύο δείκτες, ο ένας να είναι ο 
$$i$$ που δείχνει τη μέρα $$D_i$$ που ξεκινάμε την παρακολούθηση συναυλιών και έναν δείκτη $$m$$ που δείχνει την 
τελευταία συναυλία στη μέρα $$D_m$$ που μπορούμε να παρακολουθήσουμε ώστε να μην υπερβούμε τις $$K$$ μέρες. Και οι δύο 
δείκτες μόνο αυξάνονται.

Για κάθε $$i$$ ο δείκτης $$m$$ μπορεί να αυξηθεί έως $$N$$ φορές, όμως για όλα τα $$i$$, ο δείκτης $$m$$ θα αυξηθεί συνολικά $$N$$ φορές. 
Άρα για κάθε ερώτημα, θα χρειαστούμε χρόνο $$\mathcal{O}(N)$$, οπότε για τα $$Q$$ ερωτήματα θα 
χρειαστούμε $$\mathcal{O}(Q \cdot N)$$ χρόνο.

{% include code.md solution_name='2pointers.cc' start=17 end=25 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='2pointers.cc' %})
