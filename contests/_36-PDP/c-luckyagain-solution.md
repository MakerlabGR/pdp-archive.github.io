---
layout: solution
codename: luckyagain
---

## Επεξήγηση εκφώνησης

Ένας αριθμός είναι τυχερός αν έχει ζυγό αριθμό ψηφίων και τα πρώτα μισά του ψηφία έχουν το ίδιο άθροισμα με τα τελευαία μισά.

Μας δίνεται μία λίστα από $$N$$ αριθμούς και πρέπει να βρούμε πόσα ζευγάρια από αριθμούς μπορούμε να ενώσουμε ώστε να πάρουμε έναν τυχερό αριθμό.

## Υπολογίζοντας τα ψηφία ενός αριθμού

Στις δύο παρακάτω λύσεις θα χρησιμοποιήσουμε τον παρακάτω αλγόριθμο για την εύρεση των δεκαδικών ψηφίων ενός αριθμού. Ο αλγόριθμος βρίσκει διαδοχικά το τελευταίο ψηφίο του αριθμού (δηλαδή το υπόλοιπο του αριθμού με το $$10$$), αφαιρεί το τελευταίο ψηφίο (δηλαδή διαιρεί (ακέραια) τον αριθμό με το $$10$$) και συνεχίζει με τον υπόλοιπο αριθμό μέχρι να γίνει $$0$$. Για παράδειγμα, αν ξεκινήσουμε με τον αριθμο $$x = 257$$:
 - Στην πρώτη επανάληψη, λαμβάνουμε $$257 \bmod 10 = 7$$ (το πρώτο ψηφίο) και έπειτα θέτουμε $$x = 257 / 10 = 25$$.
 - Στην δεύτερη επανάληψη, λαμβάνουμε $$25 \bmod 10 = 5$$ (το δεύτερο ψηφίο) και έπειτα θέτουμε $$x = 25 / 10 = 2$$.
 - Στην δεύτερη επανάληψη, λαμβάνουμε $$25 \bmod 10 = 2$$ (το τρίτο ψηφίο) και έπειτα θέτουμε $$x = 2 / 10 = 0$$.
 - Ο αριθμός έγινε μηδέν επομένως δεν έχει άλλα ψηφία.

Ο παρακάτω κώδικας υλοποιεί αυτόν τον αλγόριθμο και χρειάζεται χρόνο γραμμικό στο πλήθος των ψηφίων του αριθμού:

{% include code.md solution_name='luckyagain_brute_force.cc' start=38 end=41 %}

## Εξαντλητική λύση

Χρησιμοποιώντας τον παραπάνω αλγόριθμο για την εύρεση των ψηφίων ενός αριθμού, μπορούμε να ελέγξουμε αν ένωση δύο αριθμών είναι τυχερός αριθμός "ενώνοντας" τα ψηφία τους, αθροίζοντας τα πρώτα και τα τελευταία μισά, και τέλος ελέγχοντας αν το άθροισμά τους είναι ίσο. Ο αλγόριθμος που το κάνει αυτό είναι ο εξής (και είναι γραμμικός στο πλήθος των ψηφίων):

{% include code.md solution_name='luckyagain_brute_force.cc' start=7 end=24 %}

Τέλος αρκεί να ελέγξουμε κάθε δυνατό ζεύγος από τους δοσμένους αριθμούς και να μετρήσουμε το πλήθος αυτών που σχηματίζουν τυχερούς αριθμούς.

{% include code.md solution_name='luckyagain_brute_force.cc' start=48 end=55 %}

Συνολικά κάνουμε $$\mathcal{O}(N^2)$$ ελέγχους και κάθε ένας από αυτούς χρειάζεται το πολύ σταθερό αριθμό πράξεων (γιατί τα ψηφία κάθε αριθμού είναι το πολύ $$9$$). Μπορείτε να βρείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='luckyagain_brute_force.cc' %})

## Βέλτιστη λύση

Ας υποθέσουμε ότι για κάποιον αριθμό $$x$$ θέλουμε να μετρήσουμε όλους τους αριθμούς $$y$$ για τους οποίους ισχύει ότι η ένωση τους $$xy$$ είναι τυχερός αριθμός. Το ποια ψηφία του $$x$$ συνεισφέρουν στο πρώτο ή στο δεύτερο μισό του ενωμένου αριθμού, εξαρτάται από το που βρίσκεται το μέσο τους. Ας θεωρήσουμε ότι το μέσο τους βρίσκεται αμέσως μετά το $$i$$-οστό ψηφίο του $$x$$. Τότε, αν $$\ell_x$$ είναι το πλήθος των ψηφίων του $$x$$, ψάχνουμε για οποιουσδήποτε αριθμούς $$y$$ με $$\ell_y = 2i - \ell_x$$ ψηφία (καθώς πρέπει $$i = (\ell_x - i) + \ell_y$$ για να είναι $$i$$ το μέσο) και άθροισμα ψηφίων $$s_y$$ τέτοιο ώστε

$$x_1 + \ldots x_i = x_{i+1} + \ldots + x_{\ell_x} + s_y \Leftrightarrow s_y = (x_1 + \ldots x_i) - (x_{i+1} + \ldots + x_{\ell_x}).$$

<center>
<img width=450px src="/assets/36-c-luckyagain.svg"/>
</center>

Προϋπολογίζουμε τον πίνακα $$\texttt{count}[\ell][s]$$, που κρατάει το πλήθος των αριθμών με $$\ell$$ ψηφία και άθροισμα ψηφίων $$s$$. Έπειτα, για κάθε αριθμό $$x$$ διατρέχουμε όλες τις θέσεις $$i$$ των ψηφίων του και αθροίζουμε το πλήθος των αριθμών 
$$\texttt{count}[2i - \ell_x][(x_1 + \ldots x_i) - (x_{i+1} + \ldots + x_{\ell_x})]$$.

Μία αντίστοιχη συμμετρική συνθήκη προκύπτει όταν το $$x$$ έρχεται μετά το $$y$$ (και το μέσο βρίσκεται πάλι στο $$x$$). Χρειάζεται λίγο προσοχή με τα ζεύγη αριθμών με το ίδιο πλήθος ψηφίων, ώστε να μην τα διπλομετρήσουμε. Στον παρακάτω κώδικα η μεταβλητή $$\texttt{same\_digit\_count}$$ φροντίζει για αυτό. 


Κάθε πρόσβαση στον πίνακα κατακερματισμού χρειάζεται $$\mathcal{O}(1)$$ χρόνο (ή $$\mathcal{O}(\log N)$$ αν χρησιμοποιήσουμε map) και επειδή κάθε αριθμός έχει το πολύ $$9$$ ψηφία, συνολικά ο αλγόριθμος χρειάζεται $$\mathcal{O}(N)$$ χρόνο. Ο κώδικας δίνεται παρακάτω.

{% include code.md solution_name='luckyagain_efficient.cc' %}


