---
layout: solution
codename: bitsign
---

## Επεξήγηση εκφώνησης 

Μας δίνεται μία ακολουθία $$\texttt{c}$$ με χαρακτήρες '0', '1' και '.', και μία ακολουθία $$\texttt{s}$$ με ακέραιους αριθμούς. Μας ζητείται να βρούμε με πόσους τρόπους μπορούμε να αντικαταστήσουμε τους χαρακτήρες '.' με ψηφία '0' ή '1' στην $$\texttt{c}$$ ώστε η ακολουθία του πλήθους των διαδοχικών '1' να είναι η $$\texttt{s}$$.

Για παράδειγμα, για τις ακολουθίες $$\texttt{c} = \texttt{0..00..000.110}$$ και $$\texttt{s} = \texttt{1 1 3}$$, δύο πιθανές απαντήσεις είναι οι εξής:

$$\texttt{0\underline{\textcolor{red}{1}0}00\underline{\textcolor{red}{1}0}000\underline{\textcolor{red}{1}}\textcolor{red}{11}0} \quad \text{και} \quad  \texttt{0\underline{\textcolor{red}{1}0}00\underline{0\textcolor{red}{1}}000\underline{\textcolor{red}{1}}\textcolor{red}{11}0}.$$

## Εξαντλητική λύση

Μία λύση είναι να δοκιμάσουμε όλες τις δυνατές τιμές $$0$$ και $$1$$ για κάθε θέση της $$\texttt{c}$$ που έχει '.'. Στην χειρότερη περίπτωση χρειάζεται να ελέγξουμε $$\Theta(2^N)$$ δυνατές ακολουθίες, επομένως ο αλγόριθμος χρειάζεται $$\mathcal{O}(2^N)$$ χρόνο.

Μπορούμε να υλοποιήσουμε αυτές τις δοκιμές αναδρομικά ως εξής:

{% include code.md solution_name='bitsign_brute_force.cc' start=13 end=30 %}

και η αρχική κλήση είναι η εξής:
{% include code.md solution_name='bitsign_brute_force.cc' start=49 end=50 %}

Μπορείτε να βρείτε ολόκληρο των κώδικα [εδώ]({% include link_to_source.md solution_name='bitsign_brute_force.cc' %}).

## Λύση με δυναμικό προγραμματισμό σε $$\mathcal{O}(N^2 M)$$ χρόνο

Ο παραπάνω αναδρομικός αλγόριθμος μπορεί να λύσει πολλές φορές το ίδιο υποπρόβλημα. Θα χρησιμοποιήσουμε [δυναμικό προγραμματισμό](https://kallinikos.github.io/Dynamic-Programming), μία αποδοτική τεχνική που σπάει το πρόβλημα σε διαδοχικά μικρότερα υποβροβλήματα και για κάθε ένα από αυτά υπολογίζει την λύση μία φορά.

Ορίζουμε ως `dp[j][i]` το πλήθος των δυνατών τρόπων να αντισταταστήσουμε τα '.' στις θέσεις `c[1..i]` ώστε να έχουμε συμπληρώσει ακολουθίες διαδοχικών άσων με μήκη `s[1..j]`. Για χάριν ευκολίας, λέμε ότι *συμπληρώνεται* μία ακολουθία από διαδοχικούς άσους αφού προσθέσουμε το μηδέν μετά τον τελευταίο άσο. Επιπλέον, προσθέτουμε ένα μηδενικό στο τέλος του `c` (το οποίο δεν αλλάζει την απάντηση), ώστε να ολοκληρωθεί η τελευταία ακολουθία από άσους. Άρα σε κάθε θέση `c[i] = ‘1’` έχουμε εξ ορισμού ότι `dp[j][i] = 0`.

Αν το στοιχείο `c[i] = ‘0'` ή `c[i] = ‘.'`, έχουμε δύο τρόπους να επεκτείνουμε τις υπάρχουσες ακολουθίες:
 1. Επεκτείνουμε όλες τις λύσεις στο `dp[j][i-1]` προσθέτοντας ένα μηδενικό στο τέλος τους. 
 2. Αν μπορούμε να βάλουμε `s[j]` άσους στις θέσεις `c[(i - s[j] - 1)..(i-1)]`, δηλαδή αυτές οι θέσεις έχουν μόνο χαρακτήρες '1' ή '.', τότε έχουμε `dp[j - 1][i - s[j] - 1]` επιπλέον τρόπους.

<center>
<img width=350px src="/assets/36-c-bitsign.svg"/>
</center>

Ο παρακάτω κώδικας συμπληρώνει τον πίνακα `dp` και η απάντηση βρίσκεται στην θέση `dp[M][N+1]`.
{% include code.md solution_name='bitsign_dp_n3.cc' start=30 end=42 %}

Ο έλεγχος για τα στοιχεία `c[(i-s[j]-1)..(i-1)]` χρειάζεται $$\mathcal{O}(N)$$ χρόνο, άρα αφού υπάρχουν $$\mathcal{O}(NM)$$ θέσεις στον πίνακα `dp`, συνολικά ο αλγόριθμος χρειάζεται $$\mathcal{O}(N^2M)$$ χρόνο και $$\mathcal{O}(NM)$$ μνήμη.

Μπορείτε να βρείτε ολόκληρο των κώδικα [εδώ]({% include link_to_source.md solution_name='bitsign_brute_force.cc' %}).

## Λύση με δυναμικό προγραμματισμό (σε $$\mathcal{O}(N M)$$ χρόνο)

Μπορούμε να επιταγχύνουμε την προηγούμενη λύση προϋπολογίζοντας τις τιμές `first_zero_to_left` για κάθε θέση `i` σε χρόνο $$\mathcal{O}(N)$$ (ακόμα και $$\mathcal{O}(N^2)$$ θα ήταν αρκετό), ως εξής:

{% include code.md solution_name='bitsign_dp_n2.cc' start=28 end=37 %}

Ο κυρίως κώδικας αλλάζει ως εξής:

{% include code.md solution_name='bitsign_dp_n2.cc' start=41 end=50 %}

Έτσι χρειάζομαστε $$\mathcal{O}(1)$$ χρόνο για τον υπολογισμό της κάθε τιμής του πίνακα $$\texttt{dp}$$, συνεπώς ο αλγόριθμος τρέχει σε $$\mathcal{O}(NM)$$ χρόνο. Μπορείτε να βρείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='bitsign_dp_n2.cc' %}).

Επιπλέον αν παρατηρήσετε ότι για τον υπολογισμό των τιμών $$\texttt{dp}[j][\cdot]$$ χρησιμοποιούμε μόνο τις τιμές $$\texttt{dp}[j-1][\cdot]$$, μπορούμε να κρατάμε μόνο δύο γραμμές στον πίνακα `dp`, μειώνοντας τον συνολικό χώρο σε $$\mathcal{O}(N)$$. Δείτε [εδώ]({% include link_to_source.md solution_name='bitsign_dp_n2_mem.cc' %}).
