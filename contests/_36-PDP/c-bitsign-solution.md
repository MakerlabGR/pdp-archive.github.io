---
layout: solution
codename: bitsign
---

## Επεξήγηση εκφώνησης 

Μας δίνεται μία ακολουθία $$\texttt{c}$$ από τους χαρακτήρες '0', '1' και '.', και μία ακολουθία $$\texttt{s}$$ από αριθμούς. Πρέπει να βρούμε με πόσους τρόπους μπορούμε να αντικαταστήσουμε τα '.' με ψηφία '0' ή '1' ώστε η ακολουθία του πλήθους των διαδοχικών '1' να είναι η $$\texttt{s}$$.

Για παράδειγμα, για τις ακολουθίες $$\texttt{c} = \texttt{0..00..000.110}$$ και $$\texttt{s} = \texttt{1 1 3}$$ δύο πιθανές απαντήσεις είναι οι εξής:

$$\texttt{0\underline{\textcolor{red}{1}0}00\underline{\textcolor{red}{1}0}000\underline{\textcolor{red}{1}}\textcolor{red}{11}0} \quad \text{και} \quad  \texttt{0\underline{\textcolor{red}{1}0}00\underline{0\textcolor{red}{1}}000\underline{\textcolor{red}{1}}\textcolor{red}{11}0}.$$

## Εξαντλητική λύση

Μία λύση είναι να δοκιμάσουμε όλες τις δυνατές τιμές $$0$$ και $$1$$ για κάθε θέση της $$\texttt{c}$$ που έχει '.'. Στην χειρότερη περίπτωση αυτή η λύση χρειάζεται $$\Theta(2^N)$$ χρόνο.

Η κυρίως αναδρομική συνάρτηση είναι η εξής:

{% include code.md solution_name='bitsign_brute_force.cc' start=13 end=28 %}

και η κλήση:
{% include code.md solution_name='bitsign_brute_force.cc' start=47 end=48 %}

Μπορείτε να βρείτε ολόκληρο των κώδικα [εδώ]({% include link_to_source.md solution_name='bitsign_brute_force.cc' %}).

## Λϋση με δυναμικό προγραμματισμό (σε $$\mathcal{O}(N^2 \cdot M)$$ χρόνο)

Ο παραπάνω αναδρομικός αλγόριθμος λύνει πολλές φορές το ίδιο υποπρόβλημα. Θα χρησιμοποιήσουμε δυναμικό προγραμματισμό, μία αποδοτική τεχνική που υπολογίζει την λύση για κάθε υποπρόβλημα μία φορά.

Ορίζουμε ως $$\texttt{dp}[j][i]$$ το πλήθος των δυνατών τρόπων να διαλέξουμε αριθμούς για τις θέσεις $$c[1..i]$$ και να έχουμε συμπληρώσει τα διαστήματα $$s[1..j]$$. Για χάριν ευκολίας, θα συμπληρώνουμε τα διαστήματα αφού προσθέσουμε το μηδέν μετά την ακολουθία από άσους (και προσθέτουμε και ένα μηδενικό στο τέλος του πίνακα, που δεν αλλάζει την απάντηση). Άρα $$\texttt{dp}[j][i] = 0$$ όταν $$c[i] = `1\text{’}$$.

Αν το στοιχείο $$c[i] = `0\text{’}$$ ή $$c[i] = `.\text{’}$$, τότε απευθείας έχουμε ότι μπορούμε να επεκτίνουμε όλες τις λύσεις στο $$\texttt{dp}[j][i-1]$$ προσθέτοντας ένα μηδενικό στο τέλος τους. Επιπλέον, αν μπορούμε να βάλουμε $$\texttt{s}[j]$$ άσους στις θέσεις $$\texttt{c}[(i - \texttt{s}[j] - 1)..(i-1)]$$, δηλαδή αυτές οι θέσεις αποτελούνται από '1' ή '.', τότε μπορούμε να κάνουμε με επιπλέον $$\texttt{dp}[j - 1][i - \texttt{s}[j] - 1]$$ τρόπους.

<center>
<img width=350px src="/assets/36-c-bitsign.svg"/>
</center>

Ο παρακάτω κώδικας υλοποιεί αυτή την σχέση.
{% include code.md solution_name='bitsign_dp_n3.cc' start=30 end=42 %}

Ο έλεγχος για τα στοιχεία $$\texttt{c}[(i - \texttt{s}[j] - 1)..(i-1)]$$ χρειάζεται $$\mathcal{O}(N)$$ χρόνο, άρα αφού υπάρχουν $$\mathcal{O}(N\cdot M)$$ θέσεις στον πίνακα $$\texttt{dp}$$, συνολικά ο αλγόριθμος χρειάζεται $$\mathcal{O}(N^2 \cdot M)$$ χρόνο και $$\mathcal{O}(N \cdot M)$$ μνήμη.

Μπορείτε να βρείτε ολόκληρο των κώδικα [εδώ]({% include link_to_source.md solution_name='bitsign_brute_force.cc' %}).

## Λύση με δυναμικό προγραμματισμό (σε $$\mathcal{O}(N \cdot M)$$ χρόνο)

Μπορούμε να επιταγχύνουμε την προηγούμενη λύση προϋπολογίζοντας τις τιμές $$\texttt{first\_zero\_to\_left}$$ για κάθε θέση $$i$$ σε χρόνο $$\mathcal{O}(N)$$ (ακόμα και $$\mathcal{O}(N^2)$$ θα ήταν αρκετό), ως εξής:

{% include code.md solution_name='bitsign_dp_n2.cc' start=28 end=37 %}

Ο κυρίως κώδικας αλλάζει ως εξής:

{% include code.md solution_name='bitsign_dp_n2.cc' start=41 end=50 %}

Έτσι χρειάζομαστε $$\mathcal{O}(1)$$ χρόνο για τον υπολογισμό της κάθε τιμής του πίνακα $$\texttt{dp}$$, συνεπώς χρειαζόμαστε $$\mathcal{O}(N \cdot M)$$ συνολικά. Μπορείτε να βρείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='bitsign_dp_n2.cc' %}).

Επιπλέον αν παρατηρήσετε ότι για τον υπολογισμό των τιμών $$\texttt{dp}[j][\cdot]$$ χρησιμοποιούμε μόνο τις τιμές $$\texttt{dp}[j-1][\cdot]$$, μπορούμε να χρησιμοποιήσουμε την τεχνική του memoization και να κρατάμε μόνο δύο γραμμές στον πίνακα, μειώνοντας τον συνολικό χώρο σε $$\mathcal{O}(N)$$. Δείτε [εδώ]({% include link_to_source.md solution_name='bitsign_dp_n2_mem.cc' %}).
