---
layout: solution
codename: fishboats
---

## Επεξήγηση

Μας δίνονται οι συντεταγμένες $$X_i$$ (με $$10.000 \leq X_i \leq 10.000$$) από $$N$$ ψαρόβαρκες πάνω σε έναν άξονα, η κάθε μία από τις οποίες έχει $$M$$ ψάρια. Ο ταβερνιάρης αρχικά βρίσκεται στην θέση $$0$$ και σε κάθε μονάδα του χρόνου μπορεί να κινηθεί δεξιά ή αριστερά μία θέση. Σε κάθε μονάδα του χρόνου τα ψάρια κάθε ψαρόβαρκας μειώνονται κατά ένα. Σας ζητείται να βρείτε το μέγιστο πλήθος ψαριών που μπορεί να πάρει ο ταβερνιάρης.

## Λύση με brute force

Η brute force λύση είναι να δοκιμάσουμε κάθε δυνατή σειρά με την οποία μπορεί ο ταβερνιάρης να επισκεφτεί τις ψαρόβαρκες. Σε κάθε βήμα έχει το πολύ δύο επιλογές: να πάει στην πιο κοντινή **αριστερή** ψαρόβαρκα που δεν έχει επισκεφτεί ή να πάει στην πιο κοντινή **δεξιά** ψαρόβαρκα που δεν έχει επισκεφτεί.

Ο αλγόριθμος παρακάτω κρατάει σε κάθε βήμα:
 1. την αριστερότερη ψαρόβαρκα $$i$$ που έχουμε επισκεφτεί, 
 2. την δεξιότερη ψαρόβαρκα $$j$$ που έχουμε επισκεφτεί, 
 3. την απόσταση $$\mathit{dist}$$ που έχει διανύσει το ταβερνιάρης από την αρχική του θέση,
 4. τα ψάρια $$\mathit{total\_fish}$$ που έχει μαζέψει ο ταβερνιάρης μέχρι στιγμής. 

Κάθε φορά που παίρνουμε μία καινούργια ψαρόβαρκα αυξάνουμε το $$x$$ ανάλογα και προσθέτουμε $$M - \mathit{dist}$$ στο $$\mathit{total\_fish}$$.

{% include code.md solution_name='fishboats_brute_force.cc' %}

Υπάρχουν το πολύ $$2$$ επιλογές σε κάθε βήμα και κάθε βήμα παίρνει $$\mathcal{O}(1)$$ χρόνο άρα συνολικά ο αλγόριθμος χρειάζεται $$\mathcal{O}(2^N)$$ χρόνο και $$\mathcal{O}(N)$$ μνήμη. Ο αλγόριθμος περνάει το 50% των testcases.


## Λυση με δυναμικό προγραμματισμό

Τώρα θα δούμε μία λύση με δυναμικό προγραμματισμό. Σε αυτή την λύση θα χρησιμοποιήσουμε την εξής παρατήρηση:

**Παρατηρηση:** Αν πρόκειται να επισκεφτούμε $$len$$ ψαρόβαρκες, και η $$i$$-οστή που επισκεφτούμε είναι η $$x_{j}$$ (και προηγουμένως ήμασταν στην $$x_{k}$$), τότε αυτή η μετακίνηση θα μας κοστίσει $$(len - i + 1) \cdot \lvert x_{j} - x_{k}\rvert$$ ψάρια (από την $$i$$-οστή και τις μετέπειτα $$len - i$$ ψαρόβαρκες).

Για παράδειγμα στην παρακάτω διαδρομή επισκεφτόμαστε την πρώτη βάρκα την στιγμή $$t_1 = 2$$, την δεύτερη την στιγμή $$t_2 = 2 + 5$$, την τρίτη την στιγμή $$t_3 = 2 + 5 + 8$$ και την τέταρτη την στιγμή $$t_4 = 2 + 5 + 8 + 14$$. Επομένως τα ψάρια που παίρνουμε είναι $$4M - (t_1 + t_2 + t_3 + t_4)$$ που μετά από μία αναδιάταξη είναι ίσο με $$4M - (4 \cdot 2 + 3 \cdot 5 + 2 \cdot 8 + 1 \cdot 14)$$, που επιβεβαιώνει την παραπάνω παρατήρηση (η πρώτη απόσταση ($$2$$) χρησιμοποιείται $$4$$ φορές, η δεύτερη ($$5$$) χρησιμοποιείται $$3$$ φορές, κοκ).

<center>
<img alt="Ψαρόβαρκες στις θέσεις X=[-9,-3,2,5]" src="/assets/23-c-fishboats-example-path.svg" width="400" >
</center>

Επειδή δεν γνωρίζουμε εξ'αρχής πόσες ψαρόβαρκες περιλαμβάνονται στην βέλτιστη λύση, θα δοκιμάσουμε όλα τα δυνατά πλήθη $$\mathit{len}$$, δηλαδή $$\mathit{len} = 0, 1, 2, \ldots, n$$. Γνωρίζοντας αυτή την πληροφορία, μπορούμε να υπολογίσουμε τον μέγιστο αριθμό ψαριών $$dp[len][i][k][is\_right]$$ για να πάρουμε τις $$i$$ αριστερές ψαρόβαρκες και τις $$j$$ δεξιές ψαρόβαρκες, όταν είμαστε στην $$i$$ ($$is\_right = 0$$), ως εξής:

$$
dp[len][i][j][0] = M + \max \begin{cases}
dp[i-1][j][0] - (len + 1 - i - j) \cdot (\mathit{left}[i] - \mathit{left}[i-1]) \\
dp[i-1][j][1] - (len + 1 - i - j) \cdot (\mathit{left}[i] + \mathit{right}[j]))
\end{cases}
$$

και όταν είμαστε στην $$j$$, ως εξής:

$$
dp[len][i][j][1] = M + \max \begin{cases}
dp[i][j-1][1] - (len + 1 - i - j) \cdot (right[j] - right[j-1]) \\
dp[i][j-1][0] - (len + 1 - i - j) \cdot (left[i] + right[j]))
\end{cases}
$$

Και η απάντηση είναι η μέγιστη τιμή από τα $$\max( dp[len][i][j][0], dp[len][i][j][1])$$ με $$i$$ και $$j$$ να ικανοποιούν $$i + j = len$$. 

Επειδή οι λύσεις για το $$len$$ είναι ανεξάρτητες, μπορούμε να χρησιμοποιήσουμε $$N$$ φορές τον ίδιο πίνακα $$dp$$. Ο κυρίως κώδικας δίνεται παρακάτω (και ολόκληρος [εδώ]({% include link_to_source.md solution_name='fishboats_dp.cc' %})):

{% include code.md solution_name='fishboats_dp.cc' start=30 end=52 %}

Ο αλγόριθμος χρειάζεται $$\mathcal{O}(N^3)$$ χρόνο και $$\mathcal{O}(N^2)$$ μνήμη. Παρατηρώντας ότι σε κάθε επανάληψη του $$j$$ χρησιμοποιούμε το $$i-1$$, μπορούμε να μειώσουμε την μνήμη σε $$\mathcal{O}(N)$$ (δείτε τον κώδικα [εδώ]({% include link_to_source.md solution_name='fishboats_dp_mem.cc' %})).

## Άπληστη λύση

Μία άπληστη λύση είναι να πάμε πρώτα προς τα δεξιά και μετά προς τα αριστερά. Και αντίστοιχα μία φορά προς τα αριστερά και μετά προς τα δεξιά. Η λύση αυτή είναι εύκολο να υλοποιηθεί σε $$\mathcal{O}(N^2)$$ χρόνο, πχ με τον εξής κώδικα (και ολόκληρος [εδώ]({% include link_to_source.md solution_name='fishboats_greedy_1.cc' %})):

{% include code.md solution_name='fishboats_greedy_1.cc' start=12 end=32 %}

Αλλά όπως φαίνεται στο παρακάτω παράδειγμα δεν βρίσκει πάντα τη βέλτιστη λύση. 

<center>
<img alt="Παράδειγμα με X = [-4,-2,1,5] και M=10, όπου η βέλτιστη λύση είναι [1,-2,-4,5], δηλαδή και η άπληστη λύση δεν δουλεύει." src="/assets/23-c-fishboats-greedy-1-counterexample.svg" width="600" >
</center>

Στα δοσμένα testcases περνάει το 50%.

Μία μικρή επέκταση αυτού του αλγορίθμου είναι να πάμε πρώτα δεξιά, μετά αριστερά και μετά πάλι δεξιά (και αντίστοιχα αριστερά, δεξιά, αριστερά) (ολόκληρος ο κώδικας [εδώ]({% include link_to_source.md solution_name='fishboats_greedy_2.cc' %})). Ξανά, αυτό μπορεί να υλοποιηθεί σε $$\mathcal{O}(N^2)$$ χρόνο, αλλά στο παρακάτω παράδειγμα ούτε αυτός βρίσκει πάντα τη βέλτιστη λύση. Στα δοσμένα testcases περνάει 26 από τα 40 testcases.

<center>
<img alt="Παράδειγμα με X = [-64,-16,-1,1,16,64] και M=300, όπου η βέλτιστη λύση είναι πχ [1,-1,-16,16,64,-64], δηλαδή και οι δύο απληστες λύσεις δεν δουλεύουν." src="/assets/23-c-fishboats-greedy-2-counterexample.svg" width="400" >
</center>
