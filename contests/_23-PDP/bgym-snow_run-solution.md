---
layout: solution
codename: snow_run
---

## 1<sup>η</sup> λύση με Brute force

Πρέπει δοθείσας της κατάταξης του κάθε χιονοδρόμου τη στιγμή που τερμάτισε να συμπεράνουμε την τελική του κατάταξη.

Μπορούμε να λύσουμε αυτό το πρόβλημα προσομοιώνοντας τη διαδικασία τερματισμών. Συγκεκριμένα η τελική κατάταξη κάθε δρομέα θα θεωρείται αρχικά ίση με αυτήν της στιγμής που τερμάτισε και στη συνέχεια όποτε θα συναντάμε κάποιο δρομέα που όταν τερμάτισε είχε μικρότερη ή ίση κατάταξη από αυτή θα αυξάνουμε κατά $$1$$ την τελική κατάσταση του πρώτου.

Για να το κάνουμε αυτό μπορούμε να χρησιμοποιήσουμε δύο εμφωλευμένα for loops, έστω με μεταβλητές $$i$$ και $$j$$. Επίσης θα χρειαστούμε έναν πίνακα, έστω $$A$$, στον οποίο θα διατηρούμε την τελική κατάταξη του κάθε δρομέα με βάση τα μέχρι στιγμής δεδομένα. Αρχικά για κάθε δρομέα $$i$$ η τελική του κατάταξη θα αρχικοποιείται στην κατάταξή του τη στιγμή που τερμάτισε και θα αυξάνεται κατά $$1$$ η κατάταξη κάθε προηγούμενου δρομέα ($$j < i$$) που μέχρι τώρα θεωρούταν ότι είχε την ίδια ή χειρότερη τελική κατάταξη ($$A[j] \geq A[i]$$).

Λόγω των δύο εμφωλευμένων for loops που διατρέχουν τον πίνακα $$A$$, η χρονική πολυπλοκότητα αυτού του αλγορίθμου θα είναι $$O(N^2)$$. Η πολυπλοκότητα αυτή είναι επαρκής για τα βασικά testcases ($$N \leq 40.000$$), αλλά το πρόγραμμα θα υπερβαίνει το χρονικό όριο για τα πιο δύσκολα (γενικά $$N \leq 100.000$$). Η χωρική πολυπλοκότητα είναι $$O(N)$$ καθώς πρέπει να αποθηκεύσουμε τις εκτιμώμενες τελικές καταστάσεις (πίνακας $$A$$).

```c++
#include <cstdio>
using namespace std;
#define MAXN 100005
long A[MAXN];
int main() {
    freopen("snow_run.in", "r", stdin);
    freopen("snow_run.out", "w", stdout);
    long N;
    scanf("%ld", &N);
    for (long i = 0; i < N; i++) {
        scanf("%ld", &A[i]);
        // Αύξηση τελικής κατάταξης προηγούμενων δρομέων που τερμάτισαν αργότερα
        for (long j = 0; j < i; j++) {
            if (A[j] >= A[i])
                A[j]++;
        }
    }
    // Εκτύπωση τελικών κατατάξεων
    for (long i = 0; i < N; i++) {
        printf("%ld\n", A[i]);
    }
    return(0);
}
```

## 2<sup>η</sup> λύση με Brute force

Αυτή η λύση που θα δούμε τώρα έχει την ίδια πολυπλοκότητα με την προηγούμενη, ωστόσο χρησιμοποιεί μία λίγο διαφορετική προσέγγιση που θα μας βοηθήσει να κατασκευάσουμε στη συνέχεια τη βέλτιστη λύση. Όπως φάνηκε από τον προηγούμενο αλγόριθμο, η τελική κατάταξη ενός παίκτη εξαρτάται μόνο από τις κατατάξεις των παικτών μετά από αυτόν και από την κατάταξή του τη στιγμή που τερμάτισε. Μπορούμε να κάνουμε μία παρατήρηση που προκύπτει από τον τρόπο που γίνονταν οι αυξήσεις των κατατάξεων στον προηγούμενο αλγόριθμο.

**Παρατήρηση**: Θεωρητικά μπορούμε να αναδιατάξουμε τους επόμενους από τον τρέχων παίκτες (χωρίς να αλλάξουμε την τελική τους κατάταξη) σε σειρά αύξουσας τελικής κατάταξης, οπότε η κατάταξη τερματισμού για αυτούς θα είναι ίση με την τελική (αφού δε θα γίνονται προσπεράσματα). Έτσι αν ο τρέχων παίκτης τη στιγμή τερματισμού του είχε κατάταξη ίση με $$a$$, τότε μόνο στη θέση του $$a$$-οστού κενού της τελικής κατάταξης που προκύπτει από τους επόμενους παίκτες κάθε αύξηση από κάποιον επόμενο παίκτη θα αντισταθμίζεται από ένα κενό.

Μπορούμε λοιπόν να έχουμε έναν boolean πίνακα, έστω $$B$$, αρχικοποιημένο σε $$\mathit{false}$$. Καθώς διατρέχουμε τους παίκτες από το τέλος προς την αρχή θα υπολογίζουμε την τελική τους κατάταξή. Αν ο $$i$$-οστός παίκτης έχει κατάταξη ίση με $$a$$ τη στιγμή τερματισμού του, τότε θα ψάχνουμε γραμμικά το $$a$$-οστό $$\mathit{false}$$ του πίνακα $$B$$. Αν αυτό βρίσκεται στη θέση $$b$$ τότε αυτή θα είναι η τελική κατάταξη του $$i$$-οστού παίκτη, οπότε θα κάνουμε το $$B[b]$$ ίσο με $$\mathit{true}$$ και το $$A[i]$$ ίσο με $$b$$. Τελικά ο πίνακας $$A$$ θα περιέχει τα αποτελέσματα.

Επειδή για κάθε παίκτη κάνουμε γραμμική διάσχιση του πίνακα $$B$$, η χρονική πολυπλοκότητα θα είναι $$O(N^2)$$. Η χωρική πολυπλοκότητα είναι και πάλι $$O(N)$$. Αν και αυτός ο αλγόριθμος έχει την ίδια χρονική πολυπλοκότητα με τον προηγούμενο, πρακτικά συχνά θα πετυχαίνει μικρότερους χρόνους καθώς για πολλούς παίκτες δε θα χρειάζεται να διασχίζουμε όλον τον πίνακα $$B$$. Βέβαια και πάλι για απαιτητικά testcases αυτή η λύση υπερβαίνει τα χρονικά όρια.

```c++
#include <cstdio>
using namespace std;
#define MAXN 100005
long A[MAXN];
bool B[MAXN];
int main() {
    freopen("snow_run.in", "r", stdin);
    freopen("snow_run.out", "w", stdout);
    long N;
    scanf("%ld", &N);
    // Διάβασμα κατατάξεων τη στιγμή τερματισμού κάθε δρομέα
    for (long i = 0; i < N; i++) {
        scanf("%ld", &A[i]);
    }
    for (long i = N - 1; i >= 0; i--) {
        long a = A[i];
        long b = 0;
        // Εύρεση a-οστού κενού στη θέση b
        while (a) {
            if (!B[++b])
                a--;
        }
        // Το b είναι η τελική κατάταξη του τρέχοντος παίκτη
        B[b] = true;
        A[i] = b;
    }
    // Εκτύπωση τελικών κατατάξεων
    for (long i = 0; i < N; i++) {
        printf("%ld\n", A[i]);
    }
    return(0);
}
```


## Βέλτιστη λύση με Segment tree

Αυτό το πρόβλημα μπορεί να λυθεί πιο γρήγορα εάν επιταχύνουμε τη διαδικασία εύρεσης του $$a$$-οστού κενού στον πίνακα κατατάξεων. Ένας τρόπος να το κάνουμε αυτό είναι με τη βοήθεια μίας δομής δεδομένων που ονομάζεται [segment tree](https://en.wikipedia.org/wiki/Segment_tree). Καλή πηγή διαβάσματος για τα segment trees με θεωρία, παραδείγματα χρήσης και προβλήματα είναι ένα άρθρο του Καλλίνικου που μπορείτε να βρείτε [εδώ](https://kallinikos.github.io/Segment-Trees).

Μπορούμε να θεωρήσουμε έναν πίνακα $$C$$ που θα έχει $$1$$ στις θέσεις που αντιστοιχούν σε μη κατειλημμένες θέσεις της κατάταξης και $$0$$ στις κατειλημμένες. Αν εφαρμόσουμε ένα αθροιστικό segment tree πάνω στον πίνακα $$C$$ μπορούμε να το χρησιμοποιούμε για να βρίσκουμε τα επιθυμητά κενά (query) και να κάνουμε κατάληψη τους (update). Επειδή κάνουμε update τους κόμβους που προκύπτουν από τα query μπορούμε να συνενώσουμε αυτές τις δύο λειτουργίες.

Ο τρόπος που θα εντοπίζουμε το $$k$$-οστό κενό του πίνακα κατάταξης, δηλαδή τον $$k$$-οστό $$1$$ του πίνακα $$C$$, είναι να βρισκόμαστε αρχικά στην κορυφή του δέντρου ξέροντας ότι θέλουμε να εντοπίσουμε τον $$k$$-οστό $$1$$ του διαστήματος του πίνακα $$C$$ που αντιστοιχεί στο υπόδεντρό μας, δηλαδή σε όλο το δέντρο. Όταν λοιπόν βρισκόμαστε σε έναν κόμβο και θέλουμε να εντοπίσουμε τον $$k$$-οστό $$1$$ του διαστήματος του πίνακα $$C$$ που αντιστοιχεί στο υπόδεντρό μας συγκρίνουμε την τιμή του αριστερού παιδιού του κόμβου μας, έστω $$c$$, με το $$k$$ και κάνουμε το εξής:
* Αν $$c \geq k$$, τότε το $$1$$ που ψάχνουμε είναι το $$k$$-οστό $$1$$ του διαστήματος που αντιστοιχεί στο υπόδεντρο του αριστερού μας παιδιού.
* Αν $$c < k$$, τότε το $$1$$ που ψάχνουμε είναι το $$(k - c)$$-οστό $$1$$ του διαστήματος που αντιστοιχεί στο υπόδεντρο του δεξιού μας παιδιού.

Οι κόμβοι από τους οποίους διερχόμαστε πρέπει να υπόκεινται μείωση τιμής κατά $$1$$ καθώς καλύπτουμε ένα κενό στο υπόδεντρό τους.

Επειδή για κάθε παίκτη ο υπολογισμός της τελικής του κατάταξης με το segment tree γίνεται σε χρόνο $$O(\log{N})$$ η χρονική πολυπλοκότητα αυτού του αλγορίθμου είναι $$O(N\log{N})$$. Η χωρική πολυπλοκότητα είναι $$O(N)$$. Πλέον ο αλγόριθμος είναι περνάει όλα τα testcases.

```c++
#include <cstdio>
using namespace std;
#define MAXN 100005
long A[MAXN];
// Δηλώσεις για segment tree
long C[MAXN], tree[4 * MAXN];
void build(long node, long start, long end) {
    if(start == end)
        tree[node] = C[start];
    else {
        long mid = (start + end) / 2;
        build(2 * node, start, mid);
        build(2 * node + 1, mid + 1, end);
        tree[node] = tree[2 * node] + tree[2 * node + 1];
    }
}
// Εντοποπισμός επιθυμητού 1 και ενημέρωση segment tree
long query(long node, long start, long end, long k) {
    tree[node]--;
    if(start == end) {
        C[start] = 0;
        return(start);
    }
    long mid = (start + end) / 2;
    long c = tree[2 * node];
    // Επιλογή κατάλληλου υποδέντρου
    if (c >= k)
        return(query(2 * node, start, mid, k));
    return(query(2 * node + 1, mid + 1, end, k - c));
}
int main() {
    freopen("snow_run.in", "r", stdin);
    freopen("snow_run.out", "w", stdout);
    long N;
    scanf("%ld", &N);
    // Διάβασμα κατατάξεων τη στιγμή τερματισμού κάθε δρομέα
    // και αρχικοποίηση πίνακα C
    for (long i = 1; i <= N; i++) {
        scanf("%ld", &A[i]);
        C[i] = 1;
    }
    // Κατασκευή segment tree
    build(1, 1, N);
    // Υπολογισμός τελικών κατατάξεων με εντοπισμό 1
    for (long i = N; i; i--) {
        A[i] = query(1, 1, N, A[i]);
    }
    // Εκτύπωση τελικών κατατάξεων
    for (long i = 1; i <= N; i++) {
        printf("%ld\n", A[i]);
    }
    return(0);
}
```
