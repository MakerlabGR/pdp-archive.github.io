---
layout: solution
codename: polybox
---

## Επεξήγηση εκφώνησης
Δίνεται ένα σύνολο ορθογωνίων παραλληλογράμμων στοιβαγμένων το ένα πάνω από το άλλο 
και ζητείται το μήκος του περιγράμματος του σχήματος που προκύπτει.

**Παρατήρηση 1** Είναι φανερό ότι όλα τα ύψη $$h_i$$ συμμετέχουν στο μήκος του περιγράμματος και μάλιστα 
κάθε ύψος $$h_i$$ συμμετέχει δύο φορές στο περίγραμμα (για την αριστερή και δεξιά πλευρά του 
ορθογωνίου παραλληλογράμμου $$i$$). Στο περίγραμμα συμμετέχουν αυτούσια επίσης, το πλάτος $$w_1$$ 
και το πλάτος $$w_n$$, δηλαδή η βάση του χαμηλότερου και η οροφή του υψηλότερου παραλληλογράμμου. 

Η παραπάνω παρατηρήση αρκεί για να υπολογιστεί η απάντηση για το υποπρόβλημα 
$$1$$ (όπου όλα τα πλάτη είναι ίσα), καθώς το περίγραμμα που σχηματίζεται από όλα τα κουτιά είναι 
πάλι ένα ορθογώνιο παραλληλόγραμμο με πλάτος $$w_1=w_2=\dots=w_n$$ και ύψος $$h_1+h_2+\dots+h_n$$.
Η απάντηση για το πρώτο subtask είναι $$2\cdot w_1 + 2\cdot(h_1+h_2+\dots+h_n)$$.

Για το δεύτερο subtask παρατηρούμε ότι υπάρχει και κάποιο επιπλέον τμήμα που αυξάνει το περίγραμμα 
στην επαφή των δύο κουτιών όπου το πλάτος $$w_2$$ δεν καλύπτεται από το $$w_1$$ (βλέπε σχήμα 1). 
Είναι φανερό ότι δεν έχει σημασία αν τα κουτιά είναι στοιβαγμένα στον κεντρικό άξονα συμμετρίας ή στη 
μια πλευρά, καθώς από την πλευρά που έχουν κοινή τα δύο κουτιά, συμμετέχει στο περίγραμμα το $$w_2-w_1$$ 
δηλαδή η διαφορά της μεγαλύτερης βάσης από τη μικρότερη βάση (βλέπε σχήμα 2).

<center>
<img alt="Παράδειγμα με δύο κουτιά" src="/assets/37-a-polybox-subtask2.svg" width="320px">
</center>

Με την παρατήρηση αυτή μπορούμε να λύσουμε και το επόμενο subtask με τα πολλά κουτιά, όπου ανάμεσα σε 
δυο οποιαδήποτε διαδοχικά κουτιά μπορούμε να υπολογίσουμε το τμήμα που συμμετέχει στο τελικό περίγραμμα.

{% include code.md solution_name='solution90p.cc' start=15 end=23 %}

Η πολυπλοκότητα της παραπάνω λύσης είναι $$\mathcal{O}(N)$$ καθώς για κάθε ένα ορθογώνιο παραλληλόγραμμο, 
χρησιμοποιούμε δύο φορές το πλάτος του και μια το ύψος του. Η λύση αυτή αποκομίζει $$90$$ βαθμούς. 
Περνά όλα τα subtasks εκτός από 
το $$5$$ που χρησιμοποιεί αριθμούς που ξεπερνούν τους τύπους ακεραίων που παρέχει η γλώσσα **C++**.

## Πλήρης λύση με χρήση μεγάλων αριθμών.

Για να λυθεί το τελευταίο subtask θα χρειαστεί να υλοποιήσουμε κάποια δομή ακεραίων που να υποστηρίζει 
ακέραιους αριθμούς που ξεπερνούν το $$10^{45}$$ (το μέγιστο ύψος $$10^{40}$$ επί τον μέγιστο αριθμό κουτιών $$10^5$$)

Μια εύκολη λύση είναι να αποθηκεύσουμε τα ψηφία των αριθμών σε κάποιο πίνακα ακεραίων και να κάνουμε τις 
πράξεις όπως μάθαμε στο δημοτικό σχολείο. Για την αποθήκευση των αριθμών (οι οποίοι δεν έχουν σταθερό αριθμό ψηφίων) 
μπορούμε να χρησιμοποιήσουμε τη δομή ``vector<int>`` της **C++**. Στη θέση $$0$$ στο vector θα αποηκεύουμε 
το ψηφίο των μονάδων, στη θέση $$1$$ το ψηφίο των δεκάδων κλπ. Το vector θα επεκτείνεται ώστε να χωρά ακριβώς τα ψηφία 
του αριθμού που θα περιέχει.

Μια συνάρτηση υποστήριξης των μεγάλων αριθμών είναι η ``cmp(a,b)`` η οποία επιστρέφει 
$$-1$$ όταν $$a\lt b$$, $$0$$ αν $$a=b$$ και $$+1$$ όταν $$a\gt b$$.
Η σύγκριση γίνεται κατά τα γνωστά, 
πρώτα με το μήκος των αριθμών (ο αριθμός με τα λιγότερα ψηφία είναι ο μικρότερος) και σε περίπτωση ίδιου μήκους 
τότε συγκρίνουμε ένα ένα τα ψηφία ξεκινώντας από το ψηφίο με το μεγαλύτερο βάρος μέχρι να βρούμε ασυμφωνία, οπότε 
ο αριθμός με το μικρότερο ψηφίο είναι ο μικρότερος. 

{% include code.md solution_name='bigint100p.cc' start=43 end=51 %}

Η **C++** είναι αντικειμενοστραφής γλώσσα προγραμματισμού και επιτρέπει το overload στους τυπικούς 
τελεστές σύγκρισης, οπότε αξιοποιώντας τη δυνατότητα αυτή έχουμε τις παρακάτω συναρτήσεις:

{% include code.md solution_name='bigint100p.cc' start=53 end=63 %}

Η πράξη της πρόσθεσης μεταξύ δύο αριθμών, θα ξεκινά από τις μονάδες (τυχόν κρατούμενα θα παραμείνουν για να 
προστεθούν στις δεκάδες) κλπ. 

{% include code.md solution_name='bigint100p.cc' start=26 end=37 %}

Η αφαίρεση θέλει περισσότερη προσοχή, καθότι δεν θέλουμε να προκύψουν αρνητικοί αριθμοί, άρα 
φροντίζουμε να αφαιρούμε τον μικρότερο αριθμό από τον μεγαλύτερο. 

{% include code.md solution_name='bigint100p.cc' start=65 end=83 %}

Θα χρειαστούν και οι αντίστοιχες συναρτήσεις ανάγνωσης και εκτύπωσης μεγάλων αριθμών στα αρχεία εισόδου-εξόδου:

{% include code.md solution_name='bigint100p.cc' start=12 end=24 %}

Η πολυπλοκότητα είναι $$\mathcal{O}(N\cdot c)$$, όπου $$c$$ είναι ένας σταθερός παράγοντας (const factor) που είναι υπολογίσιμος καθώς 
εξαρτάτε από το μήκος των μεγάλων αριθμών ($$c=40$$ στη χειρότερη περίπτωση).

## Πλήρης λύση με χρήση μεγάλων αριθμών με μικρό const factor.

Αντί να χρησιμοποιήσουμε το δεκαδικό σύστημα αρίθμησης, μπορούμε να χρησιμοποιήσουμε οποιοδήποτε άλλο με 
βάση $$10^k$$ ώστε να περιορίσουμε τον αριθμό των ψηφίων του μεγάλου αριθμού. Το $$10^k$$ πρέπει να χωρά σε 
έναν τύπο ακεραίου του υπολογιστή, οπότε $$k\le9$$ για ακεραίους 32bit.
Τον κώδικα που προέκυψε με τροποποιήσεις της προηγούμενης λύσης, κυρίως στην ανάγνωση και εκτύπωση 
των αριθμών στα αρχεία εισόδου-εξόδου, μπορείτε να τον δείτε [εδώ]({% include link_to_source.md solution_name='bigint100p2.cc' %}).

