---
layout: solution
codename: polybox
---

## Επεξήγηση εκφώνησης
Δίνεται ένα σύνολο ορθογωνίων παραλληλογράμμων στοιβαγμένων το ένα πάνω από το άλλο 
και ζητείται το μήκος του περιγράμματος του σχήματος που προκύπτει.

**Παρατήρηση:** Είναι φανερό ότι όλα τα ύψη $$h_i$$ συμμετέχουν στο μήκος του περιγράμματος και μάλιστα 
κάθε ύψος $$h_i$$ συμμετέχει δύο φορές στο περίγραμμα (για την αριστερή και δεξιά πλευρά του 
ορθογωνίου παραλληλογράμμου $$i$$). Στο περίγραμμα συμμετέχουν αυτούσια επίσης, το πλάτος $$w_1$$ 
και το πλάτος $$w_n$$, δηλαδή η βάση του χαμηλότερου και η οροφή του υψηλότερου παραλληλογράμμου. 

Η παραπάνω παρατηρήση αρκεί για να υπολογιστεί η απάντηση για το υποπρόβλημα 
$$1$$ (όπου όλα τα πλάτη είναι ίσα), καθώς το περίγραμμα που σχηματίζεται από όλα τα κουτιά είναι 
πάλι ένα ορθογώνιο παραλληλόγραμμο με πλάτος $$w_1=w_2=\dots=w_n$$ και ύψος $$h_1+h_2+\dots+h_n$$.
Η απάντηση για το πρώτο υποπρόβλημα είναι $$2\cdot w_1 + 2\cdot(h_1+h_2+\dots+h_n)$$.

Για το δεύτερο υποπρόβλημα παρατηρούμε ότι υπάρχει και κάποιο επιπλέον τμήμα που αυξάνει το περίγραμμα 
στην επαφή των δύο κουτιών όπου το πλάτος $$w_2$$ δεν καλύπτεται από το $$w_1$$ (βλέπε ακόλουθο σχήμα). 
Είναι φανερό ότι δεν έχει σημασία αν τα κουτιά είναι στοιβαγμένα στον κεντρικό άξονα συμμετρίας ή στη 
μια πλευρά, καθώς από την πλευρά που έχουν κοινή τα δύο κουτιά, συμμετέχει στο περίγραμμα το $$w_2-w_1$$ 
δηλαδή η διαφορά της μεγαλύτερης βάσης από τη μικρότερη βάση.

<center>
<img alt="Παράδειγμα με δύο κουτιά" src="/assets/37-a-polybox-subtask2.svg" width="320px">
</center>

Με την παρατήρηση αυτή μπορούμε να λύσουμε και το επόμενο υποπρόβλημα με τα πολλά κουτιά, όπου ανάμεσα σε 
δυο οποιαδήποτε διαδοχικά κουτιά μπορούμε να υπολογίσουμε το τμήμα που συμμετέχει στο τελικό περίγραμμα.

{% include code.md solution_name='solution90p.cc' start=15 end=23 %}

Η πολυπλοκότητα της παραπάνω λύσης είναι $$\mathcal{O}(N)$$ καθώς στον υπολογισμό του περιγράμματος των κουτιών χρησιμοποιούμε δύο 
φορές το πλάτος και μια το ύψος κάθε ορθογώνιου παραλληλογράμμου. Η λύση αυτή αποκομίζει $$90$$ βαθμούς. 
Περνά όλα τα υποπροβλήματα εκτός από 
το πέμπτο, διότι χρησιμοποιεί αριθμούς οι οποίοι ξεπερνούν τα όρια των τύπων ακεραίων που παρέχει η γλώσσα **C++**.

## Πλήρης λύση με χρήση μεγάλων αριθμών

Για να λυθεί και το τελευταίο υποπρόβλημα θα χρειαστεί να υλοποιήσουμε κάποια δομή ακεραίων που να υποστηρίζει 
ακέραιους αριθμούς που ξεπερνούν το $$10^{45}$$ (το μέγιστο ύψος $$10^{40}$$ επί τον μέγιστο αριθμό κουτιών $$10^5$$)

Μια εύκολη λύση είναι να αποθηκεύσουμε τα ψηφία των αριθμών σε κάποιο πίνακα ακεραίων και να κάνουμε τις 
πράξεις όπως μάθαμε στο δημοτικό σχολείο. Για την αποθήκευση των αριθμών (οι οποίοι δεν έχουν σταθερό αριθμό ψηφίων) 
μπορούμε να χρησιμοποιήσουμε τη δομή ``vector<int>`` της **C++**. Στη θέση $$0$$ στο vector θα αποηκεύουμε 
το ψηφίο των μονάδων, στη θέση $$1$$ το ψηφίο των δεκάδων κλπ. Το vector θα επεκτείνεται ώστε να χωρά ακριβώς τα ψηφία 
του αριθμού που θα περιέχει.

Η **C++** επιτρέπει να ορίσουμε πράξεις και συγκρίσεις στα ``vector`` μας. 
Για τις συγκρίσεις των μεγάλων αριθμών δημιουργήθηκε η βοηθητική συνάρτηση ``cmp(a,b)``, η οποία επιστρέφει 
$$-1$$ όταν $$a\lt b$$, $$0$$ αν $$a=b$$ και $$+1$$ όταν $$a\gt b$$.
Η σύγκριση γίνεται κατά τα γνωστά, 
πρώτα με το μήκος των αριθμών (ο αριθμός με τα λιγότερα ψηφία είναι ο μικρότερος) και σε περίπτωση ίδιου μήκους 
τότε συγκρίνουμε ένα ένα τα ψηφία ξεκινώντας από το ψηφίο με το μεγαλύτερο βάρος μέχρι να βρούμε ασυμφωνία, οπότε 
ο αριθμός με το μικρότερο ψηφίο είναι ο μικρότερος. 

{% include code.md solution_name='bigint100p.cc' start=43 end=51 %}

ο κώδικας για τις συγκρίσεις ακολουθεί: 

{% include code.md solution_name='bigint100p.cc' start=53 end=63 %}

Η πράξη της πρόσθεσης μεταξύ δύο αριθμών, ξεκινά από τις μονάδες (τυχόν κρατούμενα θα παραμείνουν για να 
προστεθούν στις δεκάδες) κλπ. 

{% include code.md solution_name='bigint100p.cc' start=26 end=37 %}

Η αφαίρεση θέλει περισσότερη προσοχή, καθότι δεν θέλουμε να προκύψουν αρνητικοί αριθμοί, άρα 
φροντίζουμε να αφαιρούμε τον μικρότερο αριθμό από τον μεγαλύτερο. 

{% include code.md solution_name='bigint100p.cc' start=65 end=83 %}

Θα χρειαστούν και οι αντίστοιχες συναρτήσεις ανάγνωσης και εκτύπωσης μεγάλων αριθμών στα αρχεία εισόδου-εξόδου:

{% include code.md solution_name='bigint100p.cc' start=12 end=24 %}

Η πολυπλοκότητα είναι $$\mathcal{O}(N\cdot c)$$. Το $$c$$ είναι το πλήθος των ψηφίων του μεγαλύτερου αριθμού (το πολύ $$40$$). 

## Πλήρης λύση με χρήση μεγάλων αριθμών (βελτίωση του χρόνου της προηγούμενης λύσης)

Αντί να χρησιμοποιήσουμε το δεκαδικό σύστημα αρίθμησης, μπορούμε να χρησιμοποιήσουμε οποιοδήποτε άλλο σύστημα με 
βάση $$10^k$$ ώστε να περιορίσουμε τον αριθμό των ψηφίων του μεγάλου αριθμού. Το $$10^k$$ πρέπει να χωρά σε 
έναν τύπο ακεραίου του υπολογιστή, οπότε $$k\le9$$ για ακεραίους 32bit.
Τον κώδικα που προέκυψε με τροποποιήσεις της προηγούμενης λύσης, κυρίως στην ανάγνωση και εκτύπωση 
των αριθμών στα αρχεία εισόδου-εξόδου, μπορείτε να τον δείτε [εδώ]({% include link_to_source.md solution_name='bigint100p2.cc' %}).

