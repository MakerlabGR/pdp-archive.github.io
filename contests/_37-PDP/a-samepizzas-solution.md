---
layout: solution
codename: samepizzas
---

## Επεξήγηση εκφώνησης 

Μας δίνονται $$N$$ υλικά και οι ποσότητες $$A_1, \ldots, A_N$$ του κάθε υλικού. Θέλουμε να φτιάξουμε το μέγιστο δυνατό αριθμό από πίτσες με τα ίδια υλικά, με τον περιορισμό αυτές να έχουν τουλάχιστον $$K$$ διαφορετικά υλικά.

Θα ξεκινήσουμε με δύο βασικές παρατηρήσεις. Ας υποθέσουμε ότι $$K = 3$$ και επιπλέον ότι έχουμε διαλέξει τα υλικά με ποσότητες $$3, 5, 8$$. Τότε, το πλήθος από πίτσες που μπορούμε να φτιάξουμε είναι $$3$$, δηλαδή το *ελάχιστο* από αυτές τις ποσότητες. 

Επιπλέον αν υπήρχε ένα στοιχείο που είναι μεγαλύτερο από το $$3$$, π.χ. το $$6$$, τότε αλλάζοντάς το με το $$3$$, μπορούμε να φτιάξουμε $$5$$ πίτσες (που είναι περισσότερες από τις $$3$$ που μπορούσαμε προηγουμένως).

Συνδυάζοντας αυτές τις δύο παρατηρήσεις, αν οι ποσότητες είναι $$3, 8, 5, 10, 12, 6$$ και $$K = 3$$ μας συμφέρει να πάρουμε τα τρία υλικά με τις μεγαλύτερες ποσότητες, δηλαδή τα $$12, 10, 8$$ και οι πίτσες που μπορούμε να φτιάξουμε είναι $$8$$, η μικρότερη από αυτές τις τιμές. Ισοδύναμα, αν ταξινομήσουμε τις ποσότητες σε φθίνουσα σειρά $$12, 10, 8, 6, 5, 3$$, τότε η απάντηση είναι η τρίτη (δηλαδή η $$K$$-οστή) τιμή.

## Λύση με ταξινόμηση (100%)

Ένας τρόπος να βρούμε την $$K$$-οστή μεγαλύτερη τιμή είναι να ταξινομήσουμε τον πίνακα και μετά να βρούμε ποια τιμή είναι στην θέση ``A[K-1]``. Στις περισσότερες γλώσσες προγραμματισμού υπάρχει μία συνάρτηση ``sort`` που υλοποιεί την ταξινόμηση σε χρόνο $$O(N \log N)$$. Για παράδειγμα, στην C++ αυτό γίνεται ως εξής:

{% include code.md solution_name='samepizzas_sort.cc'  %}

Επίσης, μπορείτε να υλοποιήσετε κάποιον από τους γρήγορους αλγορίθμους ταξινόμησης όπως η mergesort, η quicksort ή η heapsort. Αν υλοποιήσετε κάποιους από τους πιο αργούς όπως η insertion sort ή η bubble sort, τότε η λύση σας θα έχει πολυπλοκότητα $$O(N^2)$$ και θα περάσει μόνο τα υποπροβλήματα 1 και 4. 

## Λύση με select (100%)

Η λύση με την ταξινόμηση χρειάζεται χρόνο $$N \log N$$ στην χειρότερη περίπτωση. Υπάρχει όμως ένας αλγόριθμος που βρίσκει ακριβώς το $$K$$-οστό στοιχείο σε $$O(N)$$ βήματα. Στην C++ ο αλγόριθμος αυτός καλείται με την συνάρτηση ``std::nth_element``, ως εξής

{% include code.md solution_name='samepizzas_select.cc' start=15 end=19  %}

Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='samepizzas_select.cc' %}).

Το $$k$$-οστό μεγαλύτερο στοιχείο μπορούμε επίσης να το βρούμε με:
 - Δυαδική αναζήτηση σε χρόνο $$O(N \log N)$$ (Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='samepizzas_bsearch.cc' %}))

{% include code.md solution_name='samepizzas_bsearch.cc' start=20 end=27  %}

 - Ουρά προτεραιότητας, όπου κρατάμε τα $$K$$ μεγαλύτερα στοιχεία που έχουμε συναντήσει μέχρι στιγμής, σε χρόνο $$O(N \log K)$$. (Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='samepizzas_pq.cc' %}))
 
{% include code.md solution_name='samepizzas_pq.cc' start=16 end=25  %}

## Λύσεις για συγκεκριμένα υποπροβλήματα

Τα υποπροβλήματα μπορούν να λυθούν ως εξής:
 - **Υποπρόβλημα 1 $$N = 2$$:** Όταν $$K = 1$$, τότε η απάντηση είναι $$\max(A_1, A_2)$$, διαφορετικά είναι $$\min(A_1, A_2)$$ ([κώδικας]({% include link_to_source.md solution_name='samepizzas_subtask1.cc' %})).
 - **Υποπρόβλημα 2 $$K = N$$:** Η απάντηση είναι $$\min(A_1, \ldots, A_n)$$ ([κώδικας]({% include link_to_source.md solution_name='samepizzas_subtask2.cc' %})).
 - **Υποπρόβλημα 3 $$K = 1$$:** Η απάντηση είναι $$\max(A_1, \ldots, A_n)$$ ([κώδικας]({% include link_to_source.md solution_name='samepizzas_subtask3.cc' %})).
 - **Υποπρόβλημα 4 $$N \leq 10.000$$:** Σε αυτή την περίπτωση περνάνε και οι λιγότερο αποδοτικοί αλγόριθμοι ταξινόμησης (όπως η insertion sort) ([κώδικας]({% include link_to_source.md solution_name='samepizzas_insertion_sort.cc' %}))
