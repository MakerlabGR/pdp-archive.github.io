---
layout: solution
codename: reviews
---
## Επεξήγηση εκφώνησης 

Μας δίνεται ένας συνδεδεμένος μη-κατευθυνόμενος γράφος ο οποίος έχει την μορφή ενός δέντρου με μία επιπλέον ακμή. Μας ζητείται για κάθε ακμή του γράφου να βρούμε το μήκος του μακρύτερου μονοπατιού μεταξύ δύο κορυφών του γράφου αν αυτή αφαιρεθεί από τον γράφο ή να επισημάνουμε ότι ο γράφος δεν είναι συνδεδεμένος.

**Βασική παρατήρηση:** Ο γράφος αποτελείται από έναν κύκλο και ένα δέντρο με ρίζα κάθε κόμβο του κύκλου.

Από αυτό προκύπτει ότι όλες οι ακμές που δεν είναι στον κύκλο (και μόνο αυτές) αποσυνδέουν τον γράφο και η απάντησή τους είναι $$-1$$. 

<center>
<img alt="Δέντρο + μία ακμή" src="/assets/37-reviews-solution-trees.svg"/>
</center>

## Υποπρόβλημα 1

Σε αυτό το πρόβλημα όλοι οι κόμβοι ανήκουν στον κύκλο. Αν αφαιρέσουμε οποιαδήποτε ακμή μένει ένα μονοπάτι μήκους $$N-1$$. Επομένως μπορούμε να λύσουμε το πρόβλημα σε $$\mathcal{O}(N)$$ (δείτε τον κώδικα [εδώ]({% include link_to_source.md solution_name='subtask1.cc' %})).

## Υποπρόβλημα 2

Σε αυτό το υποπρόβλημα ο γράφος είναι πολύ μικρός και μπορούμε να αφαιρέσουμε κάθε ακμή και να βρούμε το μακρύτερο μονοπάτι στον υπολοιπόμενο γράφο, κάνοντας μία αναζήτηση κατά βάθος από κάθε κόμβο. 

Ο αλγόριθμος αυτός χρειάζεται $$\mathcal{O}(N^2)$$ για κάθε ακμή, άρα $$\mathcal{O}(N^3)$$ συνολικά.

Αν αξιοποιήσουμε ότι ο υπολοιπόμενος γράφος είναι ένα δέντρο, τότε μπορούμε να βρούμε το μακρύτερο μονοπάτι σε $$\mathcal{O}(N)$$ χρόνο, κάνοντας δύο αναζητήσεις κατά βάθος: 
 1. Βρίσκουμε τον βαθύτερο κόμβο $$u$$ από τον κόμβο 1 (ή όποιον άλλον κόμβο)
 2. Βρίσκουμε τον βαθύτερο κόμβο $$x$$ από τον κόμβο $$u$$.
Η απόσταση μεταξύ των $$u$$ και $$x$$ είναι η μέγιστη απόσταση στο δέντρο (δείτε [εδώ](https://codeforces.com/blog/entry/101271)).

{% include code.md solution_name='subtask2.cc' %}

## Υποπρόβλημα 3

Σε αυτό το υποπρόβλημα υπάρχουν μόνο τρεις κόμβοι στον κύκλο, άρα μπορούμε απλά να τους αφαιρέσουμε και να βρούμε το μακρύτερο μονοπάτι στο υπολοιπόμενο δέντρο σε συνολικό χρόνο $$\mathcal{O}(N)$$ (δείτε τον κώδικα [εδώ]({% include link_to_source.md solution_name='subtask3.cc' %})). 


## Υποπρόβλημα 4

Σε αυτό το υποπρόβλημα υπάρχει ένα σχετικά μικρό πλήθος κόμβων στον κύκλο. Όταν αφαιρούμε μία ακμή από τον κύκλο υπάρχουν τα εξής πιθανά σενάρια:
 1. Η μεγαλύτερη απόσταση είναι μεταξύ δύο κόμβων στο ίδιο δέντρο (πράσινο). 
 2. Η μεγαλύτερη απόσταση ξεκινάει από ένα δέντρο συνεχίζει στον κύκλο και έπειτα συνεχίζει σε ένα άλλο δέντρο (κόκκινο). 

<center>
<img alt="Δέντρο + μία ακμή" src="/assets/37-reviews-solution-two-paths.svg"/>
</center>

Την πρώτη περίπτωση μπορούμε να την αντιμετωπίσουμε όπως στο Υποπρόβλημα 2 με τις δύο αναζητήσεις κατά βάθος. 

Για την δεύτερη περίπτωση, αφαιρούμε την ακμή από τον κύκλο και το μονοπάτι που μένει το αντιμετωπίζουμε σαν έναν πίνακα. Βρίσκουμε $$w[i]$$ το βάθος του δέντρο που έχει ρίζα τον κόμβο $$i$$ και έπειτα ψάχνουμε να βρούμε τους δύο κόμβους στον πίνακα με το μέγιστο $$w[i] + w[j] + \lvert i - j\rvert$$.

Μπορούμε εύκολα να βρούμε αυτή την μέγιστη τιμή δοκιμάζοντας όλα τα δυνατά ζευγάρια:

{% include code.md solution_name='subtask4.cc' start=104 end=129 %}

Για την εύρεση του κύκλου χρησιμοποιούμε μία αναζήτηση κατά βάθος (DFS). Όταν συναντήσουμε τον ίδιο κόμβο για δεύτερη φορά, τότε δημιουργείται ένας κύκλος που ξεκινάει και τελειώνει σε αυτόν τον κόμβο, με ενδιάμεσους όσους δεν έχει ολοκληρωθεί η DFS. 

{% include code.md solution_name='subtask4.cc' start=9 end=39 %}

Η εύρεση του κύκλου χρειάζεται $$\mathcal{O}(N)$$ χρόνο και κάθε ερώτημα απαντάται σε $$\mathcal{O}(C^2)$$ χρόνο, όπου $$C$$ είναι το μήκος του κύκλου. Συνεπώς, συνολικά ο αλγόριθμος χρειάζεται $$\mathcal{O}(NC^2)$$ χρόνο, που είναι αρκετό για να περάσει το υποπρόβλημα. 

## Υποπρόβλημα 5

Σε αυτό το υποπρόβλημα το μήκος του κύκλου είναι λίγο πιο μεγάλο και θα προσπαθήσουμε να απαντήσουμε το κάθε ερώτημα σε $$\mathcal{O}(C)$$ χρόνο. Η βασική παρατήρηση που κάνουμε είναι η εξής:

**Παρατήρηση:** Έστω ότι έχουμε δύο κόμβους $$i$$ και $$j$$ με $$w[i] - i > w[j] - j$$. Για κάθε κόμβο  $$k$$ με $$k > i$$ και $$k > j$$, έχουμε ότι συμφέρει να ταιριάξουμε τον $$k$$ με τον $$i$$ (αντί για τον $$j$$).

Αυτό προκύπτει γιατί $$w[i] + w[k] + (k - i) > w[j] + w[k] + (k - j)$$. 

Συνεπώς, καθώς διατρέχουμε τον πίνακα κρατάμε τη μεγαλύτερη τιμή του $$w[i] - i$$ και την ταιριάζουμε με την τιμή του δείκτη $$k$$.  
  
{% include code.md solution_name='subtask5.cc' start=105 end=127 %}

Κάθε ερώτημα χρειάζεται $$\mathcal{O}(C)$$ χρόνο και συνολικά $$\mathcal{O}(NC^2)$$, που είναι αρκετό για να περάσει το υποπρόβλημα. Ολόκληρος ο κώδικας [εδώ]({% include link_to_source.md solution_name='subtask5.cc' %}).

## Πλήρης λύση 

Για την πλήρη λύση θα απαντήσουμε όλα τα ερωτήματα στον κύκλο με ένα πέρασμα στον πίνακα. Η ιδέα είναι να βάλουμε δύο αντίγραφα του πίνακα το ένα δίπλα στο άλλο και για κάθε παράθυρο μεγέθους $$C$$ να βρούμε το μέγιστο άθροισμα $$w[i] + w[j] + (i - j)$$. 

Για να το κάνουμε αυτό αποδοτικά κρατάμε ένα set με τα στοιχεία ``{ w[i] + i, i }`` και ένα με τα στοιχεία ``{ w[j] - j, j }``. Σε κάθε βήμα, αφαιρούμε τα στοιχεία που είναι παλιά (δηλαδή έχουν $i$ με $$i \leq k - C$$) και θέλουμε να βρούμε το μέγιστο άθροισμα αυτών των δύο. Υπάρχουν οι εξής δύο περιπτώσεις:
 1. Είναι το άθροισμα από τα δύο μέγιστα (αν οι δύο δείκτες είναι διαφορετικοί)
 2. Είναι το άθροισμα από το ένα μέγιστο και το δεύτερο μέγιστο από το άλλο σύνολο.
 
Το set μας επιτρέπει να κάνουμε αυτές τις πράξεις σε $$\mathcal{O}(\log C)$$ χρόνο. 

{% include code.md solution_name='efficient.cc' start=112 end=137 %}

Συνολικά ο αλγόριθμος χρειάζεται $$\mathcal{O}(N \log N)$$ χρόνο και είναι αρκετό για να περάσει όλα τα testcases. Ολόκληρος ο κώδικας [εδώ]({% include link_to_source.md solution_name='efficient.cc' %}).
