---
layout: solution
codename: shops
---

## Επεξήγηση εκφώνησης

Μας δίνεται ένας πίνακας με $$N$$ μη-αρνητικούς ακεραίους, και ζητείται να βρούμε δύο διαστήματα μεγέθους $$K$$ το καθένα, έτσι ώστε το άθροισμα των στοιχείων να είναι μέγιστο. Σε περίπτωση που κάποια θέση του πίνακα ανήκει και στα δύο διαστήματα, μετριέται μόνο μία φορά στο άθροισμα.

Για παράδειγμα αν μας δίνεται ο πίνακας

$$2,~4,~15,~12,~10,~1,~1,~20,~4,~10$$

Τότε η απάντηση είναι $$71$$, διότι μπορούμε να διαλέξουμε τα διαστήματα $$15,~12,~10$$ και $$20,~4,~10$$.

Παρακάτω θα εξετάσουμε:

 1. Μία πολύ απλή/πολύ αργή λύση, πολυπλοκότητας $$O(N^2K)$$. Δε χρειάζεται καμμία προ-απαιτούμενη γνώση.
 2. Μία λίγο αργή βελτίωση της λύσης $$1$$, πολυπλοκότητας $$O(N^2)$$. Θα χρειαστούμε την τεχνική cumulative sums (δείτε το θέμα [Β Φάσης Γυμνασίου 31ου ΠΔΠ](/31-PDP/bgym-mntsea-solution)).
 3. Βέλτιστη λύση! Πολυπλοκότητας $$O(N)$$. Δε χρειάζεται κάποια επιπλέον γνώση πέρα από τα cumulative sums.

## Μερικές παρατηρήσεις

*Παρατήρηση 1:* Αρχικά μπορούμε πολύ απλά να δούμε ότι αν ο πίνακας είναι μικρός (μικρότερος ή ίσος με 2K), τότε η απάντηση είναι απλώς το άθροισμα όλων των στοιχείων του.

*Παρατήρηση 2:* Δεν υπάρχει κανένας λόγος τα διαστήματα να έχουν επικάλυψη. Εφόσον ξέρουμε ότι ο πίνακας είναι αρκετά μεγάλος (μεγαλύτερος από 2K λόγω της πρώτης παρατήρησης) τότε οποιαδήποτε λύση με επικάλυψη μπορεί να βελτιωθεί μετακινόντας είτε το αριστερότερο διάστημα προς τα αριστερά, είτε το δεξιότερο προς τα δεξιά. Έτσι προσθέτουμε πάντα περισσότερα στοιχεία, και εφόσον κανένας αριθμός δεν είναι αρνητικός, αυτό μας συμφέρει.

## Αργή λύση $$O(N^2K)$$

Γνώσεις που θα χρειαστούμε: Καμμία.

Δοκιμάζουμε όλους τους $$O(N^2)$$ συνδυασμούς για τα δύο διαστήματα, με τρόπο που φροντίζουμε ποτέ να μην επικαλύπτονται. Αρκεί το δεύτερο διάστημα να αρχίζει μετά τη θέση $$K+1$$ και το πρώτο διάστημα να τελειώνει πριν την αρχή του δεύτερου.

Κάθε φορά που έχουμε ένα τέτοιο συνδυασμό, υπολογίζουμε το άθροισμα των $$2K$$ στοιχείων.

Η τελική πολυπλοκότητα είναι λοιπόν $$O(N^2K)$$.

Παρακάτω δίνεται μία ενδεικτική υλοποίηση αυτής της λύσης.

```c++
#include <bits/stdc++.h>
const long MAXN = 2000000;
using namespace std;

long N, K, ans, s, sum, A[MAXN+5];

int main() {
  freopen("shops.in","r",stdin);
  freopen("shops.out","w",stdout);
  scanf("%ld %ld", &N, &K);
  for(long i=1; i<=N; ++i) scanf("%ld", &A[i]), s+=A[i];
  if(N<=2*K) {
    printf("%ld\n", s);
    return(0);
  }
  
  for(long i=2*K; i<=N; ++i)
    for(long j=K; j<=i-K; ++j) {
      long sum = 0;
      for(long k=1; k<=K; ++k) sum += A[i-k+1] + A[j-k+1];
      ans = max (sum, ans);
    }

  printf("%ld\n", ans);
}
```
## Αργή λύση - $$O(N^2)$$

Γνώσεις που θα χρειαστούμε: cumulative sums.

Η λύση που θα δούμε εισάγει ιδέες που θα χρειαστούν για την βέλτιστη λύση.

Υπάρχουν διάφορες λύσεις $$O(N^2)$$ που βασίζονται στην $$O(N^2K)$$ αλλά απαριθμούν με έξυπνο τρόπο τα διαστήματα, ώστε να υπολογίζουν τα αθροίσματα πιο γρήγορα. Η πιο γενική από αυτές βασίζεται στη χρήση cumulative sums, τα οποία είναι μία τεχνική για να απαντάμε το άθροισμα οποιουδήποτε συνεχόμενου διαστήματος σε $$O(1)$$ χρόνο! Σε περίπτωση που δε τη γνωρίζετε ήδη, σταματήστε εδώ!! Ελέξτε τη λύση της [Β Φάσης Γυμνασίου 31ου ΠΔΠ](/31-PDP/bgym-mntsea-solution), και μετά γυρίστε πίσω.

Πολύ σύντομα, υποθέστε ότι η πρώτη θέση του πίνακα είναι η $$1$$. Η σκέψη είναι να κρατάμε σε έναν πίνακα $$S[i]$$ το άθροισμα $$A[1]+A[2]+\ldots +A[i-1]+A[i]$$. Αυτό υπολογίζεται πολύ εύκολα σε γραμμικό χρόνο, αν προσέξουμε ότι $$S[1]=A[1]$$ και $$S[i]=S[i-1]+A[i]$$. Για ευκολία ορίζουμε $$S[0] = 0$$.

Κατόπιν, το άθροισμα από $$A[j]+A[j+1]+\ldots+A[i-1]+A[i]$$ είναι ίσο με $$S[i]-S[j-1]$$ (δώστε δέκα λεπτά να καταλάβετε γιατί).

Η λύση είναι ίδια με την $$O(N^2K)$$, με τη διαφορά ότι αντί να υπολογίζουμε το άθροισμα σε $$O(K)$$ χρόνο, το υπολογίζουμε σε $$O(1)$$ χρόνο.

Μία ενδεικτική υλοποίηση παρουσιάζεται παρακάτω:

```c++
#include <bits/stdc++.h>
#define MAXN 2000000
using namespace std;

long N, K, ans, A[MAXN+5], s[MAXN+5];

int main() {
  freopen("shops.in","r",stdin);
  freopen("shops.out","w",stdout);
  scanf("%ld %ld", &N, &K);
  for(long i=1; i<=N; ++i) scanf("%ld", &A[i]), s[i] = s[i-1] + A[i];
  if(N<=2*K) {
    printf("%ld\n", s[N]);
    return(0);
  }
  
  for(long i=2*K; i<=N; ++i)
    for(long j=K; j<=i-K; ++j) {
      ans = max (s[i]-s[i-K]+s[j]-s[j-K], ans);
    }

  printf("%ld\n", ans);
}
```

## Βέλτιστη λύση - $$O(N)$$

Γνώσεις που θα χρειαστούμε: cumulative sums.

Ας υποθέσουμε ότι είμαστε βέβαιοι ότι το δεύτερο διάστημα αρχίζει ακριβώς στη θέση $$1000$$. Τότε το πρώτο διάστημα πρέπει να τελειώνει το πολύ στη θέση $$999$$. Για την ακρίβεια θα χρειαζόμασταν το βέλτιστο διάστημα μεγέθους $$K$$ που τελειώνει μέχρι τη θέση $$999$$.

Αυτό είναι πολύ εύκολο να το υπολογίσουμε για κάθε πιθανή θέση, όχι μόνο για την $$999$$. Για τις πρώτες $$K-1$$ θέσεις δεν ορίζεται, καθώς δε μπορεί το πρώτο διάστημα να τελειώνει πριν τη θέση $$K$$. Για τη θέση $$K$$, η απάντηση είναι το άθροισμα των πρώτων $$K$$ θέσεων. Για επόμενες θέσεις (πχ για την θέση $$K+101$$) η απάντηση είτε τελειώνει στη θέση $$K+101$$, και βρίσκουμε την απάντησή της σε $$O(1)$$ χρόνο με cumulative sums, είτε τελειώνει το πολύ στη θέση $$K+100$$, το οποίο το έχουμε ήδη υπολογίσει. Επομένως ο παρακάτω κώδικας μας προϋπολογίζει σε ένα πίνακα τις βέλτιστες απαντήσεις, σε περίπτωση που μας ενδιαφέρει μόνο ένα διάστημα (επειδή θεωρούμε ότι αποφασίσαμε ήδη ποιο είναι το δεύτερο).

```c++
maxUpTo[K] = s[K]; //s[K]-s[0]==s[K], because s[0]=0
for(long i=K+1; i<=N; ++i)
    maxUpTo[i] = max(maxUpTo[i-1], s[i] - s[i-K]);
```
Έχοντας υπολογίσει αυτό τον πίνακα, το μόνο που μας μένει είναι να δοκιμάσουμε κάθε πιθανή τοποθέτηση του δεύτερου διαστήματος.

**Πολυπλοκότητα:**  Οι πράξεις που κάνουμε είναι οι εξής: Η δημιουργία του πίνακα $$S$$ για τα cumulative sums. Η δημιουργία του πίνακα maxUpTo. Τέλος, οι μαντεψιές για το δεύτερο διάστημα. Όλες αυτές οι πράξεις είναι γραμμικές, οπότε η τελική πολυπλοκότητα είναι $$O(N)$$.

Μία ενδεικτική υλοποίηση παρουσιάζεται παρακάτω:

```c++
#include <bits/stdc++.h>
const long MAXN = 2000000;
using namespace std;

long N, K, ans, A[MAXN+5], s[MAXN+5], maxUpTo[MAXN+5];

int main() {
  freopen("shops.in","r",stdin);
  freopen("shops.out","w",stdout);
  scanf("%ld %ld", &N, &K);
  for(long i=1; i<=N; ++i) {
    scanf("%ld", &A[i]);
    s[i] = s[i-1] + A[i];
    if(i-K>=0) maxUpTo[i] = max(maxUpTo[i-1], s[i] - s[i-K]);
  }
  if(N<=2*K) {
    printf("%ld\n", s[N]);
    return(0);
  }
  
  for(long i=2*K; i<=N; ++i)
    ans = max (s[i]-s[i-K]+maxUpTo[i-K], ans);

  printf("%ld\n", ans);
}
```
