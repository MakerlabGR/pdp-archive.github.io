---
layout: solution
codename: pcr
---

## Επεξήγηση εκφώνησης

Μας δίνεται μία ακολουθία από ακεραίους $$\lbrace 0, 1, 2, 3 \rbrace$$. Μας ζητείται να βρούμε την *βέλτιστη* , δηλαδή τη μικρότερη σε μήκος και μετά την λεξικογραφικά μικρότερη, ακολουθία από push, reverse και complement, ώστε να μετατρέψουμε μία *αριστερή* ακολουθία σε μία *δεξιά* ακολουθία όπου τα όλα $$0$$, $$1$$, $$2$$ και $$3$$ είναι ομαδοποιημένα.

Ξεκινάμε με μία παρατήρηση που δεν είναι αναγκαία για την κατανόηση των παρακάτω λύσεων αλλά δίνει πληφοροφορίες για την διαδικασία.

**Παρατήρηση 0:** Για οποιαδήποτε δοσμένη αριστερή ακολουθία, υπάρχει μία τέτοια ακολουθία κινήσεων.

Αν οι αριθμοί ήταν $$0$$ και $$1$$, τότε μπορούμε να διατηρήσουμε την ακολουθία $$00\ldots 011 \ldots 1$$. Όποτε συναντάμε $$1$$ κάνουμε $$p$$, ενώ όποτε συναντάμε $$0$$ κάνουμε $$rpr$$ (δηλαδή το προσθέτουμε στα αριστερά). Αφού οι αριθμοί είναι από $$0$$ έως $$3$$, όποτε συναντάμε $$2$$ κάνουμε $$cpc$$ (προσθέτουμε $$1$$ στα δεξιά) και όποτε συναντάμε $$3$$ κάνουμε $$crprc$$ (προσθέτουμε $$0$$ στα αριστερά). Επομένως, πάντοτε υπάρχει μία τέτοια ακολουθία.

Κάνουμε τις εξής απλές παρατηρήσεις, που είναι χρήσιμες για όλες τις παρακάτω λύσεις:

**Παρατήρηση 1:** Τα στοιχεία εισάγονται (γίνονται pushed) με τη σειρά της δοσμένης αριστερής ακολουθίας.

*(Αιτιολόγηση)* Καμία από τις κινήσεις δεν αλλάζει την σειρά των στοιχείων στην αριστερή ακολουθία, άρα τα στοιχεία θα γίνουν push με την σειρά που μας δίνονται.

**Παρατήρηση 2:** Δεν συμφέρει να κάνουμε δύο complement χωρίς να μεσολαβεί push.

*(Αιτιολόγηση)* Κάνουμε δύο κινήσεις που δεν επηρεάζουν κανένα στοιχείο που γίνεται push. Αφού ψάχνουμε τη μικρότερη ακολουθία , δεν μπορεί να υπάρχουν αυτές οι κινήσεις.

**Παρατήρηση 3:** Δεν συμφέρει να κάνουμε δύο reverse χωρίς να μεσολαβεί push.

*(Αιτιολόγηση)* Ξανά, κάνουμε δύο κινήσεις που δεν επηρεάζουν κανένα στοιχείο που γίνεται push.

**Παρατήρηση 4:** Η βέλτιστη ακολουθία κινήσεων δεν θα έχει ποτέ $$rcp$$.

*(Αιτιολόγηση)* Το reverse επηρεάζει την δεξιά ακολουθία ενώ το complement επηρεάζει την αριστερή. Άρα μπορούμε να τους αλλάξουμε θέση (δηλαδή κάνουμε $$crp$$ αντί για $$rcp$$) και να πάρουμε μία ακολουθία κινήσεων με την ίδια επίδραση και το ίδιο πλήθος, αλλά είναι λεξικογραφικά μικρότερη.

Χρησιμοποιώντας αυτές τις παρατηρήσεις, μπορούμε να δούμε το πρόβλημα ως εξής: Μας δίνονται $$N$$ στοιχεία και για κάθε ένα επιλέγουμε μία από τις κινήσεις $$\lbrace p, rp, cp, crp \rbrace$$ ώστε στο τέλος να έχουμε μία δεξιά ακολουθία που τα στοιχεία είναι ομαδοποιημένα. Από όλες τις ακολουθίες κινήσεων, ψάχνουμε για την βέλτιστη (όπως ορίσαμε προηγουμένως).

## Brute force λύση -- $$\mathcal{O}(4^N)$$

Η brute force λύση είναι να δοκιμάσουμε σε κάθε βήμα όλες τις δυνατές κινήσεις. Από τις ακολουθίες κινήσεων που οδηγήσουν σε ομαδοποιημένες δεξιές ακολουθίες κρατάμε την βέλτιστη. Κάνουμε μία κίνηση για κάθε στοιχείο και υπάρχουν το πολύ $$4$$ επιλογές. Άρα ο αλγόριθμος θέλει $$\mathcal{O}(4^N)$$ χρόνο, που είναι πολύ αργό για τα περισσότερα testcases.

## Λύση με δυναμικό προγραμματισμό -- $$\mathcal{O}(N^2)$$

**Παρατήρηση 5:** Για να ελέγξουμε αν μπορούμε να εισάγουμε ένα στοιχείο σε μία ομαδοποιημένη αριστερή ακολουθία, χρειάζεται να ξέρουμε μόνο:
 1. την σειρά που εμφανίζονται τα στοιχεία στην δεξιά ακολουθία
 2. αν τα στοιχεία στην αριστερή ακολουθία είναι αντεστραμμένα

Πιο συγκεκριμένα, το στοιχείο $$x_i$$ μπορεί να εισαχθεί μόνο αν:

 1. το δεξιότερο στοιχείο $$r = x_i$$ (ή $$r = 3 - x_i$$ αν τα στοιχεία της αριστερής ακολουθίας είναι αντεστραμμένα), ή
 2. δεν υπάρχει το στοιχείο $$x_i$$ στην δεξιά ακολουθία (ή το $$3 - x_i$$ αν τα στοιχεία της αριστερής ακολουθίας είναι αντεστραμμένα)

*(Αιτιολόγηση)* Ας δούμε την περίπτωση που δεν έχουμε αντιστροφή (η αντιστροφή έχει το ίδιο επιχείρημα με $$3-x_i$$ αντί για $$x_i$$). 
 1. Προφανώς αν το δεξιότερο στοιχείο είναι $$x_i$$, τότε μπορούμε απλά να το κάνουμε push χωρίς να αλλάξει η ομαδοποίηση. 
 2. Αν δεν υπάρχει το $$x_i$$, τότε δημιουργούμε για αυτό μία καινούργια ομάδα.

Αν δεν ισχύει καμία από τις δύο συνθήκες, τότε άμα το κάνουμε push, θα δημιουργηθεί μία δεύτερη ομαδοποίηση (πχ αν $$x_i = 2$$, τότε για $$1 1 2 2 3$$, κάνοντας push το $$2$$ δημιουργεί μία δεύτερη ομάδα για το $$2$$).


Επίσης, γνωρίζοντας αυτές τις δύο πληροφορίες, μπορούμε να κάνουμε complement και reverse. Ορίζουμε ως κατάσταση ``s = (positions, complement)``, όπου ``positions[x]`` είναι η θέση της ομάδας του ``x`` (ή $$0$$ αν δεν εμφανίζεται) και ``complement`` είναι η boolean αν τα στοιχεία στην αριστερή ακολουθία είναι αντεστραμμένα. Θα κάνουμε δυναμικό προγραμματισμό στο ``dp(i, s)``, που μας δίνει την βέλτιστη ακολουθία όταν επεξεργαζόμαστε το $$i$$-οστό στοιχείο και είμαστε στην κατάσταση ``s``. Χρησιμοποιούμε forward DP όπου οι μεταβάσεις είναι οι δυνατές κινήσεις $$\lbrace p, cp, crp, rp \rbrace$$ (σύμφωνα με τις παρατηρήσεις 1-4).

Στον κώδικα, για ευκολία κάθε κατάσταση ``s`` κρατάμε:
 * ένα πίνακα ``position`` με την σειρά των $$4$$ τιμών
 * τις αριστερότερες (``leftmost``) και δεξιότερες (``rightmost``) τιμές
 * το πλήθος ``count`` των διαφορετικών τιμών που έχουν εμφανιστεί
 * το ``complement``, αν η αριστερή ακολουθία έχει γίνει complemented μονό αριθμών φορών.

Για παράδειγμα, για την εξής δεξιά ακολουθία

$$\underbrace{2\; 2 \; 2 \; 2}_{1} \; \; \; \underbrace{3\; 3 \; 3}_{2} \; \; \;\underbrace{0\; 0 \; 0 \; 0 \; 0}_{3}$$

το ``positions = [3, 0, 1, 2]``, το ``leftmost = 2``, το ``rightmost = 0``, ``count = 3`` και το ``complement`` θα μπορούσε να είναι true ή false. Θα δούμε στην τέταρτη λύση, πώς μπορούμε να συμπιέσουμε αυτή την αναπαράσταση.

{% include code.md solution_name='pcr_slow.cc' start=10 end=57 %}

Κρατάμε μόνο τις δυνατές καταστάσεις για το $$i$$ και υπολογίζουμε τις δυνατές καταστάσεις για το $$i + 1$$. Για να μπορούμε να συγκρίνουμε γρήγορα, βάζουμε τις τιμές σε ένα map, όπου το κλειδί είναι η κατάσταση και η τιμή είναι η βέλτιστη ακολουθία κινήσεων που μας οδήγησε εκεί. Κρατάμε την ακολουθία κινήσεων σε μορφή string ώστε να μπορούμε να συγκρίνουμε εύκολα ποια είναι λεξικογραφικά μικρότερη. Αυτό κάνει τον αλγόριθμό μας πιο αργό (γιατί συγκρίνουμε και αντιγράφουμε strings μεγέθους $$O(N)$$) και θα δούμε στην τρίτη λύση πώς μπορούμε να το αποφύγουμε.


Πιο συγκεκριμένα, για τις μεταβάσεις έχουμε, αν

```int current_val = state.complement ? (3 - x[i]) : x[i];```


 * Για την κίνηση $$p$$:

{% include code.md solution_name='pcr_slow.cc' start=89 end=94 %}

 * Για την κίνηση $$cp$$:

{% include code.md solution_name='pcr_slow.cc' start=96 end=101 %}

 * Για την κίνηση $$crp$$:

{% include code.md solution_name='pcr_slow.cc' start=104 end=110 %}

 * Για την κίνηση $$rp$$:

{% include code.md solution_name='pcr_slow.cc' start=113 end=119 %}

Επειδή υπάρχουν μόνο $$4$$ στοιχεία, το πλήθος των δυνατών ``positions`` είναι σταθερός αριθμός (για την ακρίβεια[^PositionCount] $$65$$), αρά υπάρχουν το πολύ οι διπλάσιες καταστάσεις (για complemented και όχι complemented). Οι δυνατές μεταβάσεις είναι $$4$$, και η σύγκριση μεταξύ ακολουθιών θέλει $$\mathcal{O}(N)$$ χρόνο, άρα ο αλγόριθμος θέλει συνολικά $$\mathcal{O}(N^2)$$ χρόνο, που είναι αρκετό για περίπου το 50%. Θα βρείτε ολόκληρο τον κώδικα [εδώ](https://github.com/pdp-archive/pdp-archive.github.io/blob/master/_includes/source_code/code/32-PDP/pcr/pcr_slow.cc).

[^PositionCount]: Το πλήθος όλων των διατεταγμένων υποσυνόλων ενός συνόλου μεγέθους $$n$$ δίνεται από τον τύπο: 
   
    $$T(n) = \binom{n}{0} \cdot 0! + \binom{n}{1} \cdot 1! + \ldots + \binom{n}{n} \cdot n!$$
   
    Για $$n = 4$$, δίνει $$65$$ (δείτε περισσότερα [εδώ](http://www.hms.gr/sites/default/files/subsites/competitions/2012/SYNDYASTIKH_01.pdf) ή [εδώ](https://www.topcoder.com/community/competitive-programming/tutorials/basics-of-combinatorics/)).

## Γρηγορότερη εύρεση βέλτιστης ακολουθίας κινήσεων -- $$\mathcal{O}(N)$$

Το μεγαλύτερο πρόβλημα της προηγούμενης λύσης είναι η εύρεση της βέλτιστης ακολουθίας σε $$\mathcal{O}(N^2)$$. Τώρα, θα δούμε πώς μπορεί να γίνει πιο αποδοτικά.

Η ιδέα είναι να κρατάμε τις καταστάσεις της στιγμής $$i$$ ταξινομημένες με την λεξικογραφική σειρά των βέλτιστων ακολουθιών κινήσεων για να φτάσουμε σε αυτές. Μετά, εξετάζουμε τις δυνατές κινήσεις για κάθε μία από αυτές με λεξικογραφική σειρά, δηλαδή $$\lbrace cp, crp, p, rp \rbrace$$. Όπως πριν για κάθε κατάσταση κρατάμε την μικρότερη ακολουθία, αλλά αν υπάρχουν δύο με ίσο μήκος, τότε κρατάμε αυτή που κοιτάξαμε πρώτη (γιατί είναι λεξικογραφικά μικρότερη). Τέλος, ταξινομούμε τις καταστάσεις του $$i+1$$, με βάση την σειρά των ακολουθιών κινήσεων που οδήγησαν σε αυτές. Η εικόνα παρακάτω δείχνει ένα παράδειγμα για κάθε εκδοχή.

![](/assets/32-pdp-c-pcr-sorting-examples.svg){:width="520px"}

{% include code.md solution_name='pcr_semi_efficient.cc' start=69 end=129 %}

Κρατώντας για κάθε κατάσταση ``s`` την κατάσταση ``par[s]`` που οδήγησε στην βέλτιστη ακολουθία κινήσεων στο ``s``, μπορούμε να ανακτήσουμε την βέλτιστη ακολουθία, ακολουθώντας τους δείκτες ``par[s]``.

{% include code.md solution_name='pcr_semi_efficient.cc' start=131 end=151 %}

Η χρονική πολυπλοκότητα αυτού του αλγορίθμου είναι $$\mathcal{O}(N)$$, αλλά επειδή η σταθερά του $$N$$ είναι μεγάλη, η λύση παίρνει περίπου 70%. Θα βρείτε ολόκληρο τον κώδικα [εδώ](https://github.com/pdp-archive/pdp-archive.github.io/blob/master/_includes/source_code/code/32-PDP/pcr/pcr_semi_efficient.cc).

## Βέλτιστη λύση -- $$\mathcal{O}(N)$$

Η παραπάνω λύση αφιερώνει αρκετό χρόνο στη σύγκριση και δημιουργία καταστάσεων. Πιο συγκεκριμένα, κάθε ένα από τα ``positions``, ``leftmost``, ``rightmost`` και ``count``, κρατάνε έναν ακέραιο $$\leq 5$$. Άρα χρησιμοποιούμε μόνο $$21$$ bits από $$7$$ ακεραίους. Επειδή χρειαζόμαστε μόνο $$22$$ bits ($$21$$ συν ένα για το ``complement``), μπορούμε να τα αποθηκεύσουμε όλα σε έναν ακέραιο $$32$$ bit. Διαλέγουμε την εξής αναπαράσταση (αλλά υπάρχουν πολλές παρόμοιες):

![](/assets/32-pdp-c-pcr-bit-representation-format.svg){:width="700px"}

Για το παραπάνω παράδειγμα η αναπαράσταση είναι η εξής (όπου $x$ είναι αναπαριστά αν είναι complement ή όχι η κατάσταση):

![](/assets/32-pdp-c-pcr-bit-representation-example.svg){:width="700px"}

Γι'αυτό θα χρειαστούμε κάποια bit tricks (μπορείτε να διαβάσετε περισσότερα [εδώ](https://www.topcoder.com/community/competitive-programming/tutorials/a-bit-of-fun-fun-with-bits/)). Πιο συγκεκριμένα, χρειαζόμαστε τα εξής:

 * Διάβασμα τριών bits από έναν ακέραιο (όπου ``_111 = 7``):

{% include code.md solution_name='pcr_efficient.cc' start=21 end=30 %} 
 
 * Αλλαγή τριών bits σε ένα ακέραιο:

{% include code.md solution_name='pcr_efficient.cc' start=32 end=41 %} 

 * Διάβασμα ενός bit:

{% include code.md solution_name='pcr_efficient.cc' start=55 end=55 %}

 * Αλλαγή ενός bit:
 
{% include code.md solution_name='pcr_efficient.cc' start=59 end=59 %}


Το μόνο που χρειάζεται να αλλάξουμε από την προηγούμενη λύση είναι το ``State``:

{% include code.md solution_name='pcr_efficient.cc' start=17 end=108 %}

Υπάρχουν και άλλες βελτιστοποιήσεις που θα μπορούσαν να γίνουν, αλλά αυτή είναι αρκετή ώστε ο κώδικας περάσει όλα τα testcases. Θα βρείτε ολόκληρο τον κώδικα [εδώ](https://github.com/pdp-archive/pdp-archive.github.io/blob/master/_includes/source_code/code/32-PDP/pcr/pcr_efficient.cc).
