---
layout: solution
codename: pulsars
---

## Επεξήγηση προβλήματος

Όπως αναφέρει και η εκφώνηση, το συγκεκριμένο πρόβλημα είναι μια εφαρμογή του υπολογισμού του ελάχιστου κυρτού πολυγώνου (convex hull) των σημείων που δίνονται. Μπορείτε να διαβάσετε περισσότερες πληροφορίες στη Βικιπαίδεια για [τον ορισμό και τις ιδιότητες του](https://en.wikipedia.org/wiki/Convex_hull) καθώς και για [διάφορους αλγορίθμους](https://en.wikipedia.org/wiki/Convex_hull_algorithms) που χρησιμοποιούνται για την εύρεσή του.

Για κατανοήσουμε πιο εύκολα το ζητούμενο του προβλήματος, μπορούμε να φανταστούμε ότι τα σημεία μας είναι ακίνητα στο χώρο (π.χ. καρφωμένες πινέζες ή καρφιά) και προσπαθούμε να τυλίξουμε μιά ελαστική κορδέλα γύρω τους. Το τελικό σχήμα της κορδέλας θα είναι το ελάχιστο κυρτό πολύγωνο. Στην παρακάτω φωτογραφία ο εξωτερικός κύκλος δείχνει την ελαστική κορδέλα στην αρχική της θέση πριν την αφήσουμε και το μπλε πολύγωνο το τελικό σχήμα της κορδέλας γύρω από τα σημεία μας.

![Παράδειγμα ελαστικής κορδέλας](https://upload.wikimedia.org/wikipedia/commons/d/de/ConvexHull.svg "Παράδειγμα ελαστικής κορδέλας")

## Αλγόριθμος gift wrapping ($$\mathcal{O}(N^2)$$)

([Βικιπαίδεια](https://en.wikipedia.org/wiki/Gift_wrapping_algorithm))

> Σημείωση: Κανονικά σύμφωνα με τους γραπτούς περιορισμούς και όρια στην εκφώνηση αυτή η λύση αυτή δεν θα έπρεπε να περνάει όλα τα testcases, λόγω όμως των αδύναμων testcases περνάει.

Μια άλλη προσέγγιση του προβλήματος είναι να σκεφτούμε ότι τυλίγουμε τα σημεία μας με ένα χαρτί περιτυλίγματος, όπως θα κάναμε με ένα δώρο.

Ξεκινάμε με ένα σημείο που είναι σίγουρα στο ελάχιστο κυρτό πολύγωνο (π.χ. το πιο αριστερό (και το πιο πάνω σε περίπτωση ισοβαθμίας) σημείο).

Έπειτα, διαλέγουμε το δεύτερο σημείο, έτσι ώστε όλα τα υπόλοιπα σημείο να είναι δεξιά (ή αριστερά αρκεί να διατηρήσουμε την ίδια σύμβαση στη συνέχεια) από τη γραμμή που ενώνει αυτό το σημείο με το πρώτο (σε περίπτωση συνευθειακών σημείων, μπορούμε να διαλέγουμε το πιο μακρινό ή το πιο κοντινό ανάλογα με τις ανάγκες μας, παρ' όλα αυτά στο συγκεκριμένο πρόβλημα η εκφώνηση μας διαβεβαιώνει ότι δεν υπάρχουν τρία ή περισσότερα συνευθειακά σημεία πάνω στο τελικό πολύγωνο).

Με την ίδια λογική επιλέγουμε το τρίτο σημείο έτσι ώστε όλα τα σημεία να είναι δεξιά από τη γραμμή που ενώνει το δεύτερο με το τρίτο σημείο, και ούτω καθεξής. Όταν το επόμενο σημείο που βάζουμε είναι το πρώτο τότε ο αλγόριθμος τελειώνει.

![Ο αλγόριθμος gift wrapping](https://upload.wikimedia.org/wikipedia/commons/9/9c/Animation_depicting_the_gift_wrapping_algorithm.gif "Ο αλγόριθμος gift wrapping")\
*Ο αλγόριθμος gift wrapping ([CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/deed.en))*

Για να βρούμε το αρχικό σημείο, πρέπει να βρούμε το σημείο με την ελάχιστη τετμημένη (x), το οποίο μπορούμε να το υπολογίσουμε με ένα πέρασμα από όλα τα σημεία σε χρόνο $$O(N)$$.

Για κάθε επόμενο σημείο, πρέπει να περάσουμε από όλα τα σημεία ώστε να βρούμε αυτό του οποίου η ευθεία αφήνει τα υπόλοιπα σημεία στα δεξιά. Για να το βρούμε αυτό μπορούμε είτε να υπολογίσουμε την κλίση της ευθείας και έπειτα την γωνία της με τον άξονα $$x$$ είτε να χρησιμοποιήσουμε το [εξωτερικό γινόμενο](https://el.wikipedia.org/wiki/%CE%94%CE%B9%CE%B1%CE%BD%CF%85%CF%83%CE%BC%CE%B1%CF%84%CE%B9%CE%BA%CF%8C_%CE%B3%CE%B9%CE%BD%CF%8C%CE%BC%CE%B5%CE%BD%CE%BF) (πιο συγκεκριμένα την z συντεταγμένη του). Γενικά στον προγραμματισμό για αυτή τη χρήση, χρησιμοποιούμε το εξωτερικό γινόμενο για λόγους ταχύτητας, ακρίβειας και ευκολίας γραψίματος. Η συνάρτηση υπολογισμού του εξωτερικού γινομένου, μπορεί να γραφτεί έτσι:

```c++
long long ccw(Point a, Point b, Point c)
{
  return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}
```

Αν το αποτέλεσμα της συνάρτησης είναι $$>0$$ τότε το σημείο $$\rm c$$ είναι αριστερά της ευθείας $$\overline{\rm ab}$$, αν είναι $$<0$$, είναι δεξιά και αν είναι $$=0$$, τότε τα σημεία είναι συνευθειακά.

Αφού ο υπολογισμός του εξωτερικού γινομένου είναι $$O(1)$$ (μόνο πολλαπλασιασμοί και προσθέσεις), ο συνολικός χρόνος περάσματος όλων των σημείων είναι $$O(N)$$. Πρέπει να επαναλάβουμε την διαδικασία για όλα τα σημεία του ελάχιστου κυρτού πολυγώνου, τα οποία μπορεί να είναι έως και $$O(N)$$ αν όλα τα σημεία είναι πάνω στο πολύγωνο.

Χρειάζεται, επιπλέον στο τέλος μία ταξινόμηση με βάση την σειρά που είχαν στο αρχείο εισόδου, όπως ζητάει η εκφώνηση. Η πολυπλοκότητα της ταξινόμησης είναι $$O(N\log N)$$ άμα χρησιμοποιήσουμε μια συνάρτηση ταξινόμησης όπως η quicksort για παράδειγμα.

Άρα η συνολική πολυπλοκότητα είναι $$O(N*N + N + N\log N) = O(N^2)$$.

Δείτε την υλοποίηση [εδώ](../../_includes/source_code/code/24-PDP/pulsars/pulsars_gift_wrapping.cc).

## Αλγόριθμος Graham scan $$\mathcal{O}(N\log N)$$

([Βικιπαίδεια](https://en.wikipedia.org/wiki/Graham_scan))

Μια άλλη λύση με καλύτερη πολυπλοκότητα είναι ο αλγόριθμος του [Graham Scan](https://en.wikipedia.org/wiki/Graham_scan).

Ο αλγόριθμός ξεκινάει όπως και το *gift wrapping* βρισκοντας ένα σημείο που είναι σίγουρα στο ελάχιστο κυρτό πολύγωνο, οπότε θα πάρουμε το πιο αριστερά σημείο στο δικό μας παράδειγμα, ας το ονομάσουμε $$p_0$$. Έπειτα, ταξινομεί τα σημεία ως προς τη γωνία που σχηματίζει η ευθεία που τα ενώνει με το σημείο $$p_0$$ και ο άξονας $$x$$. Δεν χρειάζεται να υπολογίσουμε την ακριβή γωνία για να τα ταξινομήσουμε, οποιαδήποτε συνάρτηση που παρουσιάζει αυστηρή μονοτονία στο διάστημα $$[-\frac{\pi}{2}, \frac{\pi}{2}]$$, όπως π.χ. η κλίση της ευθείας (με προσοχή στις κατακόρυφες ευθείες με άπειρη κλίση). Στο συγκεκριμένο παράδειγμα, θα χρησιμοποιήσουμε το εξωτερικό γινόμενο που αναφέραμε παραπάνω, το οποίο μας γλιτώνει από μερικά edge cases. Χρησιμοποιώντας το σαν το comparison function μπορούμε να ταξινομήσουμε τα σημεία (βλέπε [sort](https://en.cppreference.com/w/cpp/algorithm/sort), [Compare](https://en.cppreference.com/w/cpp/named_req/Compare)).

Έπειτα δημιουργούμε μία [στοίβα](https://el.wikipedia.org/wiki/%CE%A3%CF%84%CE%BF%CE%AF%CE%B2%CE%B1_(%CE%B4%CE%BF%CE%BC%CE%AE_%CE%B4%CE%B5%CE%B4%CE%BF%CE%BC%CE%AD%CE%BD%CF%89%CE%BD)) η οποία θα κρατάει τα στοιχεία του ελάχιστου κυρτού πολυγώνου, στην οποία αρχικά βάζουμε το σημείο $$p_0$$ και το πρώτο σημείο από την ταξινομημένη λίστα. Έπειτα, περνώντας ένα ένα τα σημεία στη ταξινομημένη λίστα κάνουμε τον εξής έλεγχο:

1. Αν το σημείο "στρίβει" αριστερά σε σχέση με τα δύο τελευταία σημεία στη στοίβα, τότε το προσθέτουμε στη στοίβα και προχωράμε στο επόμενο σημείο.
2. Αν το σημείο "στρίβει" δεξιά σε σχέση με τα δύο τελευταία σημεία στη στοίβα ή είναι συνευθειακό (η τελευταία συνθήκη εξαρτάται από τις απαιτήσεις του προβλήματος), αφαιρούμε το τελευταίο σημείο από τη στοίβα και επαναλαμβάνουμε τον έλεγχο.

Ο έλεγχος για τον αν "στρίβουμε" αριστερά ή δεξιά μπορεί να γίνει και πάλι χρησιμοποιώντας το εξωτερικό γινόμενο.

![Αλγόριθμος Graham Scan](https://upload.wikimedia.org/wikipedia/commons/e/ed/Graham_Scan.svg "Αλγόριθμος Graham Scan")\
*Στην παραπάνω εικόνα, το $$PAB$$ και $$ABC$$ στρίβουν αριστερά, αλλά το $$BCD$$ όχι, άρα βγάζουμε το τελευταίο σημείο $$C$$ από τη λίστα. Τώρα το $$ABD$$ στρίβει αριστερά, οπότε συνεχίζουμε. ([CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/deed.en))*

> Σημείωση: Αν έχουμε ταξινομήσει τα σημεία μας σε φθίνουσα σειρά με βάση τη γωνία τους, τότε το αριστερά και το δεξιά στις παραπάνω 2 οδηγίες αντιστρέφονται.

Όταν περάσουμε από όλα τα σημεία, το ελάχιστο κυρτό πολύγωνο είναι τα σημεία στη στοίβα μας (και με τη σειρά που μπήκανε). Αρκεί στο τέλος μία ταξινόμηση με βάση την σειρά που είχαν στο αρχείο εισόδου, όπως ζητάει η εκφώνηση.

Έπειτα η πολυπλοκότητα της κατασκευής του πολυγώνου είναι $$O(N)$$. Μπορεί να μοιάζει σαν $$O(N^2)$$ αρχικά, καθώς μπορεί να αδειάσουμε ολόκληρη τη στοίβα σε κάποια επανάληψη, η οποία μπορεί να φτάσει ως και $$N$$ στοιχεία, αλλά αρκεί να παρατηρήσουμε ότι ένα στοιχεία μπορεί να μπει μέχρι μια φορά και να βγει μέχρι μία φορα, άρα συνολικά το πολύ 2 φορές για κάθε σημείο, κάνοντας την τελική πολυπλοκότητα $$O(N)$$.

Άρα η συνολική πολυπλοκότητα, μαζί με την τελική ταξινόμηση ως προς τη σειρά εμφάνισης των σημείων στο αρχείο εισόδου είναι $$O(N\log N + N + N\log N) = O(N\log N)$$.

Δείτε την υλοποίηση [εδώ](../../_includes/source_code/code/24-PDP/pulsars/pulsars_graham_scan.cc).

## Αλγόριθμος monotone chain $$\mathcal{O}(N\log N)$$

([Βικιπαίδεια](https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain))

Ο αλγόριθμος αυτός μοιάζει πολύ με τον προηγούμενο, μόνο που το πολύγωνο το φτιάχνουμε σε δύο μισά (άνω και κάτω) τα οποία στο τέλος ενώνουμε. Στην αρχή ταξινομούμε τα σημεία τους με βάση την τετμημένη ($$x$$) (και την τεταγμένη $$y$$ σε περίπτωση ισότητας). Έπειτα, εφαρμόζουμε τον παραπάνω αλγόριθμο στην ταξινομημένη λίστα δύο φορές, την πρώτη κρατώντας τις αριστερές στροφές όπως πριν, φτιάχνοντας το κάτω μισό, και την δεύτερη κρατώντας τις δεξιές στροφές, φτιάχνοντας το άνω μισό.

Έπειτα μπορούμε να ενώσουμε τα δύο μισα και να ταξινομήσουμε όπως ζητάει η εκφώνηση.

Η συνολική πολυπλοκότητα είναι όπως και στον Graham Scan, αφού τρέχουμε τον ίδιο αλγόριθμο, απλά δύο φορές και χρησιμοποιώντας διαφορετική ταξινόμηση.

> Σε περίπτωση που θέλαμε τη σειρά των σημείων όπως εμφανίζονται στο ελάχιστο κυρτό πολύγωνο, θα μπορούσαμε να αντιστρέψουμε τα σημεία σε ένα από τα δύο μισά και να το προσθέσουμε στο τέλος του άλλου μισού.

Δείτε την υλοποίηση [εδώ](../../_includes/source_code/code/24-PDP/pulsars/pulsars_monotone_chain.cc).

## Περισσότεροι αλγόριθμοι

<https://en.wikipedia.org/wiki/Convex_hull_algorithms#Algorithms>
