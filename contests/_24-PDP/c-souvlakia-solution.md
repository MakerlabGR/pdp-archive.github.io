---
layout: solution
codename: souvlakia
---

## Επεξήγηση εκφώνησης

Το πρόβλημα μας δίνει ένα γράφο με $$N$$ κόμβους (καταστήματα) και για κάθε ένα $$i$$ από αυτά μας ζητά να υπολογίσουμε τρείς τιμές 
$$(X_i,Y_i,Z_i)$$ ως τις αποστάσεις των διαδρομών από το κατάστημα $$i$$ προς τρία άλλα προεπιλεγμένα καταστήματα. 

Εφόσον δεν υπάρχουν αρνητικά βάρη στις ακμές, είναι προφανές ότι με τη χρήση __Dijkstra shortest path algorithm__ θα μπορέσουμε 
να βρούμε τις αποστάσεις αυτές. Οι τιμές των αποστάσεων αυτών $$X,Y,Z \in [0, D \cdot N]$$ όπου $$D=2 \cdot 10^4$$. Το διάστημα τιμών προκύπτει αν αναλογιστούμε 
ότι ένα από τα προεπιλεγμένα καταστήματα η απόσταση από τον εαυτό του είναι $$0$$ (ελάχιστη τιμή) και αν ο γράφος αποτελείται 
από μια γραμμή με τα καταστήματα σε σειρά, το πρώτο κατάστημα από το τελευταίο θα έχουν τη μέγιστη τιμή $$D \cdot N$$.
Αφού εκτελέσουμε τρείς φορές τον greedy αλγόριθμο του Dijkstra, θα έχουμε υπολογίσει τις τρείς τιμές για το κάθε κατάστημα, 
τις αποστάσεις δηλαδή από τα τρία προεπιλεγμένα καταστήματα. Στη συνέχεια ακολουθεί η επεξήγηση του κυρίως προβλήματος.
 
Μας δίνεται ένας πίνακας με $$N$$ triplets (τριάδες) μη αρνητικών ακεραίων (οι αποστάσεις από τα τρία καταστήματα), 
έστω $$(x,y,z)$$. 
Ζητούμενο είναι να μπορούμε να απαντήσουμε σε queries
της μορφής: **αν υπάρχει για το κατάστημα $$i$$ με τριάδα $$(x_i,y_i,z_i)$$, τουλάχιστο ένα κατάστημα $$j$$ με τριάδα $$(x_j,y_j,z_j)$$ 
με $$i,j \in [1,N]$$ και $$i\neq j$$ και να ισχύουν ταυτόχρονα οι ανισότητες $$x_j\lt x_i, y_j\lt y_i, z_j\lt z_i$$**  

  
  	
  	
## Αργή λύση $$\mathcal{O}(N^2)$$

Δοκιμάζουμε για κάθε κατάστημα $$i$$ από τα $$N$$ αν υπάρχει κάποιο άλλο $$j$$ που να έχει $$x_j\lt x_i$$ και $$y_j\lt y_i$$ και $$z_j\lt z_i$$.
Συνολική πολυπλοκότητα $$\mathcal{O}(N^2)$$. Η λύση αυτή περνά τα 5 από τα 11 test cases. Πολυπλοκότητα Dijkstra $$\mathcal{O}((N+M)\cdot log(N))$$ 
και απαντήσεων ερωτημάτων $$\mathcal{O}(N^2)$$. 
Η πολυπλοκότητα πολυπλοκότητα ορίζεται από τον χειρότερο όρο άρα είναι της τάξης $$\mathcal{O}(N^2)$$.
<details>
  <summary>Ακόμα πιο αργή λύση</summary>
Προσέξτε ότι δεν είναι η $$\mathcal{O}(N^2)$$ η χειρότερη λύση, διότι αν δεν είχαμε επιλέξει μια λογαριθμική λύση για το Dijkstra αλλά την τυπική $$\mathcal{O}((N+M)\cdot N)$$ όπου το μέγιστο 
$$M$$ είναι πολλαπλάσιο του $$N$$ η λύση μας θα ήταν ακόμα χειρότερη.
</details> 
Παρακάτω δίνεται μία ενδεικτική υλοποίηση αυτής της λύσης.

{% include code.md solution_name='souvlakia_n2.cc' %}

## Mέτρια λύση - $$\mathcal{O}(N \cdot log(D \cdot N))$$

Γνώσεις που θα χρειαστούμε: Segment Tree ή Binary Index Tree

Η δυσκολία που παρουσιάζει το πρόβλημα είναι ότι έχουμε τρείς διαφορετικές συνθήκες ανεξάρτητες μεταξύ τους. Θα πρέπει 
να μπορέσουμε να αφαιρέσουμε τουλάχιστο τις δύο συνθήκες με κάποιο τρόπο ώστε να μας μείνει μια γραμμική προσπέλαση για την τρίτη. 
Εφόσον έχουμε να βρούμε διάταξη μεταξύ των αντίτστοιχων τιμών, θα πρέπει να φροντίσουμε να αφαιρέσουμε την μια συνθήκη αντικαθιστώντας την με 
τον χρόνο. Δηλαδή αν ταξινομήσουμε όλα τα καταστήματα με το $$X$$ και κάνουμε προσπέλαση από το μικρότερο προς το 
μεγαλύτερο $$X$$, τότε τη χρονική στιγμή που θα ελέγχουμε το κατάστημα $$i$$ έχουμε προσπελάσει όλα τα καταστήματα $$j$$ 
με $$x_j\lt x_i$$. 

Αυτό βέβαια αυτομάτως σημαίνει ότι δεν μπορούμε να απαντήσουμε τα queries με τη σειρά που μας δίνονται 
και θα πρέπει να τα προϋπολογίσουμε με τη σειρά που μας βολεύει και να τα απαντήσουμε offline.  
Έχοντας ταξινομήσει ως προς $$X$$ ξεχνάμε τελείως τις τιμές αυτές του $$X$$ και επικεντρονόμαστε στις άλλες δυο τιμές τις $$Y$$ και $$Z$$.
Για κάθε $$Y_i$$ που βρίσκουμε καθώς ελέγχουμε το κατάστημα $$i$$ θέλουμε να ξέρουμε αν υπάρχει ένα τουλάχιστο κατάστημα $$j$$ με $$Y_j \lt Y_i$$ 
και $$Z_j \lt Z_i$$. 

Ας το εκφράσουμε λίγο διαφορετικά: αν διατηρούμε από τα καταστήματα που ελέγξαμε έως τώρα με $$Y_j \lt Y_i$$ το $$Z_{min}$$, 
και το $$Z_{min} \lt Z_i$$ τότε το κατάστημα 
$$i$$ δεν είναι επιλέξιμο. Η δομή αυτή που ζητάμε θα πρέπει να μας απαντά το ελάχιστο $$Z$$ για $$Y \in [0,Y_i)$$ 
δηλαδή να μας δίνει το __Range Minimum Query__ όλων των τιμών $$Z$$ σε κάποιο range $$[0,Y_i]$$. 
Μια εύκολη λύση είναι να χρησιμοποιήσουμε ένα Segment Tree ή ένα Binary Index Tree. 

Δυστυχώς οι λύσεις αυτές ενώ χρονικά είναι ικανοποιητικές, δεν θα περνούσαν τα αυστηρά όρια μνήμης του προβλήματος. Το οικονομικότερο σε μνήμη 
και ταχύτερο Binary Index Tree θα ήθελε $$\mathcal{O}(D\cdot N)$$ χώρο μνήμης (όπου $$D$$ το μέγιστο βάρος μιας edge του γράφου), ενώ 
το segment tree θα ήθελε $$\mathcal{O}(2^{ceil(log_2(D\cdot N))+1})$$.

Η προσπέλαση των καταστημάτων γίνεται κατά ομάδες. Ως ομάδα θεωρούνται τα καταστήματα με ίδιο $$X$$. Προφανώς δεν επηρεάζονται 
μεταξύ τους εφόσον δεν ισχύει $$X_i < X_j$$ για οποιαδήποτε $$i,j$$ από τα καταστήματα της ομάδας.
Καθώς τελειώσουμε με τον έλεγχο των καταστημάτων κάθε ομάδας, κάνουμε την ανάλογη ενημέρωση στη δομή μας με τα 
νέα ζεύγη $$(Y_i,Z_i)$$ για κάθε κατάστημα $$i$$ της ομάδας.

Μία ενδεικτική λύση με Segment Tree:

{% include code.md solution_name='souvlakia_nlogn_segtree.cc' start=1 end=76 %}
  
{% include code.md solution_name='souvlakia_nlogn_segtree.cc' start=78 end=119 %}
  
{% include code.md solution_name='souvlakia_nlogn_segtree.cc' start=122 end=173 %}

Ο παραπάνω πλήρης κώδικας χωρίστηκε σε τρία τμήματα, το πρώτο περιέχει σταθερές, το τμήμα του Dijkstra και μερικές βοηθητικές i/o συναρτήσεις,
 το τρίτο είναι η main με την κύρια λειτουργία του προγράμματος (i/o, sort, solve, answer) και το μεσαίο τμήμα περιέχει 
 τον κώδικα του segment tree (modular style). Το τμήμα αυτό θα το βελτιώσουμε στις επόμενες λύσεις μας ενώ 
 το 1ο και 3ο block θα μείνουν ως έχουν.

Μία ενδεικτική λύση με την εξαιρετικά μικρή σε κώδικα και γρήγορη δομή Binary Index Tree θα έχουμε αν αντικαταστήσουμε 
το παραπάνω τμήμα του segment tree με τον παρακάτω κώδικα. 
Παρατηρήστε ότι ενώ το Binary Index Tree χρησιμοποιείται γενικά για Range Sum Queries 
με μια μικρή τροποποίηση δίνει το RMQ.

{% include code.md solution_name='souvlakia_nlogn_BIT.cc' start=80 end=102 %}

## Βέλτιστη λύση - $$\mathcal{O}(N \cdot log(D\cdot N))$$

Γνώσεις που θα χρειαστούμε: Implicit Segment Tree

Στην προηγούμενη λύση παρόλο που έχουμε ένα πεδίο ορισμού για τα $$Y$$ με $$D\cdot N + 1$$ τιμές για να κάνουμε 
τα range query μας, δεν πρόκειται να χρησιμοποιήσουμε περισσότερες από $$N$$ διαφορετικές τιμές για αυτά 
διότι κάθε ένα κατάστημα μπορεί να συνεισφέρει το πολύ ένα $$Y_i$$ στη δομή μας (ή κανένα αν το $$Y_i$$ υπήρχε ήδη στη δομή). 
Άρα αν είχαμε ένα segment tree που να επεκτείνετε (expand) μόνο στα $$Y$$ που χρειάζεται 
και μόνο όταν χρειάζεται τότε θα είχαμε μείωση στην απαιτούμενη μνήμη. 
Το segment tree που θέλουμε θα έπρεπε να κάνει expand προς τα φύλλα του μόνο τις $$N$$ φορές και μάλιστα ούτε τόσες διότι όταν 
κάποιο node έχει δεξιό άκρο το $$Y_i$$ δεν υπάρχει λόγος να συνεχίσουμε να κάνουμε expand σε μεγαλύτερο βάθος, 
τα queries με αυτό το $$Y_i$$ θα βρίσκουν την απάντηση τους στον κόμβο αυτό χωρίς να χρειάζονται μεγαλύτερη ανάλυση σε βάθος. 

Η λύση μας χρησιμοποιεί το __implicit segment tree__ το οποίο γενικά χρησιμοποιείται όταν ξέρουμε από την αρχή τις 
τιμές όλων των κόμβων ή αυτές εννοούνται (implied) (στην περίπτωση μας όλοι οι κόμβοι εννοείται ότι είναι $$\mathit{INF}$$ μέχρι 
να γίνουν σταδιακά update) και δεν θέλουμε να τους δημιουργήσουμε εξ αρχής διότι δεν υπάρχει λόγος να χάνουμε χρόνο και μνήμη. 
Το βάθος του implicit segment tree συνεχίζει να είναι $$log_2(D\cdot N)$$ όπως και του απλού segment tree.

Η λύση αυτή περνά όλα τα test cases.

Μια ενδεικτική τροποποίηση της παραπάνω λύσης του απλού segment tree ακολουθεί. 
Η παρακάτω λύση χρησιμοποιεί static memory allocation 
(το implicit segment tree δεσμεύεται όλο μαζί σαν πίνακας εξ αρχής) με μία απαισιόδοξη προσέγγιση στον αριθμό κόμβων που θα 
χρειαστούμε ώστε να χωρά την χειρότερη δυνατή περίπτωση. 

{% include code.md solution_name='souvlakia_nlogn_implicit_st.cc' start=82 end=135 %}

και μια ενδεικτική τροποποίηση της παραπάνω λύσης με dynamic memory allocation (οι κόμβοι γίνονται allocate δυναμικά όταν και 
αν χρειαστούν και χρησιμοποιούνται pointers για τη διαχείριση του tree):

{% include code.md solution_name='souvlakia_nlogn_implicit_st_cptr.cc' start=78 end=124 %}
  
 
## Βέλτιστη λύση - $$\mathcal{O}(N \cdot log(N))$$

Στην παραπάνω λύση δείξαμε ότι θέλουμε να βρίσκουμε την μικρότερη τιμή $$Z_{min}$$ σε όλα τα $$Y$$ μέχρι 
κάθε δυνατή θέση $$Y_i$$ καταστήματος. 
Κάθε query στη θέση $$Υ_i$$ έχει σαν απάντηση το $$\mathit{RMQ}[0..Y_i]$$ δηλαδή το
το ελάχιστο $$Z$$ όλων των καταστημάτων που συμμετέχουν στο RMQ έως τώρα και έχουν $$Y \in [0,Y_i]$$.
 
Παρατηρήστε ότι καμία θέση $$Y_j, Y_j\gt Y_i$$ δεν μπορεί να έχει $$\mathit{RMQ}[0..Y_j] \gt \mathit{RMQ}[0..Y_i]$$. 

__Απόδειξη:__ έστω $$Y_j>Y_i$$ και $$\mathit{RMQ}[0..Y_j]>\mathit{RMQ}[0..Y_i]$$, όμως το $$\mathit{RMQ}[0..Y_j]$$ περιέχει 
στο πεδίο ορισμού του και το $$\mathit{RMQ}[0..Y_i]$$. Το ελάχιστο στοιχείο ολόκληρου του πεδίου ορισμού $$\mathit{RMQ}[0..Y_j]$$ δεν μπορεί να 
είναι μεγαλύτερο από οποιοδήποτετο στοιχείο του πεδίου ορισμού του άρα και από το $$\mathit{RMQ}[0..Y_i]$$, άρα άτοπη η υπόθεση μας.

Η ακολουθία των $$\mathit{RMQ}[0..Y_i]$$ που μας ενδιαφέρουν, είναι φθίνουσα. Αν μάλιστα πετάξουμε τα διαδοχικά στοιχεία που έχουν ίσο $$Z$$ 
που αποτελούν πλεονασμό, καταλήγουμε να αποθηκεύουμε μια γνησίως φθίνουσα ακολουθία από $$Z$$ τιμές 
$$\forall Y_i,Y_j$$ με $$Y_i \lt Y_j \Leftrightarrow \mathit{RMQ}[0..Y_i] \gt \mathit{RMQ}[0..Y_j]$$. 
Μια βολική δομή για να αποθηκεύσουμε αυτή την ακολουθία είναι ένα map και κάθε 
φορά που θα εισάγουμε ένα νέο ζεύγος $$(Y_i,Z_i)$$ ή θα βελτιώνουμε ένα υπάρχον ζεύγος με μικρότερο $$Z_i$$ τότε 
διορθώνουμε (διαγράφουμε) τα ασύμβατα στοιχεία εκατέρωθεν του $$Y_i$$ ώστε η ακολουθία μας να παραμείνει γνησίως φθίνουσα. 
Κάθε κατάστημα θα εισάγει ένα ζεύγος στοιχείων και κάθε εισαγωγή ελέγχει και διαγράφει $$0$$ έως $$N$$ στοιχεία για να διατηρήσει
την ακολουθία γνησίως φθίνουσα.
Παρόλο ότι μπορεί να διαγράψει $$N$$ στοιχεία ανά update, δεν καταλήγουμε σε $$\mathcal{O}(N^2)$$ πολυπλοκότητα διότι συνολικά
για όλα τα $$Ν$$ updates δεν μπορούν να διαγραφούν περισσότερο από $$Ν$$ στοιχεία, άρα έχουμε __amortized__ $$\mathcal{O}(1)$$ πολυπλοκότητα
ανά update. 

Η λύση αυτή είναι optimal και περνά όλα τα test cases.
Για μια ενδεικτική υλοποίηση αντικαταστήστε το segment tree στον παραπάνω κώδικα με το παρακάτω:

{% include code.md solution_name='souvlakia_nlogn_map.cc' start=80 end=122 %}

## Γενικές Παρατηρήσεις στον κώδικα των λύσεων

Τα στοιχεία στο input είναι πάρα πολλά (ακμές γράφων και ερωτήματα) και ο χρόνος που απαιτείται για το input είναι 
σημαντικός. Προτιμήθηκε η λύση fast i/o με χρήση της __getchar_unlocked__ η οποία υπάρχει σε unix/linux συστήματα και 
παρακάμπτει αρκετούς από τους ελέγχους που εκτελεί η __getchar__ δίνοντας μας ένα πλεονέκτημα χρόνου.  

Οι ακμές των γράφων δεν είναι χρήσιμες μετά την εκτέλεση του Dijkstra οπότε μπορούμε να χρησιμοποιήσουμε 
__vector__ τοπικά μέσα σε compound statement ώστε όταν τελειώσει η compound statement να ελευθερωθεί η μνήμη.  

Ο Dijkstra μπορεί να υπερχειλίσει κάποιους τύπους ακεραίων όταν πάει να προσθέσει δυο $$\mathit{INF}$$ μεταξύ τους οπότε 
μια καλή λύση είναι να μην κάνουμε την πρόσθεση αν ξέρουμε ήδη ότι ο ένας ακέραιος έχει τιμή $$\mathit{INF}$$.

{% include code.md solution_name='souvlakia_nlogn_map.cc' start=53 end=53 %}


