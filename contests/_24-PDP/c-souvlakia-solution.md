---
layout: solution
codename: souvlakia
---

## Επεξήγηση εκφώνησης

Το πρόβλημα αναλύεται σε δυο μέρη, το εισαγωγικό και το κυρίως πρόβλημα. Αρχικά μας δίνει ένα γράφο με $$N$$ 
κόμβους (καταστήματα) και για κάθε ένα $$i$$ από αυτά μας ζητά να υπολογίσουμε τρείς τιμές 
$$(x_i,y_i,z_i)$$ ως τις αποστάσεις των διαδρομών από το κατάστημα $$i$$ προς τρία άλλα προεπιλεγμένα καταστήματα. 

Εφόσον δεν υπάρχουν αρνητικά βάρη στις ακμές, είναι προφανές ότι με τη χρήση __Dijkstra shortest path algorithm__ 
θα μπορέσουμε 
να βρούμε τις αποστάσεις αυτές. Οι τιμές των αποστάσεων αυτών $$x,y,z \in [0, D \cdot N]$$ όπου 
$$D \leq 2 \cdot 10^4$$ το μέγιστο βάρος κάθε ακμής. 
Το διάστημα τιμών προκύπτει αν αναλογιστούμε 
ότι για ένα από τα προεπιλεγμένα καταστήματα η απόσταση από τον εαυτό του 
είναι $$0$$ (ελάχιστη τιμή) και αν ο γράφος αποτελείται 
από μια γραμμή με τα καταστήματα σε σειρά, το πρώτο κατάστημα από το τελευταίο θα έχουν τη μέγιστη τιμή $$D \cdot N$$.
Αφού εκτελέσουμε τρεις φορές τον greedy αλγόριθμο του Dijkstra, θα έχουμε υπολογίσει τις τρεις τιμές για το κάθε κατάστημα, 
τις αποστάσεις δηλαδή από τα τρία προεπιλεγμένα καταστήματα. 

Στη συνέχεια ακολουθεί η επεξήγηση του κυρίως προβλήματος.
 
Μας δίνεται ένας πίνακας με $$N$$ triplets (τριάδες) μη αρνητικών ακεραίων (οι αποστάσεις από τα τρία καταστήματα), 
έστω $$(x,y,z)$$. 
Ζητούμενο είναι να μπορούμε να απαντήσουμε σε queries
της μορφής: **αν υπάρχει για το κατάστημα $$i$$ με τριάδα $$(x_i,y_i,z_i)$$, τουλάχιστο ένα κατάστημα $$j$$ με τριάδα $$(x_j,y_j,z_j)$$ 
με $$i,j \in [1,N]$$ και $$i\neq j$$ και να ισχύουν ταυτόχρονα οι ανισότητες $$x_j\lt x_i, y_j\lt y_i, z_j\lt z_i$$**  
Αν υπάρχει τέτοιο κατάστημα τότε το κατάστημα $$i$$ δεν είναι επιλέξιμο και η απάντηση είναι "NO", αλλιώς είναι "YES".
  
## Αργή λύση $$\mathcal{O}(N^2)$$

Δοκιμάζουμε για κάθε κατάστημα $$i$$ από τα $$N$$ αν υπάρχει κάποιο άλλο $$j$$ που να έχει $$x_j\lt x_i$$ και 
$$y_j\lt y_i$$ και $$z_j\lt z_i$$.
Συνολική πολυπλοκότητα $$\mathcal{O}(N^2)$$. Η λύση αυτή περνά τα 5 από τα 11 test cases. 
Πολυπλοκότητα Dijkstra $$\mathcal{O}((N+M)\cdot log{N})$$ 
και απαντήσεων ερωτημάτων $$\mathcal{O}(N^2)$$. 
Η συνολική πολυπλοκότητα περιορίζεται από τον χειρότερο όρο άρα είναι της τάξης $$\mathcal{O}(N^2)$$ [^1].
Παρακάτω δίνεται μία ενδεικτική υλοποίηση αυτής της λύσης.

{% include code.md solution_name='souvlakia_n2.cc' %}

## Mέτρια λύση - $$\mathcal{O}(N \cdot log(D \cdot N))$$

Γνώσεις που θα χρειαστούμε: ([Segment Tree](https://kallinikos.github.io/Segment-Trees)) ή ([Binary Indexed Tree](https://kallinikos.github.io/Binary-Indexed-Tree))

Η δυσκολία που παρουσιάζει το πρόβλημα είναι ότι έχουμε τρείς διαφορετικές συνθήκες ανεξάρτητες μεταξύ τους. Θα πρέπει 
να μπορέσουμε να αφαιρέσουμε τουλάχιστο τη μία από τις τρεις συνθήκες με κάποιο έξυπνο τρόπο ώστε να μπορέσουμε να δουλέψουμε
τις άλλες δυο. 
Εφόσον έχουμε να βρούμε διάταξη μεταξύ των αντίστοιχων τιμών, μπορούμε να αφαιρέσουμε την μια από τις τρεις συνθήκες αντικαθιστώντας την με 
τον "χρόνο". Δηλαδή αν ταξινομήσουμε όλα τα καταστήματα με τη μία παράμετρο, έστω τη $$x$$ και κάνουμε προσπέλαση από το μικρότερο προς το 
μεγαλύτερο, τότε τη χρονική στιγμή που θα ελέγχουμε το κατάστημα $$i$$ έχουμε προσπελάσει όλα τα καταστήματα $$j$$ 
με $$x_j\lt x_i$$. Αυτό που καταφέρνουμε είναι ότι όλα τα καταστήματα που μπορούν να βγάλουν το κατάστημα $$i$$ ως 
μη επιλέξιμο, θα τα έχουμε 
προσπεράσει με τη σάρωση μας πριν το $$i$$. Όσα καταστήματα βρίσκονται μετά από το $$i$$ δεν το επηρεάζουν.

Αυτό βέβαια αυτομάτως σημαίνει ότι δεν μπορούμε να απαντήσουμε τα queries με τη σειρά που μας δίνονται 
και θα πρέπει να τα προϋπολογίσουμε με τη σειρά που μας βολεύει και να τα απαντήσουμε offline.  
Έχοντας ταξινομήσει ως προς $$x$$ ξεχνάμε τελείως τις τιμές αυτές του $$x$$ και επικεντρονόμαστε στις άλλες 
δυο τιμές τις $$y$$ και $$z$$.
Για κάθε $$y_i$$ που βρίσκουμε καθώς ελέγχουμε το κατάστημα $$i$$ θέλουμε να ξέρουμε αν υπάρχει ένα τουλάχιστο κατάστημα $$j$$ με $$y_j \lt y_i$$ 
και $$z_j \lt z_i$$. 

Ας το εκφράσουμε λίγο διαφορετικά: αν διατηρούμε από τα καταστήματα που ελέγξαμε έως τώρα με $$y_j \lt y_i$$ μόνο το 
$$z_{min}$$, 
και αυτό το $$z_{min} \lt z_i$$ τότε το κατάστημα 
$$i$$ δεν είναι επιλέξιμο γιατί τουλάχιστο ένα άλλο κατάστημα προτιμάται. Η δομή αυτή που ζητάμε θα πρέπει να μας απαντά 
το ελάχιστο $$z$$ για όλα $$y \in [0,y_i)$$ 
δηλαδή να μας δίνει το __Range Minimum Query__ όλων των τιμών $$z$$ σε κάποιο range $$[0,y_i-1]$$. 
Μια εύκολη λύση είναι να χρησιμοποιήσουμε ένα Segment Tree ή ένα Binary Indexed Tree. 

Δυστυχώς οι λύσεις αυτές ενώ χρονικά είναι ικανοποιητικές, δεν θα περνούσαν τα αυστηρά όρια μνήμης του 
προβλήματος ακόμα και αν επαναχρησιμοποιήσουμε τη μνήμη που δεν χρειάζεται[^2]. 
Το οικονομικότερο σε μνήμη 
και ταχύτερο Binary Indexed Tree θα ήθελε μνήμη της τάξης $$\mathcal{O}(D\cdot N)$$ (όπου $$D$$ το μέγιστο βάρος μιας edge του γράφου), ενώ 
το segment tree θα ήθελε μνήμη τάξης $$\mathcal{O}(2^{ceil(log_2(D\cdot N))+1})$$.

Η προσπέλαση των καταστημάτων γίνεται κατά ομάδες. Ως ομάδα θεωρούνται τα καταστήματα με ίδιο $$x$$. Προφανώς δεν επηρεάζονται 
μεταξύ τους εφόσον δεν ισχύει $$x_i < x_j$$ για οποιαδήποτε $$i,j$$ από τα καταστήματα της ομάδας.
Καθώς τελειώσουμε με τον έλεγχο των καταστημάτων κάθε ομάδας, κάνουμε την ανάλογη ενημέρωση στη δομή μας με τα 
νέα ζεύγη $$(y_i,z_i)$$ για κάθε κατάστημα $$i$$ της ομάδας ώστε να ετοιμάσουμε τη δομή μας για τον έλεγχο των επόμενων 
ομάδων που ενδέχετε να επηρεάζονται από την ομάδα που μόλις προσπελάσαμε.

Μία ενδεικτική λύση με Segment Tree:

{% include code.md solution_name='souvlakia_nlogn_segtree.cc' start=1 end=76 %}
  
{% include code.md solution_name='souvlakia_nlogn_segtree.cc' start=78 end=120 %}
  
{% include code.md solution_name='souvlakia_nlogn_segtree.cc' start=122 end=173 %}

Ο παραπάνω πλήρης κώδικας χωρίστηκε σε τρία τμήματα, το πρώτο περιέχει σταθερές, το τμήμα του Dijkstra [^3] και 
μερικές βοηθητικές i/o συναρτήσεις για fast-io [^4], το τρίτο είναι η main με την 
κύρια λειτουργία του προγράμματος (i/o, sort, solve, answer) και το μεσαίο τμήμα περιέχει 
τον κώδικα του segment tree (modular style). Το τμήμα αυτό θα το βελτιώσουμε στις 
επόμενες λύσεις μας ενώ το 1ο και 3ο block θα μείνουν ως έχουν.

Μία ακόμα ενδεικτική λύση με την εξαιρετικά γρήγορη και μικρή σε κώδικα και απαιτούμενη μνήμη (σε σχέση με το Segment Tree) 
είναι η δομή Binary Indexed Tree.  
Το Binary Indexed Tree παρόλο που και αυτό έχει λογαριθμική πολυπλοκότητα είναι φανερό ότι απαιτει πολύ λιγότερες 
εντολές να εκτελέσει αλλά και λιγότερη μνήμη να προσπελάσει για να κάνει Range Queries. Το 
μειονέκτημα του είναι ότι δεν είναι τόσο γενική χρήσης, δεν έχει δηλαδή τόσο ευρύ πεδίο εφαρμογών, όπως το Segment Tree.
Παρατηρήστε ότι ενώ το Binary Indexed Tree χρησιμοποιείται γενικά για Range Sum Queries 
με μια μικρή τροποποίηση δίνει το RMQ.
Το module του Binary Indexed Tree που αντικαθιστα το module του segment tree στον παραπάνω κώδικα ακολουθεί:
{% include code.md solution_name='souvlakia_nlogn_BIT.cc' start=80 end=102 %}

## Βέλτιστη λύση - $$\mathcal{O}(N \cdot log(D\cdot N))$$

Γνώσεις που θα χρειαστούμε: Implicit Segment Tree

Στην προηγούμενη λύση παρόλο που έχουμε ένα πεδίο ορισμού για τα $$y$$ με $$D\cdot N + 1$$ τιμές για να κάνουμε 
τα range query μας, δεν πρόκειται να χρησιμοποιήσουμε περισσότερες από $$N$$ διαφορετικές τιμές για αυτά 
διότι κάθε ένα κατάστημα μπορεί να συνεισφέρει το πολύ ένα $$y_i$$ στη δομή μας (ή κανένα αν το $$y_i$$ υπήρχε ήδη στη δομή). 
Άρα αν είχαμε ένα segment tree που να επεκτείνετε (expand) μόνο στα $$y$$ που χρειάζεται 
και μόνο όταν χρειάζεται να επεκταθεί, τότε θα είχαμε μείωση στην απαιτούμενη μνήμη. 
Το segment tree που θέλουμε θα πρέπει να κάνει expand προς τα φύλλα του μόνο τις $$N$$ φορές και μάλιστα ούτε τόσες διότι όταν 
κάποιο κόμβο έχει δεξιό άκρο το $$y_i$$ δεν υπάρχει λόγος να συνεχίσουμε να κάνουμε expand σε μεγαλύτερο βάθος, διότι θα έχει 
οριοθετήσει ικανοποιητικά το range $$[0,y_i]$$ μέχρι τον κόμβο αυτό και τα queries με αυτό το $$y_i$$ θα 
βρίσκουν την απάντηση τους στον κόμβο αυτό χωρίς να χρειάζονται να συνεχίζουν σε μεγαλύτερο βάθος. 

Η λύση μας χρησιμοποιεί το __implicit segment tree__ το οποίο γενικά χρησιμοποιείται όταν ξέρουμε από την αρχή τις 
τιμές όλων των κόμβων ή όταν αυτές εννοούνται (implied). Παράδειγμα δεν έχει νόημα να κάνουμε build ένα segment tree που 
οι τιμές όλων των κόμβων είναι αρχικά όλες $$0$$.
Στην περίπτωση μας όλοι οι κόμβοι εννοείται ότι είναι $$\mathit{INF}$$ ώστε να μην επηρεάζουν κανένα κατάστημα και 
σταδιακά θα αρχίσουν να γίνονται update. Το βάθος του implicit segment tree συνεχίζει να είναι 
$$log_2(D\cdot N)$$ όπως και του απλού segment tree εφόσον αναφέρετε στο ίδιο εύρως τιμών $$y$$.

Η λύση αυτή περνά όλα τα test cases οριακά.

Μια ενδεικτική τροποποίηση της παραπάνω λύσης του απλού segment tree ακολουθεί. 
Η παρακάτω λύση χρησιμοποιεί static memory allocation 
(το implicit segment tree δεσμεύεται όλο μαζί σαν πίνακας εξ αρχής) με μία απαισιόδοξη προσέγγιση στον αριθμό κόμβων που θα 
χρειαστούμε ώστε να χωρά την χειρότερη δυνατή περίπτωση. 

{% include code.md solution_name='souvlakia_nlogn_implicit_st.cc' start=82 end=135 %}

και μια ενδεικτική τροποποίηση της παραπάνω λύσης με dynamic memory allocation ακολουθεί (οι κόμβοι γίνονται allocate δυναμικά όταν και 
αν χρειαστούν και χρησιμοποιούνται pointers για τη διαχείριση του tree). Η χρήση pointers και dynamic memory allocation θα 
καταλάβει μόνο όση μνήμη χρειάζεται αλλά η χρήση pointers απαιτεί μεγαλύτερη ευχέρεια στο χειρισμό της γλώσσας 
προγραμματισμού.

{% include code.md solution_name='souvlakia_nlogn_implicit_st_cptr.cc' start=78 end=124 %}
  
 
## Βέλτιστη λύση - $$\mathcal{O}(N \cdot log{N})$$

Στην παραπάνω λύση δείξαμε ότι θέλουμε να βρίσκουμε την μικρότερη τιμή $$z_{min}$$ από το $$0$$ έως κάθε δυνατή θέση $$y_i$$ καταστήματος. 
Κάθε query στη θέση $$y_i$$ έχει σαν απάντηση το $$\mathit{RMQ}[0..y_i]$$ δηλαδή 
το ελάχιστο $$z$$ όλων των καταστημάτων που συμμετέχουν στο RMQ έως τώρα και έχουν $$y \in [0,y_i]$$.
Αυτό που θέλουμε δηλαδή είναι ένα prefix minimum η δημιουργία του οποίου παίρνει χρόνο $$\mathcal{O}(N)$$ (όπως και του prefix sum).
Η δυσκολία σε αυτό το prefix minimum είναι ότι θέλουμε να κάνουμε updates σε τυχαία σημεία. Για να μπορέσουμε να κάνουμε τα updates 
αποδοτικά και να μην επανυπολογίζουμε το prefix minimum μετά από κάθε ενημέρωση, πρέπει να αξιοποιήσουμε τη βασική ιδιότητα του:  
καμία θέση $$y_j, y_j\gt y_i$$ δεν μπορεί να έχει $$\mathit{RMQ}[0..y_j] \gt \mathit{RMQ}[0..y_i]$$. 

__Απόδειξη:__ έστω $$y_j>y_i$$ και $$\mathit{RMQ}[0..y_j]>\mathit{RMQ}[0..y_i]$$, όμως το $$\mathit{RMQ}[0..y_j]$$ περιέχει 
στο πεδίο ορισμού του και το $$\mathit{RMQ}[0..y_i]$$. Το ελάχιστο στοιχείο ολόκληρου του πεδίου ορισμού $$\mathit{RMQ}[0..y_j]$$ δεν μπορεί να 
είναι μεγαλύτερο από οποιοδήποτετο στοιχείο του πεδίου ορισμού του άρα και από το $$\mathit{RMQ}[0..y_i]$$, άρα άτοπη η υπόθεση μας.

Η ακολουθία των $$\mathit{RMQ}[0..y_i]$$ που μας ενδιαφέρουν, είναι φθίνουσα. Αν μάλιστα πετάξουμε τα διαδοχικά στοιχεία που έχουν ίσο $$z$$ 
που αποτελούν πλεονασμό και κρατήσουμε μόνο το νωρίτερο σημείο που εμφανίζεται η ίδια τιμή $$z$$, καταλήγουμε να αποθηκεύουμε μια 
γνησίως φθίνουσα ακολουθία από $$z$$ τιμές 
$$\forall y_i,y_j$$ με $$y_i \lt y_j \Leftrightarrow \mathit{RMQ}[0..y_i] \gt \mathit{RMQ}[0..y_j]$$. 

Μια βολική δομή για να αποθηκεύσουμε αυτή την ακολουθία είναι ένα __std::map__ ή ένα __std::set__ και κάθε 
φορά θα εισάγουμε ένα νέο ζεύγος $$(y_i,z_i)$$ ή θα προσπαθούμε να βελτιώσουμε ένα υπάρχον ζεύγος με μικρότερο $$z_i$$. Καθώς εισάγουμε ή μεταβάλουμε ένα 
σημείο της ακολουθίας μας διορθώνουμε (διαγράφουμε) τα ασύμβατα στοιχεία που ακολουθούν το $$y_i$$ ώστε η ακολουθία μας να παραμείνει γνησίως φθίνουσα. 
Ας δούμε όλες τις περιπτώσεις που προκύπτουν από την εισαγωγή ενός σημείου $$(y_i,z_i)$$ στη δομή μας με τη βοήθεια του παρακάτω σχήμτος

![Παράδειγμα](/assets/24-pdp-c3-souvlakia-1.svg){:width="350px"}  

Διακρίνουμε πέντε περιπτώσεις:  
* (μπλέ σημείο) είναι μεγαλύτερο από το προηγούμενο $$z$$ άρα αγνοείται και δεν αλλάζει η δομή μας  
* (κόκκινο σημείο) είναι ίσο με το προηγούμενο $$z$$, οπότε πάλι αγνοείται και δεν αλλάζει η δομή μας  
* (κίτρινο σημείο) είναι ανάμεσα στο προηγούμενο και στο επόμενο. Εισάγεται και δεν χαλάει την μονοτονία της ακολουθίας.  
* (πράσινο σημείο) είναι ίσο με το επόμενο $$z$$. Το επόμενο σημείο διαγράφεται εφόσον καλύπτεται από αυτό που εισάγουμε τώρα.  
* (ροζ σημείο) είναι χαμηλότερο από το επόμενο σημείο. Θα διαγραφτούν όλα τα επόμενα σημεία με $$z \ge z_i$$.  

Κάθε κατάστημα κατά το update στη δομή μας ελέγχει τη μονοτονία της και διαγράφει $$0$$ έως $$N$$ στοιχεία για να διατηρήσει
την ακολουθία γνησίως φθίνουσα. Το κάθε update έχει $$\mathcal{O}(log{N})$$ πολυπλοκότητα.
Παρόλο ότι μπορεί να διαγράψει $$N$$ στοιχεία σε ένα update, δεν καταλήγουμε σε $$\mathcal{O}(N^2\cdot log N)$$ πολυπλοκότητα διότι συνολικά
για όλα τα $$Ν$$ updates δεν μπορούν να διαγραφούν περισσότερο από $$Ν$$ στοιχεία, άρα έχουμε __amortized__ $$\mathcal{O}(log {N})$$ πολυπλοκότητα
ανά update. 

Η λύση αυτή είναι optimal και περνά όλα τα test cases.
Για μια ενδεικτική υλοποίηση αντικαταστήστε το segment tree στον παραπάνω κώδικα με το παρακάτω:

{% include code.md solution_name='souvlakia_nlogn_map.cc' start=80 end=114 %}


[^1]: Η $$\mathcal{O}(N^2)$$ δεν είναι η χειρότερη λύση, διότι αν δεν είχαμε επιλέξει μια λογαριθμική λύση με τη χρήση του std::set για το Dijkstra αλλά μια λύση με loop $$\mathcal{O}((N+M)\cdot N)$$ όπου στο συγκεκριμένο πρόβλημα το μέγιστο $$M$$ είναι πολλαπλάσιο του $$N$$ η λύση μας θα ήταν ακόμα χειρότερη.

[^2]: Οι ακμές των γράφων δεν είναι χρήσιμες μετά την εκτέλεση του Dijkstra οπότε μπορούμε να χρησιμοποιήσουμε __vector__ τοπικά μέσα σε compound statement ώστε όταν τελειώσει η compound statement να ελευθερωθεί η μνήμη του vector.  

[^3]: Ο Dijkstra μπορεί να υπερχειλίσει κάποιους τύπους ακεραίων όταν πάει να προσθέσει δυο $$\mathit{INF}$$ μεταξύ τους οπότε μια καλή λύση είναι να μην κάνουμε την πρόσθεση αν ξέρουμε ήδη ότι ο ένας ακέραιος έχει τιμή $$\mathit{INF}$$.

[^4]: Τα στοιχεία στο input είναι πάρα πολλά (ακμές γράφων και ερωτήματα) και ο χρόνος που απαιτείται για το input είναι σημαντικός. Προτιμήθηκε η λύση fast i/o με χρήση της __getchar_unlocked__ η οποία υπάρχει σε unix/linux συστήματα και παρακάμπτει αρκετούς από τους ελέγχους που εκτελεί η __getchar__ δίνοντας μας ένα πλεονέκτημα χρόνου.

