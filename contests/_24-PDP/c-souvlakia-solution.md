---
layout: solution
codename: souvlakia
---

## Επεξήγηση εκφώνησης

Το πρόβλημα αναλύεται σε δυο μέρη, το εισαγωγικό και το κυρίως πρόβλημα.

**Εισαγωγικό πρόβλημα:** Μας δίνετε γράφος με $$N$$ κόμβους (καταστήματα) και για κάθε κατάστημα $$i$$, ζητείται να υπολογίσουμε τρείς τιμές $$(x_i,y_i,z_i)$$ ως τις αποστάσεις των διαδρομών από το κατάστημα $$i$$ προς τρία άλλα προεπιλεγμένα καταστήματα. Εφόσον δεν υπάρχουν αρνητικά βάρη στις ακμές, είναι ευνόητο ότι με τη χρήση του greedy αλγορίθμου εύρεσης καλύτερης διαδρομής του __Dijkstra__ θα μπορέσουμε να βρούμε τις αποστάσεις αυτές. Οι τιμές των αποστάσεων αυτών $$x,y,z \in [0, D \cdot N]$$, όπου $$D = 2 \cdot 10^4$$ το μέγιστο βάρος κάθε ακμής.  
Το διάστημα τιμών προκύπτει αν αναλογιστούμε ότι για ένα από τα προεπιλεγμένα καταστήματα η απόσταση από τον εαυτό του είναι $$0$$ (ελάχιστη τιμή) και μια διαδρομή μπορεί να έχει έως $$N$$ καταστήματα, οπότε ως μέγιστη απόσταση έχουμε την τιμή  $$D \cdot N$$.
Εκτελούμε τρεις φορές τον αλγόριθμο του Dijkstra (μία φορά για το κάθε προεπιλεγμένο κατάστημα), υπολογίζοντας τις αποστάσεις κάθε καταστήματος από τα τρία προεπιλεγμένα, οπότε θα μπορέσουμε να συνεχίσουμε στο κυρίως πρόβλημα μας του οποίου η επεξήγηση ακολουθεί.

**Κυρίως πρόβλημα:** Μας δίνεται ένας πίνακας με $$N$$ triplets (τριάδες) μη αρνητικών ακεραίων (οι αποστάσεις από τα τρία καταστήματα), έστω $$(x,y,z)$$. 
Ζητούμενο είναι να μπορούμε να απαντήσουμε σε queries της μορφής: **αν υπάρχει για το κατάστημα $$i$$ με τριάδα $$(x_i,y_i,z_i)$$, τουλάχιστο ένα κατάστημα $$j$$ με τριάδα $$(x_j,y_j,z_j)$$ 
με $$i,j \in [1,N]$$ και $$i\neq j$$ και να ισχύουν ταυτόχρονα οι ανισότητες $$x_j\lt x_i, y_j\lt y_i, z_j\lt z_i$$**  
Αν υπάρχει τέτοιο κατάστημα τότε το κατάστημα $$i$$ δεν είναι επιλέξιμο και η απάντηση είναι "NO", αλλιώς είναι "YES".

Στη συνέχεια θα δωθούν με τη σειρά διαφορετικές λύσεις με σκοπό να μεταβούμε ομαλά από την εύκολη και μη αποδεκτή λύση (brute force), σε λύσεις με segment tree και binary indexed tree, implicit segment tree, coordinate compression + binary indexed tree μέχρι την τελική optimal λύση.  

## Λύση Brute Force $$\mathcal{O}(N^2)$$

Δοκιμάζουμε για κάθε κατάστημα $$i$$ από τα $$N$$ αν υπάρχει κάποιο άλλο $$j$$ που να έχει $$x_j\lt x_i$$ και 
$$y_j\lt y_i$$ και $$z_j\lt z_i$$.
Συνολική πολυπλοκότητα $$\mathcal{O}(N^2)$$. Η λύση αυτή περνά τα 8 από τα 11 test cases. 
Πολυπλοκότητα Dijkstra $$\mathcal{O}((N+M)\cdot \log {N})$$ 
και απαντήσεων ερωτημάτων $$\mathcal{O}(N^2)$$. 
Η συνολική πολυπλοκότητα περιορίζεται από τον χειρότερο όρο άρα είναι της τάξης $$\mathcal{O}(N^2)$$ [^1].
Παρακάτω δίνεται μία ενδεικτική υλοποίηση αυτής της λύσης.

{% include code.md solution_name='souvlakia_n2.cc' %}

## Λύση με Segment Tree - $$\mathcal{O}(N \cdot \log {(D \cdot N)})$$

Γνώσεις που θα χρειαστούμε: [Segment Tree](https://kallinikos.github.io/Segment-Trees)

Η δυσκολία που παρουσιάζει το πρόβλημα είναι ότι έχουμε τρείς διαφορετικές συνθήκες **ανεξάρτητες** μεταξύ τους. Τη μια συνθήκη θα την αφαιρέσουμε εύκολα αν φροντίσουμε να έχουμε τελειώσει με όλα τα καταστήματα που είναι δυνατόν να καταστήσουν μη επιλέξιμο (ακυρώσουν) ένα κατάστημα $$i$$ πριν φτάσουμε να επεξεργαστούμε το $$i$$. Για το σκοπό αυτό αρκεί να ταξινομήσουμε σε αύξουσα σειρά τα καταστήματα με τη μία τιμή (έστω την τιμή $$x$$) οπότε όταν θα φτάνουμε στο κατάστημα με $$x_i$$ θα έχουμε τελειώσει με όλα τα καταστήματα $$j$$ με $$x_j \lt x_i$$[^2].
Όσα καταστήματα βρίσκονται μετά από το $$i$$ δεν το επηρεάζουν διότι δεν έχουν μικρότερο $$x$$.  
Αυτό βέβαια αυτομάτως σημαίνει ότι δεν μπορούμε να απαντήσουμε τα queries με τη σειρά που μας δίνονται και θα πρέπει να τα προϋπολογίσουμε με τη σειρά που μας βολεύει και να τα απαντήσουμε αργότερα, δηλαδή offline.  

Για το $$y_i$$ του καταστήματος $$S_i$$ θέλουμε να ξέρουμε αν υπάρχει ένα τουλάχιστο κατάστημα $$j$$ με $$y_j \lt y_i$$ 
και $$z_j \lt z_i$$. Ας δούμε το παρακάτω σχήμα όπου το κατάστημα $$S_i(y_i,z_i)$$ ακυρώνεται αν υπάρχει έστω και ένα κατάστημα στη γραμμοσκιασμένη περιοχή [^9]. 

![Παράδειγμα](/assets/24-pdp-c3-souvlakia-2.svg){:width="350px"}  

Παρατηρήστε ότι τα πράσινα σημεία δεν επηρεάζουν το κατάστημα $$S_i$$ ενώ το κόκκινο σημείο το ακυρώνει. Η δομή που απαντά τέτοια ερωτήματα είναι η **range minimum query** αν βάλουμε ως πεδίο ορισμού της, τις τιμές $$y$$ και σαν πεδίο τιμών θα έχει ένα υποσύνολο των $$z$$ των καταστημάτων[^3]. Ας συμβολίσουμε τη δομή μας ως μια συνάρτηση $$RMQ(Y)$$ δηλαδή το range minimum query των τιμών $$z$$ για όλα τα $$y \in [0,Y]$$.  
Το γραμμοσκιασμένο παραλληλόγραμμο έχει όρια στην κορυφή $$(y_i-1,z_i-1)$$. Έστω $$z_{min} = \mathit{RMQ} (y_i-1)$$, αν $$z_{min} \lt z_i$$ τότε υπάρχει κατάστημα στη γραμμοσκιασμένη περιοχή και το κατάστημα $$S_i$$ ακυρώνεται (η απάντηση είναι "NO") αλλιώς η απάντηση είναι "YES". Στο παραπάνω σχήμα το $$\mathit{RMQ} (y_i-1)$$ θα έδεινε το $$z$$ του κόκκινου σημείου.


Στο ακόλουθο σχήμα εμφανίζεται η λειτουργία του RMQ με γραφικό τρόπο αφού έχουν γίνει οι απαραίτητες ενημερώσεις του από τα καταστήματα $$s_1$$ έως και $$s_7$$ [^9].

![Παράδειγμα](/assets/24-pdp-c3-souvlakia-3.svg){:width="350px"}  
<style>table, th,td { border: 6px; } </style>
|Χρώμα περιοχής&nbsp;&nbsp;|Διάστημα | $$\mathit{RMQ}(y)$$|
|----------------|-------------|-----------|
|Κόκκινη&nbsp;&nbsp;| $$0 \le y \lt y_1$$&nbsp;&nbsp;|$$+\infty$$|
|Μωβ&nbsp;&nbsp;| $$y_1 \le y \lt y_7$$&nbsp;&nbsp;|$$z_1$$|
|Κίτρινη&nbsp;&nbsp;| $$y_7 \le y \lt y_2$$&nbsp;&nbsp;|$$z_7$$|
|Πράσινη&nbsp;&nbsp;| $$y_2 \le y \lt y_4$$&nbsp;&nbsp;|$$z_2$$|
|Μπλε&nbsp;&nbsp;| $$y_4 \le y \lt +\infty$$&nbsp;&nbsp;&nbsp;&nbsp; |$$z_4$$|


Μια εύκολη λύση είναι να χρησιμοποιήσουμε ένα segment tree. 
Η προσπέλαση των καταστημάτων γίνεται κατά ομάδες. Ως ομάδα θεωρούνται τα καταστήματα με ίδιο $$x$$[^10]. Καθώς τελειώσουμε με τον έλεγχο των καταστημάτων κάθε ομάδας, κάνουμε την ανάλογη ενημέρωση στη δομή μας με τα νέα ζεύγη $$(y_i,z_i)$$ ώστε να ετοιμάσουμε τη δομή μας για τον έλεγχο των επόμενων ομάδων.

Δυστυχώς η λύση αυτή ενώ χρονικά είναι ικανοποιητική, δεν περνά τα αυστηρά όρια μνήμης του προβλήματος ακόμα και αν επαναχρησιμοποιήσουμε τη μνήμη που δεν χρειάζεται πλέον[^4] καθώς απαιτεί μνήμη της τάξης $$\mathcal{O}(D\cdot N)$$[^7] για το segment tree με πεδίο ορισμού $$D\cdot N$$ τιμών.

Μία ενδεικτική λύση με segment tree ακολουθεί, χωρισμένη σε τρία τμήματα.

**Τμήμα 1<sup>o</sup>:** Περιέχει σταθερές, το τμήμα του Dijkstra[^5] και μερικές βοηθητικές i/o συναρτήσεις για fast-io[^6]
{% include code.md solution_name='souvlakia_nlogn_segtree.cc' start=1 end=76 %}
  
**Τμήμα 2<sup>o</sup>:** Η δομή RMQ με χρήση segment tree
{% include code.md solution_name='souvlakia_nlogn_segtree.cc' start=78 end=120 %}
  
**Τμήμα 3<sup>o</sup>:** Η main με την κύρια λειτουργία του προγράμματος (i/o, sort, solve, answer)
{% include code.md solution_name='souvlakia_nlogn_segtree.cc' start=122 end=173 %}

Η επιλογή να κοπεί το πρόγραμμα σε τρία τμήματα έγινε γιατί στη συνέχεια θα δούμε τις εναλλακτικές μορφές της δομής μας αλλάζοντας μόνο το δεύτερο τμήμα και κρατώντας το πρώτο και τρίτο ως έχουν.


## Λύση με Binary Indexed Tree - $$\mathcal{O}(N \cdot \log {(D \cdot N)})$$

Γνώσεις που θα χρειαστούμε: [Binary Indexed Tree](https://kallinikos.github.io/Binary-Indexed-Tree)

To binary indexed tree είναι λίγο οικονομικότερο σε μνήμη (παρόλο που και αυτό είναι της τάξης $$\mathcal{O}(D\cdot N)$$) σε σχέση με το segment tree, αλλά και πάλι ξεπερνά τα αποδεκτά όρια μνήμης του προβλήματος.
Το μειονέκτημα του είναι ότι δεν είναι τόσο γενική χρήσης, δεν έχει δηλαδή τόσο ευρύ πεδίο εφαρμογών, όπως το segment tree και γενικά υπολογίζει από την αρχή (ή το τέλος) έως το σημείο του query άρα είναι κατάλληλο για υπολογισμούς [prefix ή suffix](https://kallinikos.github.io/Binary-Indexed-Tree#prefix-minmax-queries-%CE%BA%CE%B1%CE%B9-point-updates) τιμών υπό προϋποθέσεις.

Μια ενδεικτική λύση έχουμε αντικαθιστώντας το τμήμα 2 του παραπάνω κώδικα με το παρακάτω απόσπασμα:
{% include code.md solution_name='souvlakia_nlogn_BIT.cc' start=78 end=104 %}

## Αποδεκτή Λύση με Implicit Segment Tree - $$\mathcal{O}(N \cdot \log(D\cdot N))$$

Γνώσεις που θα χρειαστούμε: Implicit Segment Tree

Στην προηγούμενη λύση παρόλο που έχουμε ένα πεδίο ορισμού για τα $$y$$ με $$D\cdot N + 1$$ τιμές για να κάνουμε τα range query μας, δεν πρόκειται να χρησιμοποιήσουμε περισσότερες από $$N$$ διαφορετικές τιμές για αυτά διότι κάθε κατάστημα μπορεί να συνεισφέρει το πολύ ένα $$y_i$$ στη δομή μας. 
Άρα αν είχαμε ένα segment tree που να επεκτείνετε (expand) μόνο στα $$y$$ που χρειάζεται και μόνο όταν χρειάζεται να επεκταθεί, τότε θα είχαμε μείωση στην απαιτούμενη μνήμη. 

Το segment tree που θέλουμε θα πρέπει να κάνει expand προς τα φύλλα του μόνο τις $$N$$ φορές και μάλιστα ούτε τόσες διότι όταν κάποιος κόμβος έχει δεξιό άκρο το $$y_i$$ δεν υπάρχει λόγος να συνεχίσουμε να κάνουμε expand σε μεγαλύτερο βάθος, διότι ο κόμβος αυτός έχει οριοθετήσει ικανοποιητικά το range $$[0,y_i]$$ και τα queries με αυτό το $$y_i$$ θα βρίσκουν την απάντηση τους χωρίς να χρειάζονται να συνεχίζουν σε μεγαλύτερο βάθος. 

Η λύση μας χρησιμοποιεί το **implicit segment tree** το οποίο γενικά χρησιμοποιείται όταν ξέρουμε από την αρχή τις τιμές όλων των κόμβων ή όταν αυτές εννοούνται (implied). Παράδειγμα: δεν έχει νόημα να κάνουμε build ένα segment tree που οι τιμές όλων των κόμβων είναι αρχικά όλες $$0$$.
Στην περίπτωση μας όλοι οι κόμβοι εννοείται ότι είναι $$\mathit{INF}$$ ώστε να μην επηρεάζουν κανένα κατάστημα και σταδιακά θα αρχίσουν να γίνονται update. Το βάθος του implicit segment tree συνεχίζει να είναι $$\log_2(D\cdot N)$$ όπως και του απλού segment tree εφόσον αναφέρετε στο ίδιο εύρως τιμών $$y$$.

Η λύση αυτή περνά όλα τα test cases οριακά.

Η παρακάτω λύση χρησιμοποιεί static memory allocation 
(το implicit segment tree δεσμεύεται όλο μαζί σαν πίνακας εξ αρχής) με μία απαισιόδοξη προσέγγιση στον αριθμό κόμβων που θα 
χρειαστούμε ώστε να χωρά την χειρότερη δυνατή περίπτωση. 

{% include code.md solution_name='souvlakia_nlogn_implicit_st.cc' start=82 end=134 %}

και μια ενδεικτική τροποποίηση της παραπάνω λύσης με dynamic memory allocation ακολουθεί (οι κόμβοι γίνονται allocate δυναμικά όταν και 
αν χρειαστούν και χρησιμοποιούνται pointers για τη διαχείριση του tree). Η χρήση pointers και dynamic memory allocation θα 
καταλάβει μόνο όση μνήμη χρειάζεται αλλά η χρήση pointers απαιτεί μεγαλύτερη ευχέρεια στο χειρισμό της γλώσσας 
προγραμματισμού.

{% include code.md solution_name='souvlakia_nlogn_implicit_st_cptr.cc' start=78 end=125 %}
  
 
## Βέλτιστη λύση με συμπίεση συντεταγμένων - $$\mathcal{O}(N \cdot \log {N})$$

Γνώσεις που θα χρειαστούμε: σύμπτυξη ή συμπίεση συντεταγμένων (coordinate compression)

Έχουμε το πολύ $$N$$ τιμές. Έστω ότι έχουμε ακριβώς $$\mathit{YMAX}$$ διαφορετικές τιμές $$y$$ ($$\mathit{YMAX} \le N$$). Mπορούμε να "συμπιέσουμε" τις τιμές $$y$$, δηλαδή να τις αντικαταστήσουμε με **διαδοχικούς** αριθμούς ανάμεσα στο $$0$$ και στο $$\mathit{YMAX}$$ αφαιρώντας τα "κενά" ανάμεσα τους. Αντικαθιστούμε το $$y_i$$ κάθε καταστήματος $$i$$ με έναν αριθμό από το $$1$$ έως το $$\mathit{YMAX}$$  (συμπιεσμένη τιμή) έτσι ώστε να μην χαλάσει η διάταξη (order) μεταξύ των καταστημάτων, δηλαδή για όλους τους συνδυασμούς καταστημάτων $$i,j$$ θα ισχύουν οι συνθήκες:  

$$y_i =  y_j \Leftrightarrow \mathit{compressed}(y_i) = \mathit{compressed}(y_j)$$  

$$y_i \lt y_j \Leftrightarrow \mathit{compressed}(y_i) \lt \mathit{compressed}(y_j)$$  

Με τον τρόπο αυτό περιορίζουμε το πεδίο ορισμού στο οποίο πρέπει να απαντά ερωτήματα το binary indexed tree (ή το segment tree) από $$D\cdot N$$ σε $$\mathit{YMAX}$$, οπότε δεν ξεπερνάμε τα όρια μνήμης του προβλήματος καθώς:

$$0\lt\mathit{YMAX}\leq N \lt D\cdot N$$  

Αντικαθιστούμε το τμήμα 2 της παραπάνω λύσης με το παρακάτω απόσπασμα που χρησιμοποιεί compression + binary indexed tree. Η λύση αυτή περνά όλα τα test cases.

{% include code.md solution_name='souvlakia_nlogn_yzip2_BIT.cc' start=79 end=118 %}
  



## Βέλτιστη λύση με prefix minimum - $$\mathcal{O}(N \cdot \log {N})$$

Στην παραπάνω λύση δείξαμε ότι ψάχνουμε την μικρότερη τιμή $$z_{min}$$ από το $$0$$ έως κάθε δυνατή θέση $$y_i$$ καταστήματος. Κάθε query στη θέση $$y_i$$ έχει σαν απάντηση το $$\mathit{RMQ}(y_i)$$ δηλαδή το ελάχιστο $$z$$ όλων των καταστημάτων που συμμετέχουν στο RMQ έως τώρα και έχουν $$y \in [0,y_i]$$.
Αυτό που Θέλουμε είναι μια ειδική περίπτωση του range query που ψάχνουμε το ελάχιστο $$z$$ από όλα τα $$y$$ από το αριστερότερο άκρο του άξονα, έως ένα συγκεκριμένο $$y_i$$. 
Η λύση λέγεται **prefix minimum**, η δημιουργία του οποίου γενικά παίρνει χρόνο $$\mathcal{O}(N)$$ (όπως και του prefix sum). Η δυσκολία σε αυτό το prefix minimum είναι ότι θέλουμε να κάνουμε updates σε τυχαία σημεία.
Προσέξτε όμως ότι στο παραπάνω σχήμα, οι τιμές του RMQ μένουν σταθερές ή μειώνονται. Για να κάνουμε τα updates αποδοτικά και να διατηρούμε το prefix minimum ενημερωμένο, πρέπει να αξιοποιήσουμε την ιδιότητα αυτή, ότι καμία θέση $$y_j, y_j\gt y_i$$ δεν μπορεί να έχει $$\mathit{RMQ}(y_j) \gt \mathit{RMQ}(y_i)$$. 

**Παρατήρηση:** Έστω $$y_j>y_i$$ και $$\mathit{RMQ}(y_j)>\mathit{RMQ}(y_i)$$. Την τιμή $$\mathit{RMQ}(y_i)$$ την οριοθέτησε ένα ή περισσότερα καταστήματα που έχουν $$y \in [0,y_i]$$ και $$z = \mathit{RMQ}(y_i)$$. Το ίδιο κατάστημα που οριοθέτησε το $$\mathit{RMQ}(y_i)$$, υπάρχει και στο $$\mathit{RMQ}(y_j)$$ καθώς $$y_j \gt y_i$$ άρα το $$\mathit{RMQ}(y_j)$$ δεν μπορεί να είναι μεγαλύτερο από $$\mathit{RMQ}(y_i)$$, άρα άτοπη η υπόθεση μας.


Η ακολουθία των $$\mathit{RMQ}(y_i)$$ που μας ενδιαφέρουν, είναι φθίνουσα. Αν μάλιστα αγνοήσουμε τα διαδοχικά στοιχεία που έχουν ίσο $$z$$ διότι αποτελούν πλεονασμό και κρατήσουμε μόνο το νωρίτερα εμφανιζόμενο σημείο που εμφανίζεται η ίδια τιμή $$z$$, καταλήγουμε να αποθηκεύουμε μια γνησίως φθίνουσα ακολουθία από $$z$$ τιμές δηλαδή:
$$y_i \lt y_j \Leftrightarrow \mathit{RMQ}(y_i) \gt \mathit{RMQ}(y_j)$$  


Μια βολική δομή για να αποθηκεύσουμε αυτή την ακολουθία είναι ένα __std::map__ ή ένα __std::set__ και κάθε 
φορά θα εισάγουμε ένα νέο ζεύγος $$(y_i,z_i)$$ ή θα προσπαθούμε να βελτιώσουμε ένα υπάρχον ζεύγος με μικρότερο $$z_i$$. Καθώς εισάγουμε ή μεταβάλουμε ένα 
σημείο της ακολουθίας μας διορθώνουμε (διαγράφουμε) τα ασύμβατα στοιχεία που ακολουθούν το $$y_i$$ ώστε η ακολουθία μας να παραμείνει γνησίως φθίνουσα. 
Ας δούμε όλες τις περιπτώσεις που προκύπτουν από την εισαγωγή ενός σημείου $$(y_i,z_i)$$ στη δομή μας με τη βοήθεια του παρακάτω σχήματος

![Παράδειγμα](/assets/24-pdp-c3-souvlakia-1.svg){:width="350px"}  

Διακρίνουμε πέντε περιπτώσεις:  
* (μπλέ σημείο) είναι μεγαλύτερο από το προηγούμενο $$z$$, άρα αγνοείται και δεν αλλάζει η δομή μας  
* (κόκκινο σημείο) είναι ίσο με το προηγούμενο $$z$$, οπότε πάλι αγνοείται και δεν αλλάζει η δομή μας  
* (κίτρινο σημείο) είναι ανάμεσα στο προηγούμενο και στο επόμενο. Εισάγεται και δεν χαλάει την μονοτονία της ακολουθίας.  
* (πράσινο σημείο) είναι ίσο με το επόμενο $$z$$. Το επόμενο σημείο διαγράφεται εφόσον καλύπτεται από αυτό που εισάγουμε τώρα.  
* (ροζ σημείο) είναι χαμηλότερο από το επόμενο σημείο. Θα διαγραφτούν όλα τα επόμενα σημεία με $$z \ge z_i$$.  

Κάθε κατάστημα κατά το update στη δομή μας, ελέγχει τη μονοτονία της και διαγράφει $$0$$ έως $$N$$ στοιχεία για να διατηρήσει την ακολουθία γνησίως φθίνουσα. Το κάθε update έχει $$\mathcal{O}(\log {N})$$ πολυπλοκότητα. Παρόλο ότι μπορεί να διαγράψει $$N$$ στοιχεία σε ένα update, δεν καταλήγουμε σε $$\mathcal{O}(N^2\cdot \log {N})$$ πολυπλοκότητα διότι συνολικά, για όλα τα $$N$$ updates, δεν μπορούν να διαγραφούν περισσότερο από $$N$$ στοιχεία, άρα έχουμε **amortized** $$\mathcal{O}(\log {N})$$ πολυπλοκότητα ανά update. 

Η λύση αυτή είναι optimal και περνά όλα τα test cases.
Για μια ενδεικτική υλοποίηση αντικαταστήστε το τμήμα 2 με το παρακάτω:

{% include code.md solution_name='souvlakia_nlogn_map.cc' start=81 end=113 %}


[^1]: Ο αλγόριθμος Dijkstra έχει διάφορες υλοποιήσεις (διπλό loop, priority queue με updates, Fibonacci heap κλπ). Επιλέχθηκε μια λογαριθμική λύση με std::set ώστε να χρησιμοποιηθεί αυτούσια και στις υπόλοιπες λύσεις χωρίς να χειροτερεύει την πολυπλοκότητα τους.

[^2]: Αντικαταστήσαμε τη μία συνθήκη με το χρόνο στον οποίο θα επεξεργαστούμε κάθε κατάστημα και το πρόβλημα από τριών διαστάσεων έγινε δύο διαστάσεων.

[^3]: Μπορεί να γίνει και αντίστροφα, πεδίο ορισμού τα $$z$$ και το πεδίο τιμών να είναι υποσύνολο του των $$y$$.

[^4]: Οι ακμές των γράφων δεν είναι χρήσιμες μετά την εκτέλεση του Dijkstra οπότε μπορούμε να χρησιμοποιήσουμε __std::vector__ τοπικά μέσα σε compound statement ώστε όταν τελειώσει η compound statement να ελευθερωθεί η μνήμη του std::vector.  

[^5]: Ο Dijkstra μπορεί να υπερχειλίσει κάποιους τύπους ακεραίων όταν πάει να προσθέσει δυο $$\mathit{INF}$$ μεταξύ τους οπότε μια καλή λύση είναι να μην κάνουμε την πρόσθεση αν ξέρουμε ήδη ότι ο ένας ακέραιος έχει τιμή $$\mathit{INF}$$.

[^6]: Τα στοιχεία στο input είναι πάρα πολλά (ακμές γράφων και ερωτήματα) και ο χρόνος που απαιτείται για το input είναι σημαντικός. Προτιμήθηκε η λύση fast i/o με χρήση της __getchar_unlocked__ η οποία παρακάμπτει αρκετούς από τους ελέγχους που εκτελεί η __getchar__ δίνοντας μας ένα πλεονέκτημα χρόνου. Οι συναρτήσεις αυτές υπάρχουν σε πολλές υλοποιήσεις C/C++.

[^7]: Το segment tree χρειάζεται $$2^{ceil(\log_2 (D\cdot N))+1}$$ κόμβους για να αποθηκευτεί, όπου $$2^{ceil(\log_2 (D\cdot N))+1} \le 4\cdot D \cdot N$$ ενώ το binary index tree χρειάζεται $$D\cdot N$$ κόμβους.

[^9]: Οι τιμές $$x,y,z$$ στα σχήματα δεν αναφέρονται σε συγκεκριμένο test case.

[^10]: Κανένα κατάστημα $$i$$ της ομάδας, δεν μπορεί να καταστήσει κάποιο άλλο $$j$$ στην ομάδα μη επιλέξιμο, εφόσον δεν ισχύει η συνθήκη $$x_i \lt x_j$$.
