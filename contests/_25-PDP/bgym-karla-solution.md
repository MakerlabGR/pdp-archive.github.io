---
layout: solution
codename: karla
---

## Επεξήγηση εκφώνησης

Μας δίνεται ένας πίνακας $$N\times N$$ με ακέραιες τιμές και πρέπει να υπολογίσουμε πόσα συνδεδεμένα τμήματα θα μείνουν αν αφαιρέσουμε όλες τις τιμές μικρότερες ή ίσες με $$M$$.


Δύο τιμές $$A, B$$ είναι συνδεδεμένες ($$A\leftrightarrow B$$) αν:

 * H μία είναι μία από τις τέσσερις γειτονικές της άλλης.

 * Αν υπάρχει μία ακολουθία από γειτονικές τιμές $$k_1, \ldots, k_n$$ ώστε $$Α \leftrightarrow k_1 \leftrightarrow \ldots \leftrightarrow k_n \leftrightarrow B$$.

 
Αυτή η συνδεσιμότητα ορίζει έναν γράφο (δείτε την εικόνα για τον γράφο του παραδείγματος). Επομένως, πρέπει να μετρήσουμε τα συνεκτικά τμήματα του γράφου. 

<center>
<img alt="Γράφος παραδείγματος" src="/assets/25-pdp-b-karla-graph-example.svg" width="400px">
</center>

## Αναζήτηση κατά βάθος

Ξεκινάμε από μία τιμή ($$> M$$) του πίνακα και βρίσκουμε όλες με τις οποίες συνδέεται. Το κάνουμε αυτό ξεκινώντας μία αναζήτηση-κατά-βάθος (DFS) στην τιμή. Κάθε τιμή που επισκεπτόμαστε την μαρκάρουμε, ώστε να μην την ξανα-επισκεφτούμε. Όταν δεν υπάρχουν άλλες τιμές που μπορούμε να επισκεφτούμε, συνεχίζουμε με την επόμενη τιμή μεγαλύτερη από $$M$$ και αυξάνουμε τον μετρητή τμημάτων.


Αφού στο τέλος θα επισκεφτούμε κάθε τιμή μία φορά, ο αλγόριθμος τρέχει σε $$\mathcal{O}(N^2)$$ και χρειάζεται μνήμη $$\mathcal{O}(N^2)$$.


Υπάρχουν δύο κλασικοί τρόποι υλοποίησης της DFS: αναδρομικά ή γραμμικά. Ο γραμμικός τρόπος έχει το (μικρό) πλεονέκτημα ότι χρησιμοποιεί μικρότερη στοίβα κλήσεων. Παρακάτω δίνεται η αναδρομική υλοποίηση:

{% include code.md solution_name='karla_efficient_recursive.cc' %}

Η γραμμική υλοποίηση χρησιμοποιεί μία στοίβα:

{% include code.md solution_name='karla_efficient_iterative.cc' start=16 end=42 %}

Μπορούμε να απλοποίησουμε τον έλεγχο των γειτονικών κελιών κρατώντας τις τέσσερις πιθανές διευθύνσεις σε έναν πίνακα:

{% include code.md solution_name='karla_efficient_short.cc' start=16 end=27 %}

## Συνένωση τμημάτων σε ομάδες

Γνώσεις που θα χρειαστούμε: [union-find disjoint-sets](https://kallinikos.github.io/Union-Find-Disjoint-Sets)


Θα εξερευνήσουμε με τη σειρά ένα ένα όλα τα κελιά, από αριστερά προς τα δεξιά και από πάνω προς τα κάτω. Θα εντάξουμε όλα τα μη πλημμυρισμένα κελιά σε μια νέα ή σε μια υπάρχουσα ομάδα. Η λύση αυτή δεν απαιτεί αναδρομή και επεξεργάζεται κάθε κελί μια φορά.

Εργαζόμαστε ως εξής: αν το κελί που εξετάζουμε δεν είναι πλημμυρισμένο, το ενώνουμε με τα αμέσως γειτονικά του προς τα αριστερά και προς τα επάνω που δεν είναι πλημμυρισμένα. Το αριστερό και το επάνω κελί τα έχουμε επεξεργαστεί πριν φτάσουμε στο τρέχον κελί. Πολυπλοκότητα $$\mathcal{O}(N^2)$$

Στο τέλος μετράμε πόσες διαφορετικές ομάδες έχουν δημιουργηθεί με τους διαφορετικούς εκπροσώπους που καταλήξαμε. Το τελευταίο αυτό στάδιο θέλει άλλο ένα $$\mathcal{O}(N^2)$$ για την καταμέτρηση.

{% include code.md solution_name='karla_simple_disjoint.cc' %}

Ας εξαλείψουμε τον χρόνο εκτέλεσης την καταμέτρησης στην παραπάνω λύση με βελτίωση του κώδικα.
Στη μεταβλητή $$\mathit{ans}$$ θα κρατάμε τον αριθμό ομάδων που έχουμε μέχρι τώρα.
Κάθε μη πλημμυρισμένο κελί $$x,y$$ που εξερευνούμε, το εντάσσουμε σε μια νέα ομάδα με εκπρόσωπο τον εαυτό του. 

Ελέγχουμε τα αμέσως γειτονικά του προς τα αριστερά και προς τα επάνω και αν δεν είναι πλημμυρισμένα τα ενώνουμε. Αν κατά την ένωση βρήκαμε ότι οι δύο ομάδες είχαν διαφορετικό εκπρόσωπο, τότε πρέπει να μειώσουμε τον αριθμό των μη πλημμυρισμένων τμημάτων που διατηρούμε στην μεταβλητή $$\mathit{ans}$$ κατά $$1$$.

{% include code.md solution_name='karla_efficient_disjoint.cc' %}


