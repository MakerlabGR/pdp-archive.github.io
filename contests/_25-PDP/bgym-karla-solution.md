---
layout: solution
codename: karla
---

## Επεξήγηση εκφώνησης

Μας δίνεται ένας πίνακας $$N\times N$$ με ακέραιες τιμές και πρέπει να υπολογίσουμε πόσα συνδεδεμένα τμήματα θα μείνουν αν αφαιρέσουμε όλες τις τιμές μικρότερες ή ίσες με $$M$$.


Δύο τιμές $$A, B$$ είναι συνδεδεμένες ($$A\leftrightarrow B$$) αν:

 * H μία είναι μία από τις τέσσερις γειτονικές της άλλης.

 * Αν υπάρχει μία ακολουθία από γειτονικές τιμές $$k_1, \ldots, k_n$$ ώστε $$Α \leftrightarrow k_1 \leftrightarrow \ldots \leftrightarrow k_n \leftrightarrow B$$.

 
Αυτή η συνδεσιμότητα ορίζει έναν γράφο (δείτε την εικόνα για τον γράφο του παραδείγματος). Επομένως, πρέπει να μετρήσουμε τα συνεκτικά τμήματα του γράφου. 

![Γράφος παραδείγματος](/assets/25-pdp-b-karla-graph-example.svg){:width="400px"}


## Αναζήτηση κατά βάθος

Ξεκινάμε από μία τιμή ($$> M$$) του πίνακα και βρίσκουμε όλες με τις οποίες συνδέεται. Το κάνουμε αυτό ξεκινώντας μία αναζήτηση-κατά-βάθος (DFS) στην τιμή. Κάθε τιμή που επισκεπτόμαστε την μαρκάρουμε, ώστε να μην την ξανα-επισκεφτούμε. Όταν δεν υπάρχουν άλλες τιμές που μπορούμε να επισκεφτούμε, συνεχίζουμε με την επόμενη τιμή μεγαλύτερη από $$M$$ και αυξάνουμε τον μετρητή τμημάτων.


Αφού στο τέλος θα επισκεφτούμε κάθε τιμή μία φορά, ο αλγόριθμος τρέχει σε $$\mathcal{O}(N^2)$$ και χρειάζεται μνήμη $$\mathcal{O}(N^2)$$.


Υπάρχουν δύο κλασικοί τρόποι υλοποίησης της DFS: αναδρομικά ή γραμμικά. Ο γραμμικός τρόπος έχει το (μικρό) πλεονέκτημα ότι χρησιμοποιεί μικρότερη στοίβα κλήσεων. 

{% include code.md solution_name='karla_efficient_recursive.cc' %}

{% include code.md solution_name='karla_efficient_iterative.cc' %}

Μπορούμε να απλοποίησουμε τον έλεγχο των γειτονικών με το ακόλουθο τρικ:

{% include code.md solution_name='karla_efficient_short.cc' %}
