---
layout: solution
codename: triangle
---

## Brute force
Μπορούμε να δοκιμάσουμε όλα τα δυνατά μονοπάτια που ξεκινάνε από την κορυφή του τριγώνου. Αν είμαστε στο j-οστό στοιχείο της i-οστής γραμμής (για συντομία $$(i, j)$$), τότε μπορούμε είτε να πάμε στο $$(i+1, j)$$ ή στο $$(i+1, j+1)$$. 

Αφού σε κάθε βήμα υπάρχουν δύο επιλογές, θα ελέγξουμε συνολικά $$2^N$$. Αν υπολογίζουμε παράλληλα το άθροισμα, τότε γίνεται σε χρόνο $$O(2^N)$$ και χώρο $$O(N^2)$$. 

{% include code.md solution_name='triangle_brute_force.cc' %}


## Δυναμικός προγραμματισμός

Η λύση αυτή προϋποθέτει γνώσεις δυναμικού προγραμματισμού.

Έστω $$\mathit{max\_path}[i][j]$$ το μήκος του μεγαλύτερου μονοπατιού που τελειώνει στο j-οστό στοιχείο της i-οστής γραμμής. Υπάρχουν δύο δυνατοί τρόποι να φτάσαμε σε αυτό το στοιχείο στο μεγαλύτερο μονοπάτι:

 1. Να επεκτείναμε το μεγαλύτερο μονοπάτι για το στοιχείο $$(i-1, j)$$
 2. Να επεκτείναμε το μεγαλύτερο μονοπάτι για το στοιχείο $$(i-1, j-1)$$ (αν $$j>0$$)

Το μεγαλύτερο μονοπάτι στο $$(i, j)$$, δίνεται από το

$$\mathit{max\_path}[i][j] = T[i][j] + \max{\lbrace\mathit{max\_path}[i-1][j-1], \mathit{max\_path}[i-1][j] \rbrace}$$

{% include code.md solution_name='triangle_efficient.cc' %}

**Σημείωση:** Μπορούμε να δούμε αυτόν τον αλγόριθμο σαν μία παραλλαγή του προηγούμενου, όπου υπολογίζουμε κάθε κλήση της συνάρτησης `findMaxPath` μία φορά.

Αφού υπολογίζουμε κάθε στοιχείο του $$\mathit{max\_path}$$ μόνο μία φορά, ο χρόνος που χρειάζεται ο αλγόριθμος είναι $$O(N^2)$$ και η μνήμη $$O(N^2)$$. 

## Δυναμικός προγραμματισμός με memoisation

Μπορούμε να παρατηρήσουμε ότι για τον υπολογισμό της $$i$$-οστής γραμμής χρειαζόμαστε μόνο τις τιμές της γραμμής $$i-1$$. Επομένως, καθώς διαβάζουμε το input μπορούμε να κρατάμε μόνο τις τιμές των τελευταίων δύο σειρών των $$\max\_path$$ και του $$T$$. Αυτό μειώνει τη μνήμη που χρειάζεται ο αλγόριθμος σε $$2N = O(N)$$.

{% include code.md solution_name='triangle_mem_efficient.cc' %}