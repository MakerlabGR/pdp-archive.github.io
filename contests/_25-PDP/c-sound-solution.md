---
layout: solution
codename: sound
---

## Επεξήγηση εκφώνησης
Το πρόβλημα μας ζητάει να βρούμε σε πόσα διαστήματα μήκους $$M$$ η διαφορά της μέγιστης και της ελάχιστης τιμής είναι μικρότερη ή ίση του $$C$$. 

## Brute force λύση
Υπάρχουν $$N-M+1$$ διαστήματα μεγέθους $$M$$, κάθε ένα της μορφής $$[i, i+M)$$ για $$i=0, \ldots , N-M$$. Για κάθε ένα από αυτά υπολογίζουμε την μέγιστη και την ελάχιστη τιμή διατρέχοντας όλα τα στοιχεία του διαστήματος σε χρόνο $$\mathcal{O}(M)$$.

Συνεπώς ο αλγόριθμος χρειάζεται χρόνο $$\mathcal{O}(N\cdot M)$$ και μνήμη $$\mathcal{O}(N)$$. 

{% include code.md solution_name='sound_brute_force.cc' %}

## Λύση με set
Μπορούμε να επιταχύνουμε την παραπάνω λύση βρίσκοντας το ελάχιστο και το μέγιστο για τα διαστήματα $$[0, M)$$, $$[1, M+1)$$, $$\ldots$$ με τη σειρά. Ας δούμε πώς βρίσκουμε γρήγορα το ελάχιστο και με παρόμοια λογική μπορούμε να βρούμε και το μέγιστο. 

Κρατάμε ένα set $$\mathit{min\_set}$$ με στοιχεία $$(a[x], x)$$. Όταν επεξεργαζόμαστε το διάστημα $$[i, i+M)$$, το $$\mathit{min\_set}$$ μας δίνει το ελάχιστο στοιχείο, αλλά μπορεί αυτό να αντιστοιχεί σε στοιχείο $$(a[j], j)$$ με $$j < i$$ (δηλαδή εκτός διαστήματος). Κάθε τέτοιο στοιχείο που συναντάμε μπορούμε να το αφαιρέσουμε αφού δεν μπορεί να είναι το ελάχιστο για τα επόμενα διαστήματα. Αφαιρώντας στοιχεία, κάποια στιγμή θα βρούμε ένα στοιχείο που ανήκει στο διάστημα $$[i, i+M)$$. Αφού βρούμε το ελάχιστο προσθέτουμε το στοιχείο $$(a[i+M], i+M)$$ και συνεχίζουμε με το επόμενο διάστημα (αν υπάρχει). 

Κάθε στοιχείο θα προστεθεί μία φορά και θα αφαιρεθεί το πολύ μία φορά. Αφού κάθε πράξη στο set θέλει χρόνο $$\mathcal{O}(\log{N})$$, ο αλγόριθμος θέλει συνολικό χρόνο $$\mathcal{O}(N\log{N})$$ και μνήμη $$\mathcal{O}(N)$$. 

{% include code.md solution_name='sound_semi_fast.cc' %}


## Λύση με μονότονη ουρά
**Παρατήρηση:** Αν βάλουμε μία τιμή $$(a[i], i)$$ στο $$min\_set$$ τότε όλες οι $$(a[j], j)$$ με $$j<i$$ και $$a[i] \leq a[j]$$, δεν μπορούν ποτέ να είναι το ελάχιστο των επόμενων διαστημάτων. 

Με αυτή την παρατήρηση, τροποποιούμε τον παραπάνω αλγόριθμο ώστε να κρατάμε deque[^1] αντί για set. Για το ελάχιστο κρατάμε τα στοιχεία με αύξον $$i$$ και αύξον $$a[i]$$. Όταν πηγαίνουμε από το διάστημα $$[i, i+M)$$ στο $$[i+1, i+M+1)$$, αφαιρούμε από το πίσω μέρος της deque όλα τα στοιχεία που έχουν λήξει (δηλαδή πιθανώς το $$a[i]$$) και προσθέτουμε το $$a[i+M]$$. Όταν προσθέσουμε το $$a[i+M]$$ πρέπει να διατηρήσουμε την μονοτονία επομένως αφαιρούμε από μπροστά όλα τα στοιχεία που είναι μεγαλύτερα από το $$a[i]$$ (αφού από την παραπάνω παρατήρηση δεν θα είναι ποτέ ελάχιστα). Το πίσω πίσω στοιχείο είναι το ελάχιστο του διαστήματος.

Για το παράδειγμα, η deque για το ελάχιστο αλλάζει ως εξής:

| Deque &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp;  | Σχόλια | Ελάχιστο |
| ----------- | ----------- | ----------- |
| (0, 0) (1, 1)  | Αρχική κατάσταση σε αύξουσα σειρά θέσης | 0 |
| ~~(0, 0) (1, 1)~~ (2, 1) | Αφαιρούμε το (0, 0) επειδή είναι εκτός διαστήματος και το (1,1) επειδή δεν θα είναι ποτέ ελάχιστο | 1 |
| (2, 1) (3, 2)  | Απλά προσθέτουμε το καινούργιο | 1 |
| ~~(2, 1)~~ (3, 2) (4, 3)  | Αφαιρούμε το (2, 1) επειδή είναι εκτός διαστήματος | 2 |
| ~~(3, 2) (4, 3)~~ (5, 2) | Αφαιρούμε το (3, 2) επειδή είναι εκτός διαστήματος και το (4, 3) επειδή δεν θα είναι ποτέ ελάχιστο | 2 |
| ~~(5, 2)~~ (6, 2) | Αφαιρούμε το (5, 2) επειδή δεν θα είναι ποτέ ελάχιστο | 2 |


Αφού κάθε στοιχείο προστίθεται και αφαιρείται μία φορά, ο αλγόριθμος χρειάζεται συνολικά $$\mathcal{O}(N)$$ χρόνο και $$\mathcal{O}(N)$$ μνήμη.

{% include code.md solution_name='sound_efficient.cc' %}

[^1]: Δομή δεδομένων που υποστηρίζει `push_front`, `push_back`, `pop_front` και `pop_back` σε $$\mathcal{O}(1)$$ χρόνο.
