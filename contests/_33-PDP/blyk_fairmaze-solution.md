---
layout: solution
codename: fairmaze
---

## Επεξήγηση εκφώνησης

Μας δίνεται ένας κατευθυνόμενος γράφος με $$N\times M$$ κόμβους. Κάθε κόμβος έχει ακριβώς μια ακμή εξόδου, άρα έχουμε $$N\times M$$ κατευθυνόμενες ακμές. Οι ακραίοι κόμβοι ενδέχεται να έχουν διέξοδο εκτός του γράφου. Μας ζητείται να υπολογίσουμε πόσοι κόμβοι του γράφου δεν έχουν άμεση ή έμμεση (μέσω άλλων κόμβων) διέξοδο εκτός του γράφου.

Μια λύση είναι να βρούμε όλους τους ακραίους κόμβους που έχουν ακμή διέξοδο και για κάθε έναν από αυτούς να ακολουθήσουμε τις διαδρομές που οδηγούν σε αυτούς. Η λύση αυτή μπορεί να υλοποιηθεί με αναζήτηση κατά βάθος (dfs). 

Μια άλλη λύση, είναι να επεξεργαστούμε κάθε κόμβο με τη σειρά και να τον εντάξουμε σε μια ομάδα με τους κόμβους που συναντά στη διαδρομή του. Αν στο τέλος της διαδρομής έχουμε διέξοδο, τότε όλοι οι κόμβοι της ομάδας αυτής έχουν διέξοδο και δεν προσμετρώνται στην απάντηση μας. Η λύση αυτή υλοποιείται με τη δομή δεδομένων union-find.

## Εξερεύνηση ακραίων κόμβων και αναζήτηση κατά βάθος αναδρομικά

Ξεκινάμε από κάθε έναν από τους $$2\cdot N + 2\cdot M$$ ακραίους κόμβους. Προσέξτε ότι κάθε ένας από τους $$4$$ γωνιακούς κόμβους, έχει $$2$$ δυνατές διεξόδους, οπότε αυτούς τους $$4$$ κόμβους τους ελέγχουμε και με τις δύο δυνατές διεξόδους. Εφόσον ξεκινούμε ανάποδα (από την έξοδο του γράφου), θα κινούμαστε και ανάποδα (προς τις ακμές εισόδου, δηλαδή με 'D' προς τα πάνω, με 'L' προς τα δεξιά κλπ). Κάθε κόμβο που μπορέσαμε να εντάξουμε στην ομάδα μας τον μαρκάρουμε ώστε να μην ασχοληθούμε πάλι μαζί του. Ο αλγόριθμος μας έχει πολυπλοκότητα $$\mathcal{O}(N \cdot M)$$ και χρειάζεται μνήμη $$\mathcal{O}(N \cdot M)$$. 

Υπάρχουν δύο κλασικοί τρόποι υλοποίησης της DFS: αναδρομικά ή γραμμικά.
Ο αναδρομικός τρόπος ακολουθεί:

{% include code.md solution_name='fairmaze_reverse_dfs.cc' %}

Παρατηρήστε ότι αν κάποιο test case έχει σχεδιαστεί σαν ένα μονοπάτι που να περνά διαδοχικά από όλους του κόμβους, τότε θα έχουμε $$1.000.000$$ αναδρομικές κλήσεις της DFS, με ενδεχόμενη υπερχείλιση (overflow) της μνήμης σωρού κλήσεων (call stack) και πρόκληση σφάλματος κατάτμησης. 
Για τον παραπάνω λόγο, η λύση αυτή δεν περνά όλα τα test cases.
Για να αποφύγουμε το πρόβλημα αυτό, χρησιμοποιούμε μία δομή επανάληψης και μία stack (χωρίς αναδρομικές κλήσεις) δηλαδή υλοποιούμε τη γραμμική DFS:

{% include code.md solution_name='fairmaze_efficient_reverse_iter_dfs.cc' start=11 end=38 %}

Η λύση αυτή περνά όλα τα test cases.

## Εξερεύνηση κατά βάθος αναδρομικά

Κάνουμε ένα loop για κάθε κόμβο και με αναζήτηση κατά βάθος (dfs) ελέγχουμε αν βγαίνουμε εκτός λαβυρίνθου. Σημειώνουμε σε κάθε κόμβο ότι  περάσαμε στον πίνακα $$\mathit{visit}$$ και αν έχει διέξοδο στον πίνακα $$\mathit{escapes}$$ και φροντίζουμε να μην ξαναπεράσουμε από εκεί. Καταμετρούμε τους κόμβους που δεν έχουν διέξοδο. Ο αλγόριθμος μας έχει πολυπλοκότητα $$\mathcal{O}(N \cdot M)$$ και χρειάζεται μνήμη $$\mathcal{O}(N \cdot M)$$. 

{% include code.md solution_name='fairmaze_dfs.cc' start=8 end=23 %}

Η λύση αυτή δεν περνά όλα τα test cases λόγω υπερχείλισης της μνήμης του σωρού κλήσεων (call stack).

## Εξερεύνηση κατά βάθος με χρήση βρόγχου επανάληψης

Κάνουμε ένα loop για κάθε κόμβο και με αναζήτηση κατά βάθος (dfs) ελέγχουμε αν βγαίνουμε εκτός λαβυρίνθου. Παρατηρήστε ότι κάθε κόμβος έχει μόνο μια έξοδο, άρα δεν υπάρχουν διακλαδώσεις και η αναζήτηση μπορεί να γίνει με έναν απλό βρόγχο για να ακολουθήσουμε το μονοπάτι. Όταν βρούμε το τέλος του μονοπατιού ή καταλήξουμε σε κόμβο που έχουμε ξαναεπισκευτεί, ενημερώνουμε όλους τους κόμβους που προσπεράσαμε. Ο αλγόριθμος μας εξερευνεί κάθε κόμβο μια φορά και ενημερώνει μέσω του πίνακα $$\mathit{path}$$ κάθε κόμβο, μια φορά, άρα έχει πολυπλοκότητα $$\mathcal{O}(N \cdot M)$$ και χρειάζεται μνήμη $$\mathcal{O}(N\cdot M)$$. 

{% include code.md solution_name='fairmaze_efficient_loop.cc' start=8 end=49 %}

Η λύση αυτή περνά όλα τα test cases.

## Συνένωση κόμβων με χρήση της δομής union-find

Γνώσεις που θα χρειαστούμε: [union-find disjoint-sets](https://kallinikos.github.io/Union-Find-Disjoint-Sets)

Θα εξερευνήσουμε με τη σειρά έναν έναν όλους τους κόμβους, από αριστερά προς τα δεξιά και από πάνω προς τα κάτω. Θα ενώσουμε κάθε κόμβο με την ομάδα του κόμβου που βρίσκεται στη γραμμή εξόδου του. Αν ένας κόμβος έχει διέξοδο, τότε μαρκάρουμε όλη την ομάδα ότι έχει διέξοδο (συνάρτηση *dj_escapes()*).
Χρειάζεται να διατρέξουμε μία φορά τον πίνακα, άρα χρειάζονται $$\mathcal{O}(N\cdot M)$$ βήματα. Η μνήμη που χρειάζεται είναι επίσης $$\mathcal{O}(N \cdot M)$$.

Η αναζήτηση εκπροσώπου και η συνένωση ομάδων, γίνεται amortized σχεδόν σε σταθερό χρόνο[^1] και δεν αλλάζει την ασυμπτωτική πολυπλοκότητα της λύσης.

Στο τέλος αθροίζουμε στην $$\mathit{ans}$$ τα πλήθη από τις διαφορετικές ομάδες που έχουν δημιουργηθεί στη union-find και δεν έχουν διέξοδο. Το τελευταίο αυτό στάδιο θέλει άλλα $$\mathcal{O}(N\cdot M)$$ βήματα για την καταμέτρηση.

{% include code.md solution_name='fairmaze_efficient_dj.cc' %}

Μπορούμε να εξαλείψουμε το τελευταίο στάδιο της καταμέτρησης αν φροντίσουμε να διατηρούμε συνεχώς ενημερωμένη τη μεταβλητή $$\mathit{ans}$$. Για το σκοπό αυτό θέτουμε ως αρχική τιμή στην $$\mathit{ans}$$ το πλήθος όλων των κόμβων. Καθώς ανακαλύπτουμε ομάδες με διέξοδο, αφαιρούμε το πλήθος των κόμβων τους από την $$\mathit{ans}$$.

{% include code.md solution_name='fairmaze_efficient_dj2.cc' start=33 end=50 %}

και μιά μικρή παραλλαγή με μετατροπή του *switch* σε βρόγχο με χρήση πίνακα:

{% include code.md solution_name='fairmaze_efficient_dj2_short.cc' start=55 end=92 %}


[^1]: Οι λειτουργίες union και find της union-find που χρησιμοποιούν συμπύκνωση μονοπατιών, χρειάζονται χρόνο $$\mathcal{O}(\alpha(N^2))$$ ανα κλήση σε ένα δάσος $$N^2$$ κόμβων σαν αυτό της άσκησης. Με $$\alpha(n)$$ συμβολίζουμε την εξαιρετικά μικρής αύξησης ως προς το $$n$$, [αντίστροφη συνάρτηση Ackermann](https://en.wikipedia.org/wiki/Ackermann_function#Inverse). Ενδεικτικά του ρυθμού αύξησης, το $$\alpha(9876 !)=5$$. Στην πράξη, ο χρόνος στις συναρτήσεις union και find είναι σχεδόν γραμμικός λόγω του ότι το $$\alpha(n)\le 3$$ για οποιοδήποτε $$n$$ μπορεί να προκύψει στην πράξη [ανφ.R.Tarjan](http://encyclopediaofmath.org/index.php?title=Ackermann_function&oldid=49989).



