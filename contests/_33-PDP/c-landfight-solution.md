---
layout: solution
codename: landfight
---


## Πολύ αργή λύση (brute force)

Η πιο απλή λύση είναι για κάθε $$L$$, να ελέγξουμε όλα τα δυνατά $$R$$. Για να αθροίσουμε τα πρώτα $$L$$ στοιχεία $$x_1+x_2+\dots+x_L$$ θα κάνουμε ένα ακόμα for, άρα συνολοκή πολυπλοκότητα $$\mathcal{O}(N^3)$$.

{% include code.md solution_name='landfight_brute.cc' %} 


## Λύση με χρήση prefix sums (20% της βαθμολογίας)
Στην παραπάνω λύση αποφεύγουμε τα loop υπολογισμού αθροισμάτων κάνοντας προϋπολογισμό των prefix sums σε έναν πίνακα $$\mathit{PS}$$ έτσι ώστε το 

$$\mathit{PS}_i=x_1+x_2+ \dots + x_i=\sum_{j=1}^i {A_j}$$ 

Αντίστοιχα, θα χρειαστούμε και τα suffix sums για το άθροισμα των τελευταίων $$R$$ στοιχείων σε έναν πίνακα $$\mathit{SS}$$ με 

$$\mathit{SS}_i=x_i+x_{i+1}+\dots+x_N=\sum_{j=i}^N{A_j}$$ 

Χρειάζεται προσοχή στην ειδική περίπτωση που το άθροισμα όλων των στοιχείων είναι $$0$$. Στην περίπτωση αυτή το $$\mathit{PS}_N=0$$ και ο αριστερός τσιφλικάς θα πάρει όλα τα χωράφια ενώ ο δεξιός δεν θα πάρει κανένα. Η ιδιόμορφη αυτή περίπτωση είναι αποδεκτή και έχει απάντηση $$0$$. Για την περίπτωση αυτή στον πίνακα των suffix sums προσθέτουμε μια επιπλέον θέση με τιμή $$0$$ στη θέση $$\mathit{SS}_{N+1}$$.
Συνολική πολυπλοκότητα της λύσης είναι $$\mathcal{O}(N^2)$$.

{% include code.md solution_name='landfight_brute_ps.cc' %} 

Στην παραπάνω λύση, μπορεί να γίνει μια μικρή βελτίωση στο εσωτερικό loop. Όταν έχουμε υπολογίσει κάποια τιμή $$\mathit{ans}$$ έως τώρα, δεν μας ενδιαφέρει να ελέγχουμε τιμές χειρότερες από την τιμή αυτή. Το δεύτερο loop μπορεί να γραφτεί:
```
    for(long j=i+1,n2=min(N,ans+i+1);j<n2;j++)
```

## Λύση με χρήση δύο pointers (70% της βαθμολογίας)

Σύμφωνα με τους περιορισμούς της εκφώνησης, για περιπτώσεις ελέγχου συνολικής αξίας 70% έχουμε μόνο μη μηδενικές θετικές τιμές για τα $$x_i$$. Αποτέλεσμα αυτού, είναι τόσο τα prefix sums όσο και τα suffix sums να αποτελούν γνησίως αύξουσες ακολουθίες εφόσον από κάθε θέση $$i$$ για να πάμε στην επόμενη $$i+1$$ προσθέτουμε έναν μη μηδενικό θετικό αριθμό.

**Απόδειξη:** <br>
$$x_i \gt 0 \Leftrightarrow \mathit{PS}_{i-1} + x_i \gt \mathit{PS}_{i-1} \Leftrightarrow \mathit{PS}_{i} \gt \mathit{PS}_{i-1}$$<br>
$$x_i \gt 0 \Leftrightarrow \mathit{SS}_{i+1} + x_i \gt \mathit{SS}_{i+1} \Leftrightarrow \mathit{SS}_{i} \gt \mathit{SS}_{i+1}$$

Εφόσον οι δύο ακολουθίες είναι γνησίως αύξουσες, για κάθε σημείο της μιας ακολουθίας θα υπάρχει το πολύ ένα σημείο της άλλης που θα έχει ίδια τιμή.

**Απόδειξη:** <br>
Έστω ότι υπάρχουν δυο κοινά σημεία των δύο ακολουθιών στις θέσεις $$i$$ και $$j$$ με $$i<j$$ άρα $$\mathit{PS}_{i}=\mathit{SS}_{i}=\mathit{PS}_{j}=\mathit{SS}_{j}$$. Εφόσον $$i<j$$ και οι ακολουθίες είναι γνησίως αύξουσες, τότε $$\mathit{PS}_{i} \lt \mathit{PS}_{j}$$ πράγμα άτοπο.  

Παρατηρήστε το παρακάτω σχήμα που αντιστοιχεί στο πρώτο παράδειγμα της εκφώνησης:

<center>
<img alt="2pointers" src="/assets/33-pdp-c-landfight-bs1.svg" width="400px">
</center>

Οι πράσινες κουκίδες αντιστοιχούν στην ακολουθία των prefix sums και οι κόκκινες στα suffix sums. Μας ενδιαφέρει να εντοπίσουμε τιμές του κατακόρυφου άξονα (τιμές sum) που να υπάρχουν και στις δύο ακολουθίες. Τέτοιες τιμές είναι οι $$0$$,$$10$$,$$18$$ και $$28$$. Από αυτές αποδεκτές είναι μόνο η τιμή $$0$$ (με απάντηση $$7$$ αδιάθετα χωράφια) και η $$10$$ (με απάντηση $$2$$ αδιάθετα χωράφια). Οι τιμές $$18$$ και $$28$$ βρίσκονται μετά τη διασταύρωση των δυο ακολουθιών και απορρίπτονται διότι τα χωράφια του ενός τσιφλικά έχουν υπερκαλύψει χωράφια του άλλου. 

Οπότε αρκεί να χρησιμοποιήσουμε δύο δείκτες, έναν για το prefix sum και έναν για το suffix sum και να τους μετακινούμε έτσι ώστε να βρούμε όλους τους συνδυασμούς όπου το suffix sum στον ένα δείκτη είναι ίσο με το prefix sum στον άλλο δείκτη. Σταματάμε όταν οι δείκτες διασταυρωθούν. 
Η πολυπλοκότητα της λύσης είναι $$\mathcal{O}(N)$$ καθώς ελέγχει κάθε στοιχείο μια φορά. 

{% include code.md solution_name='landfight_2pointers.cc' %} 


## Λύση με δυαδική αναζήτηση στα suffix sums (100% της βαθμολογίας)

Για κάθε δυνατό πλήθος αριστερών χωραφιών θέλουμε να ελέγξουμε μόνο τα suffix sums με ίδια τιμή. Ας ταξινομήσουμε αυτά τα suffix sums, διατηρώντας τις θέσεις που αυτά εμφανίστηκαν, ώστε να μπορούμε να κάνουμε δυαδική αναζήτηση σε αυτά. Δηλαδή για κάθε πλήθος $$i$$ χωραφιών του αριστερού τσιφλικά με prefix sum $$\mathit{PS}_i$$, ψάχνουμε τις θέσεις που εμφανίζονται suffix sums με $$\mathit{SS}_j=\mathit{PS}_i$$ και $$i\lt j$$. 
Θα χρησιμοποιήσουμε έναν πίνακα με *pair* από τη βιβλιοθήκη *stl*, όπου αποδίδουμε στο πρώτο στοιχείο του την τιμή του suffix sum $$\mathit{SS}_i$$ και στο δεύτερο τη θέση $$i$$ που βρέθηκε το suffix sum αυτό. Η ταξινόμηση στα *pair* γίνεται με το πρώτο στοιχείο και σε περίπτωση ισότητας και με το δεύτερο.
Συνολική πολυπλοκότητα της λύσης είναι $$\mathcal{O}(N\cdot \log{N})$$.

{% include code.md solution_name='landfight_bsearch.cc' %} 

## Λύση με χρήση αραιού πίνακα από δομές αποθήκευσης (100% της βαθμολογίας)

Γνώσεις που θα χρειαστούμε: [unordered_map](https://kallinikos.github.io/STL), [stack](https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29)

Αντί να βάλουμε τα suffix sums σε έναν πίνακα και να τον ταξινομήσουμε, θα μπορούσαμε να τα έχουμε σε έναν δισδιάστατο πίνακα όπου η πρώτη διάσταση είναι η τιμή του suffix sum και στη δεύτερη διάσταση του θα έχουμε τις θέσεις που συναντήσαμε το suffix sum. Οι τιμές των suffix sum όμως δεν είναι συνεχείς και μπορεί να έχουν τιμές από $$-10^9$$ έως $$10^9$$ σύμφωνα με τους περιορισμούς της εκφώνησης του προβλήματος. Ο συνολικός αριθμός των διαφορετικών τιμών δεν μπορεί όμως να ξεπεράσει το $$N$$, άρα χρειαζόμαστε μια δομή να αποθηκεύσουμε έναν αραιό πίνακα από πίνακες όπως το *map* ή το *unordered_map* που περιέχονται στην *stl*.

**Παράδειγμα:** 
``` 
    unordered_map<long, vector<long>> M;
    M[0].push_back(N+1);//περίπτωση L=N,R=0
    for(long sum=0,k=N;k>0;k--){
        sum += A[k];
        M[sum].push_back(k);
    }
```
**Παρατήρηση:**
Στον κάθε πίνακα *vector*, οι θέσεις $$k$$ που αποθηκεύονται μειώνονται σε κάθε βήμα της επανάληψης καθώς υπολογίζουμε τα suffix sums από τη θέση $$N$$ προς τη θέση $$1$$. Άρα κάθε *vector* περιέχει μια γνησίως φθίνουσα ακολουθία.

Ας δούμε ένα παράδειγμα με το ακόλουθο test case:

| **landfight.in**      |
| :---  | :--- |
|   11 <br> -3 -5 5 4 -9 5 -2 -1 0 3 7 |
{:.table_with_borders.table_with_monospace_font}

Το παρακάτω διάγραμμα αναπαριστά την ακολουθία των suffix sums

<center>
<img alt="suffix sum diagram" src="/assets/33-pdp-c-landfight-bs2.svg" width="560px">
</center>

και αποθηκεύεται στο *unordered_map* (πράσινα κελιά) από *vectors* (κίτρινα κελιά) του παρακάτω σχήματος, αναπαριστώντας έναν δισδιάστατο αραιό πίνακα που απεικονίζει το επόμενο σχήμα

<center>
<img alt="dim2 sparse array" src="/assets/33-pdp-c-landfight-bs3.svg" width="340px">
</center>


Μια απλοποιημένη και μη αποδοτική αναζήτηση[^3] της απάντησης του προβλήματος, μπορεί να γίνει ως εξής:
```
    long ans = N;
    for(long prefix=0,i=1;i<=N;i++){
        prefix += A[i];
        for(long j:M[prefix]){
            if(j>i)
                ans = min(ans,j-i-1);
        }
    }
```
 Μια προφανής λύση είναι να χρησιμοποιήσουμε binary search, όμως μπορούμε να εφαρμόσουμε ακόμα καλύτερη λύση. Καθώς το $$i$$ αυξάνεται, οι τιμές του κάθε *vector* που είναι μικρότερες ή ίσες από το $$i$$ δεν θα χρησιμοποιηθούν ξανά και μπορούμε να τις αγνοήσουμε[^4] ή να τις διαγράψουμε. Στο *vector* η διαγραφή γενικά δεν είναι αποδοτική εκτός αν διαγράφουμε το (ή τα) τελευταία στοιχεία του, όπως συμβαίνει στην περίπτωση μας.
 
Μια λύση με *vector* ακολουθεί:

{% include code.md solution_name='landfight_vector.cc' %}

Αντί για *vector* μπορούμε να χρησιμοποιήσουμε και άλλες δομές που μας επιτρέπουν διαγραφή στοιχείων όπως η διπλά συνδεδεμένη λίστα[^2] ή το *stack*.

Μια λύση με *stack* ακολουθεί. 

{% include code.md solution_name='landfight_stack.cc' %}

Η συνολική πολυπλοκότητα των παραπάνω λύσεων είναι amortized $$\mathcal{O}(N)$$ καθώς για κάθε θέση $$i$$ μπορεί να διαγράψουμε έως $$N$$ θέσεις από το *vector*, *stack* ή το *list*, αλλά για όλα τα $$i$$ δεν θα διαγράψουμε περισσότερα από $$N$$ στοιχεία συνολικά. 

[^4]: [Ενδεικτική λύση με vector χωρίς διαγραφή στοιχείων](https://github.com/pdp-archive/pdp-archive.github.io/blob/master/_includes/source_code/code/33-PDP/landfight/landfight_vector_head.cc) 

[^2]: [Ενδεικτική λύση με διπλά συνδεδεμένη λίστα](https://github.com/pdp-archive/pdp-archive.github.io/blob/master/_includes/source_code/code/33-PDP/landfight/landfight_list.cc)

[^3]: Ο απλοποιημένος αυτός κώδικας δεν είναι αποδοτικός και έχει πολυπλοκότητα $$\mathcal{O}(N^2)$$ καθώς μπορεί για παράδειγμα ένα test case να έχει όλα τα $$x_i=0$$ οπότε το *vector* στη θέση $$M_0$$ θα έχει $$N$$ στοιχεία. Ένα ακόμα πρόβλημα του παραπάνω κώδικα είναι ότι δεν ελέγχει αν υπάρχει το στοιχείο $$M_{\mathit{prefix}}$$ πριν το χρησιμοποιήσει, με αποτέλεσμα τη δημιουργία κενών στοιχείων στο *unordered_map*. 

