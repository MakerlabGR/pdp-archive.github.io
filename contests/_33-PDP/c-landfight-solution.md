---
layout: solution
codename: landfight
---


## Λύση brute force (20% της βαθμολογίας)

Η πιο απλή λύση είναι για κάθε $$L$$, να ελέγξουμε όλα τα δυνατά $$R$$. Για να αθροίσουμε τα πρώτα $$L$$ στοιχεία $$x_1+x_2+\dots+x_L$$ ή θα κάνουμε ένα ακόμα for ή θα κάνουμε προϋπολογισμό των prefix sums σε έναν πίνακα $$\mathit{PS}$$ έτσι ώστε το $$\mathit{PS}_i=x_1+x_2+ \dots + x_i$$ (ή $$\mathit{PS}_i=\sum_{j=1}^i {A_j}$$). Αντίστοιχα, θα χρειαστούμε και τα suffix sums για το άθροισμα των τελευταίων $$R$$ στοιχείων σε έναν πίνακα $$\mathit{SS}$$ με $$\mathit{SS}_i=x_i+x_{i+1}+\dots+x_N$$ (ή $$\mathit{SS}_i=\sum_{j=i}^N{A_j}$$). 

Χρειάζεται προσοχή στην ειδική περίπτωση που το άθροισμα όλων των στοιχείων είναι $$0$$. Στην περίπτωση αυτή το $$\mathit{PS}_N=0$$ και ο αριστερός τσιφλικάς θα πάρει όλα τα χωράφια ενώ ο δεξιός δεν θα πάρει κανένα. Η ιδιόμορφη αυτή περίπτωση είναι αποδεκτή και έχει απάντηση $$0$$. Για την περίπτωση αυτή στον πίνακα των suffix sums προσθέτουμε μια επιπλέον θέση με τιμή $$0$$ στη θέση $$\mathit{SS}_{N+1}$$.
Συνολική πολυπλοκότητα της λύσης είναι $$\mathcal{O}(N^2)$$.

{% include code.md solution_name='landfight_simple.cc' %} 

Στην παραπάνω λύση, μπορεί να γίνει μια μικρή βελτίωση στο εσωτερικό loop. Όταν έχουμε υπολογίσει κάποια τιμή $$\mathit{ans}$$ έως τώρα, δεν μας ενδιαφέρει να ελέγχουμε τιμές χειρότερες από την τιμή αυτή. Το δεύτερο loop μπορεί να γραφτεί:
```
    for(long j=i+1,n2=min(N,ans+i+1);j<n2;j++)
```

## Λύση με χρήση δύο pointers (70% της βαθμολογίας)

Σύμφωνα με τους περιορισμούς της εκφώνησης, για περιπτώσεις ελέγχου συνολικής αξίας 70% έχουμε μόνο μη μηδενικές θετικές τιμές για τα $$x_i$$. Αποτέλεσμα αυτού, είναι τόσο τα prefix sums όσο και τα suffix sums να αποτελούν γνησίως αύξουσες ακολουθίες εφόσον από κάθε θέση $$i$$ για να πάμε στην επόμενη $$i+1$$ προσθέτουμε έναν μη μηδενικό θετικό αριθμό. 
Εφόσον οι δύο ακολουθίες είναι γνησίως αύξουσες, για κάθε σημείο της μιας ακολουθίας θα υπάρχει το πολύ ένα σημείο της άλλης που θα έχει ίδια τιμή.
Οπότε αρκεί να χρησιμοποιήσουμε δύο δείκτες, έναν για το prefix sum και έναν για το suffix sum και να τους μετακινούμε έτσι ώστε να βρούμε όλους τους συνδυασμούς όπου το suffix sum στον ένα δείκτη είναι ίδιο με το prefix sum στον άλλο δείκτη. 
Η πολυπλοκότητα της λύσης είναι $$\mathcal{O}(N)$$ καθώς ελέγχει κάθε στοιχείο μια φορά. 

{% include code.md solution_name='landfight_2pointers.cc' %} 


## Πλήρης λύση με δυαδική αναζήτηση στα suffix sums

Για κάθε δυνατό πλήθος αριστερών χωραφιών θέλουμε να ελέγξουμε μόνο τα suffix sums με ίδια τιμή. Ας ταξινομήσουμε αυτά τα suffix sums, διατηρώντας τις θέσεις που αυτά εμφανίστηκαν, ώστε να μπορούμε να κάνουμε δυαδική αναζήτηση σε αυτά. Δηλαδή για κάθε πλήθος $$i$$ χωραφιών του αριστερού τσιφλικά με prefix sum $$\mathit{PS}_i$$, ψάχνουμε τις θέσεις που εμφανίζονται suffix sums με $$\mathit{SS}_j=\mathit{PS}_i$$ και $$i\lt j$$. 
Θα χρησιμοποιήσουμε έναν πίνακα με *pair* της *C++*, όπου αποδίδουμε στο πρώτο στοιχείο του την τιμή του suffix sum $$\mathit{SS}_i$$ και στο δεύτερο τη θέση $$i$$ που βρέθηκε το suffix sum αυτό. Η ταξινόμηση στα *pair* γίνεται με το πρώτο στοιχείο και σε περίπτωση ισότητας και με το δεύτερο.
Συνολική πολυπλοκότητα της λύσης είναι $$\mathcal{O}(N\cdot \log{N})$$.

{% include code.md solution_name='landfight_bsearch.cc' %} 

## Πλήρης λύση με χρήση αραιού πίνακα από δομές αποθήκευσης
Γνώσεις που θα χρειαστούμε: [map](https://kallinikos.github.io/STL), [unordered_map](https://kallinikos.github.io/STL), [hash value](https://el.wikipedia.org/wiki/%CE%A3%CF%85%CE%BD%CE%AC%CF%81%CF%84%CE%B7%CF%83%CE%B7_%CE%BA%CE%B1%CF%84%CE%B1%CF%84%CE%B5%CE%BC%CE%B1%CF%87%CE%B9%CF%83%CE%BC%CE%BF%CF%8D), [stack](https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29)

Αντί να βάλουμε τα suffix sums σε έναν πίνακα και να τον ταξινομήσουμε, θα μπορούσαμε να τα έχουμε σε έναν δισδιάστατο πίνακα όπου η πρώτη διάσταση είναι η τιμή του suffix sum και στη δεύτερη διάσταση του θα έχουμε τις θέσεις που συναντήσαμε το suffix sum. Οι τιμές των suffix sum όμως δεν είναι συνεχείς και μπορεί να έχουν τιμές από $$-10^9$$ έως $$10^9$$ σύμφωνα με τους περιορισμούς της εκφώνησης του προβλήματος. Ο συνολικός αριθμός των διαφορετικών τιμών δεν μπορεί όμως να ξεπεράσει το $$N$$, άρα χρειαζόμαστε μια δομή να αποθηκεύσουμε έναν αραιό πίνακα από πίνακες όπως το *map* ή το *unordered_map* της *C++*.
Παράδειγμα: 
``` 
    unordered_map<long, vector<long>> M;
    M[0].push_back(N+1);//περίπτωση L=N,R=0
    for(long sum=0,k=N;k>0;k--){
        sum += A[k];
        M[sum].push_back(k);
    }
```

Καθώς υπολογίζουμε τα suffix sums από τη θέση $$N$$ προς τη θέση $$1$$ και τα τοποθετούμε στον αραιό πίνακα $$M$$, οι θέσεις $$k$$ που αποθηκεύονται στο *vector* μειώνονται συνεχώς σχηματίζοντας γνησίως φθίνουσα ακολουθία. 
Μια απλοποιημένη και μη αποδοτική αναζήτηση[^3] της απάντησης του προβλήματος, μπορεί να γίνει ως εξής:
```
    long ans = N;
    for(long prefix=0,i=1;i<=N;i++){
        prefix += A[i];
        for(long j:M[prefix]){
            if(j>i)
                ans = min(ans,j-i-1);
        }
    }
```
Ας αξιοποιήσουμε την παρατήρηση ότι στον κάθε πίνακα *vector* τα περιεχόμενα είναι αποθηκευμένα σε φθίνουσα διάταξη. Μια προφανής λύση είναι να χρησιμοποιήσουμε binary search, όμως μπορούμε να εφαρμόσουμε ακόμα καλύτερη λύση. Καθώς το $$i$$ αυξάνεται, οι τιμές του κάθε *vector* που είναι μικρότερες ή ίσες από το $$i$$ δεν θα χρησιμοποιηθούν πάλι και μπορούμε να τις αγνοήσουμε ή να τις διαγράψουμε. Στο *vector* η διαγραφή δεν είναι αποδοτική[^1].
Αντί για *vector* μπορούμε να χρησιμοποιήσουμε άλλες δομές που μας επιτρέπουν διαγραφή στοιχείων όπως η διπλά συνδεδεμένη λίστα[^2] ή το *stack*.

Μια λύση με *stack* ακολουθεί. Η συνολική πολυπλοκότητα της λύσης είναι amortized $$\mathcal{O}(N)$$ καθώς για κάθε θέση $$i$$ μπορεί να διαγράψουμε έως $$N$$ θέσεις από το *stack* αλλά για όλα τα $$i$$ δεν θα διαγράψουμε περισσότερα από $$N$$ στοιχεία από όλα τα *stack* συνολικά. 

{% include code.md solution_name='landfight_stack.cc' %}

[^1]: Θα μπορούσαμε να χρησιμοποιήσουμε το *vector* χωρίς να διαγράφουμε όμως στοιχεία από αυτό. Θα κρατούσαμε για κάθε *vector* έναν δείκτη $$\mathit{index}$$ για να ξέρουμε ποιο είναι το πρώτο χρήσιμο στοιχείο. Καθώς θα προσπερνάμε τα χωράφια από τα αριστερά προς τα δεξιά, οι δείκτες των *vector* θα αυξάνονται προσπερνώντας τα στοιχεία που δεν είναι πια χρήσιμα χωρίς όμως να τα διαγράφουμε. [ενδεικτική λύση με vector](https://github.com/pdp-archive/pdp-archive.github.io/blob/master/_includes/source_code/code/33-PDP/landfight/landfight_vector.cc)

[^2]: [Ενδεικτική λύση με διπλά συνδεδεμένη λίστα](https://github.com/pdp-archive/pdp-archive.github.io/blob/master/_includes/source_code/code/33-PDP/landfight/landfight_list.cc)

[^3]: Ο απλοποιημένος αυτός κώδικας δεν είναι αποδοτικός και έχει πολυπλοκότητα $$\mathcal{O}(N^2)$$ καθώς μπορεί για παράδειγμα ένα test case να έχει όλα τα $$x_i=0$$ οπότε το *vector* στη θέση $$M_0$$ θα έχει $$N$$ στοιχεία. Ένα ακόμα πρόβλημα του παραπάνω κώδικα είναι ότι δεν ελέγχει αν υπάρχει το στοιχείο $$M_{\mathit{prefix}}$$ πριν το χρησιμοποιήσει, με αποτέλεσμα τη δημιουργία κενών στοιχείων στο *unordered_map*. 

