---
layout: solution
codename: islands
---

## Επεξήγηση εκφώνησης
Έχουμε $$N$$ νησιά διατεταγμένα σε μια γραμμή, στα οποία μπορούμε να 
ταξιδεύουμε μόνο προς τη μια κατεύθυνση 
και συγκεκριμένα από κάθε νησί 
$$i$$ στο $$i+1$$ ($$1\le i < N$$). Αρχικά όλες οι μετακινήσεις είναι δωρεάν.

Δίνονται $$Q$$ ανακοινώσεις και ερωτήματα: 
* Όλες οι μετακινήσεις από κάθε νησί $$i$$ στο $$i+1$$ με $$a \le i < b$$ θα απαιτούν εισιτήριο.
* Όλες οι μετακινήσεις από κάθε νησί $$i$$ στο $$i+1$$ με $$a \le i < b$$ θα γίνονται δωρεάν.
* Αν ξεκινήσουμε από το νησί $$i$$ με $$b$$ εισιτήρια, μέχρι ποιο νησί θα φτάσουμε;

**Παρατήρηση 1**

Αν έχουμε δύο διαδοχικά νησιά $$a$$ και $$a+1$$ και η μετάβαση από το πρώτο στο δεύτερο απαιτεί εισιτήριο, 
το εισιτήριο αυτό περιορίζει την πρόσβαση  στο $$a+1$$ νησί και δεν επηρεάζει την πρόσβαση στο $$a$$. 
Θα δημιορυργήσουμε έναν πίνακα ακεραίων (ή boolean) με όνομα $$Z$$ και θέτουμε στη θέση $$i$$   
την τιμή $$1$$ αν χρειαζόμαστε εισιτήριο για να φτάσουμε στο νησί $$i$$ από το νησί $$i-1$$ ή $$0$$ αν η μετάβαση είναι δωρεάν. 
Στη θέση $$1$$ δεν θα χρειαστούμε ποτέ εισιτήριο, οπότε ισχύει πάντα ότι $$Z_1=0$$

Στα ερωτήματα που μας δίνονται, ξεκινώντας από το νησί $$a$$, προχωρούμε δεξιότερα στο $$a+1$$ έως ότου εξαντλήσουμε τα $$b$$ 
εισιτήρια ή όσο δεν χρειάζεται επιπλέον εισιτήριο ή μέχρι να φτάσουμε στο τελευταίο νησί.

## Λύση brute force  (10%)

Το subtask με $$N,Q\le 1000$$, μπορεί να λυθεί με τη μέθοδο της εξαντλητικής διερεύνησης brute force.
Για κάθε ανακοίνωση, θέτουμε $$0$$ ή $$1$$ σε όλες τις θέσεις 
του διαστήματος $$[a+1,b]$$ του πίνακα $$Z$$ που επηρεάζει η ανακοίνωση. 
Ο χρόνος ανά ενημέρωση διαστήματος είναι $$\mathcal{O}(N)$$ εφόσον 
το μήκος του διαστήματος είναι $$\mathcal{O}(N)$$. Στα ερωτήματα, ξεκινάμε από την αφετηρία $$a$$ που μας 
δίνεται και προχωρούμε προς το νησί $$N$$ έως να το φτάσουμε ή να εξαντλήσουμε τα $$b$$ εισιτήρια που έχουμε στη διάθεση μας.
Ο χρόνος ανα ερώτημα είναι επίσης $$\mathcal{O}(N)$$ εφόσον μπορεί να χρειαστεί να 
προσπεράσουμε ολόκληρο τον πίνακα εισιτηρίων.

Συνεπώς, ο χρόνος που απαιτείται για τα $$Q$$ ερωτήματα είναι της τάξης $$\mathcal{O}(Q \cdot N)$$.

{% include code.md solution_name='brute_10p.cc' %}


## Λύση subtask με prefix sum  (20%)

Η παρακάτω λύση αφορά το subtask συνολικής αξίας 20% όπου καμία 
ανακοίνωση δεν θα γίνεται μετά από ερώτημα. 

Το πρώτο στάδιο της λύσης φροντίζει να αξιοποιεί με αποδοτικό τρόπο τις ενημερώσεις. 
Η τεχνική που χρησιμοποιείται, αποθηκεύει μόνο την αρχή και το τέλος κάθε διαστήματος 
που επηρεάζει μια ανακοίνωση (δηλαδή τα γεγονότα έναρξης και λήξης κάθε μιας ανακοίνωσης) σε χρόνο $$\mathcal{O}(Q)$$. 
Στο τέλος όλων των ανακοινώσεων, θα προσπελάσουμε μια φορά γραμμικά τον πίνακα γεγονότων για να 
φτιάξουμε τον τελικό πίνακα εισιτηρίων $$Z$$. Κατά την προσπέλαση του πίνακα γεγονότων, θα χρειαστεί να κρατάμε 
ένα *set* με τις ενεργές ανακοινώσεις, ώστε να ξέρουμε ανα πάσα στιγμή ποιά είναι η πιό πρόσφατη. 
Η προσπέλαση του πίνακα γεγονότων θα χρειαστεί χρόνο της τάξης $$\mathcal{O}(Q \cdot \log{Q} + N)$$ καθώς θα είσαγει και θα 
διαγράψει έως $$Q$$ στοιχεία στο *set* και θα ενημερώσει $$N$$ τιμές στους πίνακες $$Z$$ και $$PS$$. 

Το δεύτερο στάδιο της λύσης αφορά την απάντηση των ερωτημάτων. Σε οποιοδήποτε διάστημα $$[a+1,b]$$ 
αθροίζοντας τα αντίστοιχα στοιχεία του $$Z$$ βρίσκουμε πόσα εισιτήρια χρειάζονται 
για να ταξιδέψουμε από το νησί $$a$$ στο $$b$$. 
Μια μέθοδος για να απαντάμε αθροίσματα διαστημάτων στον πίνακα $$Z$$, είναι να δημιουργήσουμε έναν 
πίνακα $$PS$$ με τα prefix sum του $$Z$$. Το prefix sum κάθε θέσης $$i$$ είναι το 
άθροισμα όλων των στοιχείων $$Z_1+Z_2+\ldots+Z_i$$ ή 
πιο σύντομα $$PS_i = \sum_{j=1}^i{Z_j}$$.
Ο πίνακας $$Z$$ δεν είναι απαραίτητο να κρατηθεί, καθώς μπορούμε να υπολογίζουμε κατευθείαν τα prefix sums.      
Το μειονέκτημα στο prefix sum είναι ότι δεν είναι αποδοτικό στις ενημερώσεις τιμών 
και πρέπει να επανυπολογισθεί. Στο subtask αυτό όμως, όλες οι ανακοινώσεις που 
προκαλούν ενημερώσεις τιμών στον πίνακα $$Z$$, συμβαίνουν *πριν* αρχίσουν τα ερωτήματα, 
οπότε θα υπολογίσουμε μόνο μια φορά τα prefix sum αφού σταματήσουν οι ανακοινώσεις.
  
Αν χρειάζονται $$k$$ εισιτήρια για να μεταβούμε από το νησί $$a$$ στο $$b$$ και $$m$$ εισιτήρια 
για να μεταβούμε από το $$a$$ στο $$b+1$$, ισχύει $$k\lt m$$, άρα ο πίνακας $$PS$$ έχει αύξουσα διάταξη.
Με τη χρήση δυαδικής αναζήτησης μπορούμε, έχοντας έναν αριθμό εισιτηρίων $$b$$, να βρούμε τη θέση $$i$$ 
στην οποία αυτά θα έχουν χρησιμοποιηθεί.  
Χρησιμοποιώντας την *upper_bound* η οποία χρησιμοποιεί δυαδική αναζήτηση βρίσκουμε την πρώτη θέση στον πίνακα $$PS$$ 
(άρα και το αντίστοιχο νησί) που ξεπερνά τα εισιτήρια $$b$$ που έχουμε στη διάθεση μας 
(ή την θέση $$N+1$$ αν εξαντληθεί ο πίνακας $$PS$$), 
οπότε απαντάμε με την αμέσως προηγούμενη θέση.
Κάθε ερώτημα χρειάζεται χρόνο τάξης $$\mathcal{O}(\log{N})$$ λόγω της δυαδικής 
αναζήτησης στα $$N$$ στοιχεία του πίνακα $$PS$$.

Ο απαιτούμενος χρόνος είναι της τάξης $$\mathcal{O}(Q\cdot \log{Q} + N\cdot \log{N})$$.

{% include code.md solution_name='prefxsum_20p.cc' start=13 end=47 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='prefxsum_20p.cc' %}).

## Λύση subtask με σημειακές ανακοινώσεις (30%)

Γνώσεις που θα χρειαστούμε: [*Segment Tree*](https://kallinikos.github.io/Segment-Trees) ή [*Binary Indexed Tree*](https://kallinikos.github.io/Binary-Indexed-Tree)

Στο subtask αυτό οι ανακοινώσεις αναφέρονται σε διαστήματα μεγέθους $$1$$ (από θέση $$a$$ σε $$a+1$$), δηλαδή είναι σημειακές. 
Δύο λύσεις που μπορούν να κάνουν σημειακές ενημερώσεις στα prefix sum σε αποδοτικό χρόνο, 
είναι οι δομές *segment tree* και *binary indexed tree*.
Η δομή *segment tree* αποτελείται από ένα ισοροπημένο δυαδικό δέντρο με $$N$$ φύλλα και ύψος $$\mathcal{O}(\log{N})$$. 
Κάθε κόμβος του δέντρου είναι είτε φύλλο και κρατά ένα στοιχείο του $$Z$$, είτε έχει δύο απογόνους και κρατά το άθροισμα τους. 
Κάθε ενημέρωση ενός στοιχείου του $$Z$$ (δηλαδή ενός φύλλου του *segment tree*) απαιτεί μόνο $$\log{N}$$ ενημερώσεις 
στους κόμβους που είναι πρόγονοι του φύλλου.
Στο συγκεκριμένο *segment tree* υπολογίζουμε τα αθροίσματα διαστημάτων (range sums) που θα χρησιμοποιήσουμε στη λύση του subtask. 

{% include code.md solution_name='segtree_30p_NlogN2.cc' start=9 end=29 %}

Για κάθε ερώτημα που ξεκινά από το νησί $$a$$ με $$b$$ εισιτήρια:
 * κάνουμε μια αναζήτηση πόσα εισιτήρια χρειάζονται για να πάμε από το νησί $$1$$ στο $$a$$ και τα προσθέτουμε στο $$b$$. 
 Με τον τρόπο αυτό μετασχηματίζουμε το ερώτημα που μας δίνεται και αντί για αφετηρία το νησί $$a$$, έχουμε το νησί $$1$$ 
 (οπότε συνεχίζουμε όπως με το subtask με prefix sum).
 * Κάνουμε δυαδική αναζήτηση στις θέσεις των νησιών μέχρι να βρούμε σε ποιό νησί έχουμε ξοδέψει $$b$$ εισιτήρια. 

Κάθε ερώτημα του προβλήματος θα κάνει λόγω της δυαδικής αναζήτησης $$\log{N}$$ αναζητήσεις στο *segment tree*, κάθε
μια από τις οποίες χρειάζεται χρόνο $$\mathcal{O}(\log{N})$$, άρα η συνολική πολυπλοκότητα της λύσης 
αυτής είναι $$\mathcal{O}(Q\cdot \log^2{N})$$. 

{% include code.md solution_name='segtree_30p_NlogN2.cc' start=46 end=57 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='segtree_30p_NlogN2.cc' %}).

## Βελτιωμένη λύση subtask με σημειακές ανακοινώσεις (30%)

Στο παραπάνω *segment tree*, κάθε διάστημα $$[1,i]$$ δίνεί το prefix sum της θέσης $$i$$. Τα prefix sums έχουν αύξουσα 
διάταξη άρα στο segment tree όταν βρισκόμαστε σε οποιοδήποτε κόμβο $$si$$ έχοντας $$b$$ εισιτήρια, αποφασίζουμε αν θα πάμε στο αριστερό 
τμήμα του δηλαδή στον κόμβο $$si\cdot 2+1$$ (αν δεν μας φτάνουν τα εισιτήρια για να τον προσπεράσουμε) ή στο δεξί κόμβο $$si\cdot 2+2$$ 
(αν έχουμε αρκετά εισιτήρια για να προσπεράσουμε το αριστερό τμήμα του) οπότε ενσωματώνουμε τη δυαδική αναζήτηση στη δομή του. 

Πιο αναλυτικά: αν $$b<st[si\cdot 2+1]$$ θα συνεχίσουμε στον αριστερό απόγονο (καθώς τα εισιτήρια μας δεν μας επιτρέπουν να τον προσπεράσουμε), 
ενώ αν $$b>st[si\cdot 2+2]$$ θα συνεχίσουμε στον δεξιό απόγονο (στην περίπτωση αυτή μειώνονται τα $$b$$ εισιτήρια μας σε $$b-st[si\cdot 2+1]$$ 
καθώς προσπεράσαμε τα νησιά του αριστερού απογόνου). Η περίπτωση $$b=st[si\cdot 2+1]$$ χρειάζεται ιδιαίτερη προσοχή καθώς εξαντλήσαμε όλα μας 
τα εισιτήρια στο διάστημα που καλύπτει ο αριστερός κόμβος αλλά θέλουμε να συνεχίσουμε και στον δεξιό για τα εντοπίσουμε τα αριστερότατα 
συνεχόμενα νησιά του, που δεν χρειάζονται εισιτήριο. Υπάρχει όμως η περίπτωση να μη βρεθεί κανένα νησί στο αριστερό άκρο 
του δεξιού κόμβου χωρίς εισιτήριο. Στην περίπτωση αυτή, θα πρέπει να επιστρέψουμε *μια* θέση προς τα αριστερά 
(ώστε να ξαναγυρίσουμε στο δεξιότατο άκρο του αριστερού κόμβου).
 
{% include code.md solution_name='segtree_30p_NlogN.cc' start=34 end=36 %}
    
Συνολική πολυπλοκότητα  $$\mathcal{O}(Q\cdot \log{N})$$.

{% include code.md solution_name='segtree_30p_NlogN.cc' start=18 end=37 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='segtree_30p_NlogN.cc' %}).

## Λύση με lazy propagation σε segment tree (76%)

Το μειονέκτημα του παραπάνω *segment tree* είναι ότι ενημερώνει μόνο ένα δρομολόγιο σε χρόνο $$\mathcal{O}(\log{N})$$, κάνει δηλαδή σημειακά updates. 
Αν έχουμε να ενημερώσουμε ένα διάστημα $$[a,b]$$ με έως $$N$$ δρομολόγια, θα ξοδέψουμε χρόνο της τάξης $$\mathcal{O}(N\cdot \log{N})$$. 
Τη λύση σε αυτό τη δίνει μια τροποποίηση στο *segment tree* που λέγεται *lazy propagation*. 
Σε κάθε ανακοίνωση δεν ενημερώνουμε απευθείας όλα τα επηρεαζόμενα 
φύλλα, αλλά αφήνουμε τις ενημερώσεις όσο πιο ψηλά στο δέντρο μπορούμε 
και "τεμπελιάζουμε". Όταν θα χρειαστεί σε επόμενη ανακοίνωση ή 
ερώτηση να προσπελάσουμε κάποιον κόμβο που έχει τιμή που "τεμπελιάζει", 
σπρώχνουμε πιο χαμηλά την "τεμπέλικη" τιμή 
πριν προσπεράσουμε τον κόμβο αυτό. 

{% include code.md solution_name='lazy_NlogN2.cc' start=10 end=49 %}

Ο παρακάτω κώδικας χρησιμοποιεί δυαδική αναζήτηση για να βρεί πως θα ξοδέψει $$b$$ εισιτήρια.
Ο χρόνος που απαιτείται είναι της τάξης $$\mathcal{O}(Q\cdot \log^2{N})$$.

{% include code.md solution_name='lazy_NlogN2.cc' start=65 end=76 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='lazy_NlogN2.cc' %}).

## Πλήρης λύση με lazy propagation (100%)

Όπως και στη λύση των σημειακών ενημερώσεων χωρίς δυαδική αναζήτηση, έτσι και εδώ έχουμε να λύσουμε το πρόβλημα 
πως θα προχωρήσουμε στο δεξιό κόμβο (για να ανακαλύψουμε τα αριστερότατα $$0$$) αν έχουμε εξαντλήσει τα εισιτήρια μας 
στον αριστερό κόμβο. Εκτός από τη λύση που δόθηκε παραπάνω, θα μπορούμε να κάνουμε το εξής: υποθέτουμε ότι τα νησιά μας είναι 
$$N+1$$ και όταν έχουμε ερώτημα για $$b$$ εισιτήρια, ψάχνουμε για $$b+1$$ (ένα παραπάνω) στο segment tree, οπότε ότι απάντηση 
και να βρούμε, *αφαιρούμε* ένα νησί. Βέβαια χρειάζεται το segment tree να καλύπτει $$N+1$$ νησιά ώστε όταν τα εισιτήρια μας υπερκαλύπτουν 
μετακίνηση σε όλα τα νησιά, το νησί που αφαιρέσαμε να συνεχίσει να μας δίνει τη σωστή απάντηση $$N$$.
   
Ο επόμενος κώδικας εκτελεί δυαδική αναζήτηση απευθείας στο segment tree βελτιώνοντας την χρονική 
πολυπλοκότητα της προηγούμενης λύσης σε $$\mathcal{O}(Q\cdot \log{N})$$. 

{% include code.md solution_name='lazy_NlogN.cc' start=51 end=65 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='lazy_NlogN.cc' %}).

## Λύση με sqrt decomposition (buckets) (45%) 

Γνώσεις που θα χρειαστούμε: [*SQRT Decomposition*](https://cp-algorithms.com/data_structures/sqrt_decomposition.html)

Ο κώδικας του sqrt decomposition είναι πιο απλός στη σχεδίαση αλλά όχι τόσο αποδοτικός όσο το *segment tree*. Χωρίζει τον πίνακα 
$$Z$$ σε $$\sqrt{N}$$ διαστήματα (buckets) μεγέθους $$\sqrt{N}$$ (εκτός ίσως από το τελευταίο διάστημα που θα είναι μικρότερο).
Κάθε ερώτημα θα περιλαμβάνει από $$1$$ έως $$\sqrt{N}$$ συνεχόμενα buckets. Από τα buckets που αφορούν τo ερώτημα, 
το αριστερό και το δεξιό ενδέχεται να μην περιλαμβάνονται πλήρως στο ερώτημα, ενώ όλα τα ενδιάμεσα περιλαμβάνονται ολόκληρα.
Στα buckets που δεν περιλαμβάνονται πλήρως, κάνουμε brute force στα $$\sqrt{N}$$ στοιχεία τους, ενώ στα υπόλοιπα buckets, 
εκτελούμε σε χρόνο $$\mathcal{O}(1)$$ την ενημέρωση/ερώτηση που θέλουμε. 

Για να πετύχουμε τις ενημερώσεις/ερωτήσεις ενός bucket σε $$\mathcal{O}(1)$$, κρατάμε μια "τεμπέλικη" (lazy) τιμή 
για το bucket στον πίνακα $$L$$ και το άθροισμα του bucket στον πίνακα $$S$$. 
Αν $$L_i=-1$$ το bucket $$i$$ δεν έχει lazy τιμή. Για να υπολογίσουμε το άθροισμα των στοιχείων του κάνουμε *brute force*. 
Αν $$L_i=1$$ όλα τα στοιχεία του bucket θεωρείται ότι έχουν τιμή $$1$$ (αλλά δεν ξοδεύουμε χρόνο για να τα κάνουμε $$1$$) 
οπότε το $$S_i$$ υπολογίζεται αμέσως καθώς ισούτε με τον αριθμό στοιχείων του bucket. 
Αν $$L_i=0$$ τότε όλα τα στοιχεία του bucket θεωρείται ότι έχουν τιμή $$0$$ 
και το άθροισμα των στοιχείων του bucket είναι $$S_i=0$$. 

{:.center_image}
![απεικόνιση των buckets στο παράδειγμα της εκφώνησης](/assets/35-c-islands-sqrt-decomp1.svg){:width="60%"}

Στα μωβ κουτάκια, απεικονίζονται οι θέσεις του πίνακα Ζ. Στα σκούρα μωβ κουτάκια υπερισχύουν 
οι τιμές του L (lazy values) του κάθε bucket και αγνοούνται οι τιμές του Ζ. 
Το άθροισμα S (sum) των στοιχείων του Z για κάθε bucket, είναι πάντα έγκυρο.
Με κόκκινο επισημαίνεται το τμήμα που επηρεάζει η πρώτη ανακοίνωση και με πράσινο η δεύτερη.

{% include code.md solution_name='sqrtdecomp_NsqrtNlogN.cc' start=13 end=50 %}

Μπορούμε να απαντάμε τα ερωτήματα του προβλήματος με τη λύση της δυαδικής αναζήτησης για να βρούμε τη μεγαλύτερη τιμή (νησί) που 
μπορούμε να φτάσουμε με $$b$$ εισιτήρια. Ο απαιτούμενος χρόνος είναι της τάξης  $$\mathcal{O}(Q\cdot \sqrt{N} \cdot \log{N})$$.

{% include code.md solution_name='sqrtdecomp_NsqrtNlogN.cc' start=84 end=96 %}

Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='sqrtdecomp_NsqrtNlogN.cc' %}).

## Πλήρης λύση με sqrt decomposition (buckets) (100%) 

Με μια τροποποίηση του κώδικα του sqrt decomposition μπορούμε να καταργήσουμε τη δυαδική αναζήτηση και να γλυτώσουμε από το 
λογαριθμικό παράγοντα στην τάξη χρόνου καταλήγοντας σε $$\mathcal{O}(Q\cdot \sqrt{N})$$.

{% include code.md solution_name='sqrtdecomp_NsqrtN.cc' start=71 end=96 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='sqrtdecomp_NsqrtN.cc' %}).

