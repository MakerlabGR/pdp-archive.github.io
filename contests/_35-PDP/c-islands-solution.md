---
layout: solution
codename: islands
---

## Επεξήγηση εκφώνησης
Έχουμε $$N$$ νησιά διατεταγμένα σε μια γραμμή, στα οποία μπορούμε να 
ταξιδεύουμε μόνο προς τη μια κατεύθυνση 
και συγκεκριμένα από κάθε νησί 
$$i$$ στο $$i+1$$ ($$1\le i < N$$). Αρχικά όλες οι μετακινήσεις είναι δωρεάν.

Δίνονται $$Q$$ ανακοινώσεις και ερωτήματα: 
* Όλες οι μετακινήσεις από κάθε νησί $$i$$ στο $$i+1$$ με $$a \le i < b$$ θα απαιτούν εισιτήριο.
* Όλες οι μετακινήσεις από κάθε νησί $$i$$ στο $$i+1$$ με $$a \le i < b$$ θα γίνονται δωρεάν.
* Αν ξεκινήσουμε από το νησί $$i$$ με $$b$$ εισιτήρια, σε ποιο νησί θα φτάσουμε;

**Παρατήρηση**

Αν έχουμε δύο διαδοχικά νησιά $$a$$ και $$a+1$$ και η μετάβαση από το πρώτο στο δεύτερο απαιτεί εισιτήριο, τότε μπορούμε να 
αποθηκεύσουμε την τιμή $$1$$ στη θέση $$a+1$$ εφόσον το εισιτήριο το χρειαζόμαστε για να φτάσουμε στο $$a+1$$ νησί και όχι για 
να φτάσουμε στο $$a$$.  Με τον τρόπο αυτό
στα ερωτήματα που μας δίνονται, ξεκινώντας από το νησί $$i$$, προχωρούμε δεξιότερα στο $$i+1$$ έως ότου εξαντλήσουμε τα $$b$$ 
εισιτήρια ή όσο δεν χρειάζεται επιπλέον εισιτήριο.

## Λύση brute force  (10%)

Φτιάχνουμε έναν πίνακα $$Z$$ με $$N+1$$ θέσεις, έτσι ώστε η θέση 
$$Z_i$$ (με $$1<i\le N$$) να έχει τιμή $$0$$ αν η 
μετακίνηση από το νησί $$i-1$$ στο $$i$$ 
είναι δωρεάν ή $$1$$ αν χρειάζεται εισιτήριο. 
Η θέση $$A_1$$ έχει πάντα τιμή $$0$$.

Για κάθε ανακοίνωση, αποθηκεύουμε $$0$$ ή $$1$$ σε όλες τις θέσεις 
του διαστήματος $$[a+1,b]$$ που επηρεάζει η ανακοίνωση. 
Ο χρόνος ανά ενημέρωση διαστήματος είναι $$\mathcal{O}(N)$$ εφόσον 
μπορεί να χρειαστούν έως $$N$$ ενημερώσεις 
τιμών στον πίνακα εισιτηρίων. Στα ερωτήματα, ξεκινάμε από την αφετηρία που μας 
δίνεται και προχωρούμε όοο μπορούμε έως ότου εξαντλήσουμε τα εισιτήρια μας.
Ο χρόνος ανα ερώτημα είναι επίσης $$\mathcal{O}(N)$$ εφόσον μπορεί να χρειαστεί να 
προσπεράσουμε ολόκληρο τον πίνακα εισιτηρίων.

Ο χρόνος που απαιτείται είναι της τάξης $$\mathcal{O}(Q \cdot N)$$.

{% include code.md solution_name='brute_10p.cc' %}


## Λύση subtask με prefix sum  (20%)

Σε οποιοδήποτε διάστημα $$[a,b]$$ μπορούμε να βρούμε πόσα εισιτήρια χρειάζονται, 
αν αθροίσουμε τα αντίστοιχα στοιχεία του $$Z$$.
Όταν έχει σταθεροποιηθεί ο πίνακας $$Z$$, μπορούμε να απαντάμε σε ερωτήματα αποδοτικά αν 
φτιάξουμε έναν πίνακα με όνομα $$PS$$ ο οποίος θα είναι τα prefix sum του πίνακα $$Z$$. 
Εφόσον οι τιμές του $$Z$$ είναι μη αρνητικές ($$0$$ ή $$1$$), ο πίνακας $$PS$$ 
έχει αύξουσα διάταξη και μπορoύμε να κάνουμε δυαδική αναζήτηση πάνω του. 
Χρησιμοποιώντας την *upper_bound* η οποία χρησιμοποιεί δυαδική αναζήτηση για να βρει την πρώτη θέση (νησί) 
που ξεπερνά τα εισιτήρια $$b$$ που έχουμε (ή την θέση $$N+1$$ αν εξαντληθεί ο πίνακας $$PS$$), 
οπότε απαντάμε με την προηγούμενη θέση.
Κάθε ερώτημα χρειάζεται χρόνο τάξης $$\mathcal{O}(log{N})$$ λόγω της δυαδικής 
αναζήτησης στα $$N$$ στοιχεία του πίνακα $$PS$$.

Το μειονέκτημα στο prefix sum είναι ότι δεν είναι αποδοτικό στις ενημερώσεις τιμών 
και πρέπει να επανυπολογισθεί. Στο subtask αυτό όμως, όλες οι ανακοινώσεις που 
προκαλούν ενημερώσεις τιμών στον πίνακα $$Z$$, συμβαίνουν *πριν* αρχίσουν τα ερωτήματα, 
οπότε θα υπολογίσουμε μόνο μια φορά τα prefix sum αφού σταματήσουν οι ανακοινώσεις.
  
Η τεχνική που θα χρησιμοποιήσουμε για να ενώσουμε όλες τις ανακοινώσεις, 
αποθηκεύει μόνο την αρχή και το τέλος κάθε διαστήματος 
που επηρεάζει μια ανακοίνωση (δηλαδή τα συμβάντα έναρξης και λήξης κάθε μιας ανακοίνωσης) 
σε χρόνο $$\mathcal{O}(Q)$$. 
Στο τέλος των ανακοινώσεων, θα προσπελάσουμε μια φορά γραμμικά τον πίνακα συμβάντων για να 
φτιάξουμε τον τελικό πίνακα εισιτηρίων $$Z$$ και 
τον πίνακα $$PS$$ που θα χρησιμοποιήσουμε για να απαντήσουμε 
όλα τα ερωτήματα.
Κατά την προσπέλαση του πίνακα συμβάντων, θα χρειαστεί να κρατάμε 
ένα *set* με τις ενεργές ανακοινώσεις, 
ώστε να ξέρουμε ανα πάσα στιγμή ποιά είναι η πιό πρόσφατη. 
Η προσπέλαση του πίνακα συμβάντων θα χρειαστεί χρόνο 
της τάξης $$\mathcal{O}(Q \cdot log{Q} + N)$$ καθώς θα είσαγει και θα 
διαγράψει έως $$Q$$ στοιχεία στο *set* και 
θα ενημερώσει $$N$$ τιμές στους πίνακες $$Z$$ και $$PS$$. 

Ο πίνακας $$Z$$ δεν είναι απαραίτητο να κρατηθεί, 
καθώς μπορούμε να υπολογίζουμε κατευθείαν τα prefix sums.      

Ο απαιτούμενος χρόνος είναι της τάξης $$\mathcal{O}(Q\cdot log{Q} + N\cdot log{N})$$.

{% include code.md solution_name='prefxsum_20p.cc' start=13 end=47 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='prefxsum_20p.cc' %})

## Λύση subtask με σημειακές ανακοινώσεις (30%)

Γνώσεις που θα χρειαστούμε: [Segment Tree](https://kallinikos.github.io/Segment-Trees) ή [Binary Indexed Tree](https://kallinikos.github.io/Binary-Indexed-Tree)

Στο subtask αυτό οι ανακοινώσεις αναφέρονται σε διαστήματα πλάτους $$1$$ (από θέση $$a$$ σε $$a+1$$). 
Δύο λύσεις που μπορούν να κάνουν ενημερώσεις στα prefix sum με σημειακές ενημερώσεις σε αποδοτικό χρόνο, 
είναι οι δομές *segment tree* και *binary indexed tree*.
Η δομή *segment tree* αποτελείται από ένα ισοροπημένο δυαδικό δέντρο με $$N$$ φύλλα και ύψος $$\lceil log{N} \rceil $$. 
Κάθε ένας κόμβος του δέντρου αποτελεί φύλλο (οπότε αναφέρεται μόνο σε ένα στοιχείο του $$Z$$) ή περιέχει το άθροισμα των δύο απογόνων του. 
Κάθε αλλαγή ενός στοιχείου του $$Z$$ (δηλαδή ενός φύλλου του *segment tree*) απαιτεί μόνο $$log{N}$$ αλλαγές στους πρόγονους κόμβους του φύλλου.
Στο συγκεκριμένο *segment tree* υπολογίζουμε τα αθροίσματα διαστημάτων (range sums) που θα χρησιμοποιήσουμε στη λύση του subtask, 

{% include code.md solution_name='segtree_30p_NlogN2.cc' start=9 end=29 %}

Για κάθε ερώτημα που ξεκινά από το νησί $$a$$ με $$b$$ εισιτήρια, κάνουμε μια αναζήτηση πόσα εισιτήρια χρειάζονται για να πάμε από 
το νησί $$1$$ στο $$a$$ και τα προσθέτουμε στο $$b$$. Με τον τρόπο αυτό μετασχηματίζουμε το ερώτημα που μας δίνεται 
και αντί για αφετηρία το νησί $$a$$, έχουμε το νησί $$1$$. Κάνουμε δυαδική αναζήτηση στα νησιά μέχρι να βρούμε σε ποιό νησί 
έχουμε ξοδέψει $$b$$ εισιτήρια. Κάθε ερώτημα του προβλήματος θα κάνει λόγω του binary search $$log{N}$$ αναζητήσεις στο *segment tree*, κάθε
μια από τις οποίες χρειάζεται χρόνο $$\mathcal{O}(log{N})$$, άρα η συνολική πολυπλοκότητα της λύσης αυτής είναι $$\mathcal{O}(Q\cdot log^2{N})$$. 

{% include code.md solution_name='segtree_30p_NlogN2.cc' start=46 end=57 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='segtree_30p_NlogN2.cc' %})

## Βελτιωμένη Λύση subtask με σημειακές ανακοινώσεις (30%)

Η προηγούμενη λύση έκανε δυαδική αναζήτηση για να βρει πότε θα ξοδευτούν $$b$$ εισιτήρια. Το *segment tree* όμως είναι ένα ισορροπημένο δυαδικό 
δέντρο αναζήτησης (BST) άρα εμπεριέχει τη δυαδική αναζήτηση στη δομή του. Όταν βρισκόμαστε σε έναν κόμβο $$si$$ που χρειάζεται $$st[si]$$ εισιτήρια, 
τότε οι δυο του απόγονοι $$si*2+1$$ και $$si*2+2$$ μοιράζονται αυτά τα εισιτήρια. 
Αν $$b<st[si*2+1]$$ θα συνεχίσουμε στον αριστερό απόγονο (καθώς τα εισιτήρια μας δεν μας επιτρέπουν να τον προσπεράσουμε) 
ενώ αν $$b>st[si*2+2]$$ θα συνεχίσουμε στον δεξιό απόγονο (στην περίπτωση αυτή έχουν μειωθεί τα $$b$$ εισιτήρια μας σε $$b-st[si*2+1]$$ 
καθώς προσπεράσαμε τα νησιά του αριστερού απογόνου). Η περίπτωση $$b=st[si*2+1]$$ χρειάζεται προσοχή καθώς εξαντλήσαμε όλα μας 
τα εισιτήρια στο διάστημα που καλύπτει ο αριστερός κόμβος αλλά θέλουμε να συνεχίσουμε και στον δεξιό για τα εντοπίσουμε τα αριστερότατα 
συνεχόμενα νησιά του που δεν χρειάζονται εισιτήριο. Υπάρχει όμως η περίπτωση να μη βρεθεί κανένα νησί στο αριστερό άκρο 
του δεξιού κόμβου χωρίς εισιτήριο. Στην περίπτωση αυτή, θα πρέπει να επιστρέψουμε μια θέση προς τα αριστερά.
 
{% include code.md solution_name='segtree_30p_NlogN.cc' start=34 end=36 %}
    
Συνολική πολυπλοκότητα  $$\mathcal{O}(Q\cdot log{N})$$.

{% include code.md solution_name='segtree_30p_NlogN.cc' start=18 end=37 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='segtree_30p_NlogN.cc' %})

## Λύση με lazy propagation σε segment tree (76%)

Το μειονέκτημα του παραπάνω *segment tree* είναι ότι ενημερώνει μόνο ένα δρομολόγιο σε χρόνο $$\mathcal{O}(log{N})$$, κάνει δηλαδή σημειακά updates. 
Αν έχουμε να ενημερώσουμε ένα διάστημα $$[a,b]$$ με έως $$N$$ δρομολόγια, θα ξοδέψουμε χρόνο της τάξης $$\mathcal{O}(N\cdot log{N})$$. 
Τη λύση σε αυτό τη δίνει μια τροποποίηση στο *segment tree* που λέγεται *lazy propagation*. 
Σε κάθε ανακοίνωση δεν ενημερώνουμε απευθείας όλα τα επηρεαζόμενα 
φύλλα, αλλά αφήνουμε τις ενημερώσεις όσο πιο ψηλά στο δέντρο μπορούμε 
και "τεμπελιάζουμε". Όταν θα χρειαστεί σε επόμενη ανακοίνωση ή 
ερώτηση να προσπελάσουμε κάποιον κόμβο που έχει τιμή που "τεμπελιάζει", 
σπρώχνουμε πιο χαμηλά την "τεμπέλικη" τιμή 
πριν προσπεράσουμε τον κόμβο αυτό. 

{% include code.md solution_name='lazy_NlogN2.cc' start=10 end=49 %}

Ο παρακάτω κώδικας χρησιμοποιεί δυαδική αναζήτηση για να βρεί πως θα ξοδέψει $$b$$ εισιτήρια.
Ο χρόνος που απαιτείται είναι της τάξης $$\mathcal{O}(Q\cdot log^2{N})$$.

{% include code.md solution_name='lazy_NlogN2.cc' start=65 end=76 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='lazy_NlogN2.cc' %})

## Πλήρης λύση με lazy propagation (100%)

Όπως και στη λύση των σημειακών ενημερώσεων χωρίς δυαδική αναζήτηση, έτσι και εδώ έχουμε να λύσουμε το πρόβλημα 
πως θα προχωρήσουμε στο δεξιό κόμβο (για να ανακαλύψουμε τα αριστερότατα $$0$$) αν έχουμε εξαντλήσει τα εισιτήρια μας 
στον αριστερό κόμβο. Εκτός από τη λύση που δόθηκε παραπάνω, θα μπορούμε να κάνουμε το εξής: υποθέτουμε ότι τα νησιά μας είναι 
$$N+1$$ και όταν έχουμε ερώτημα για $$b$$ εισιτήρια, ψάχνουμε για $$b+1$$ (ένα παραπάνω)στο segment tree, οπότε ότι απάντηση 
και να βρούμε, *αφαιρούμε* ένα νησί. Βέβαια χρειάζεται το segment tree να καλύπτει $$N+1$$ νησιά ώστε όταν τα εισιτήρια μας υπερκαλύπτουν 
μετακίνηση σε όλα τα νησιά, το νησί που αφαιρέσαμε να συνεχίσει να μας δίνει τη σωστή απάντηση $$N$$.
   
Ο επόμενος κώδικας εκτελεί δυαδική αναζήτηση απευθείας στο segment tree βελτιώνοντας την χρονική 
πολυπλοκότητα της προηγούμενης λύσης σε $$\mathcal{O}(Q\cdot log{N})$$. 

{% include code.md solution_name='lazy_NlogN.cc' start=51 end=65 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='lazy_NlogN.cc' %})

## Λύση με sqrt decomposition (buckets) (45%) 

Γνώσεις που θα χρειαστούμε: [SQRT Decomposition](https://cp-algorithms.com/data_structures/sqrt_decomposition.html)

Ο κώδικας του sqrt decomposition είναι πιο απλός στη σχεδίαση αλλά όχι τόσο αποδοτικός όσο το *segment tree*. Χωρίζει τον πίνακα 
$$Z$$ σε $$\sqrt{N}$$ διαστήματα (buckets) μεγέθους $$\sqrt{N}$$ (εκτός ίσως από το τελευταίο διάστημα που θα είναι μικρότερο).
Κάθε ερώτημα θα περιλαμβάνει από $$1$$ έως $$\sqrt{N}$$ συνεχόμενα buckets. Από τα buckets που αφορούν τo ερώτημα, 
το αριστερό και το δεξιό ενδέχεται να μην περιλαμβάνονται πλήρως στο ερώτημα, ενώ όλα τα ενδιάμεσα περιλαμβάνονται ολόκληρα.
Στα buckets που δεν περιλαμβάνονται πλήρως, κάνουμε brute force στα $$\sqrt{N}$$ στοιχεία τους, ενώ στα υπόλοιπα buckets, 
εκτελούμε σε χρόνο $$\mathcal{O}(1)$$ την ενημέρωση/ερώτηση που θέλουμε. Για να πετύχουμε τις ενημερώσεις/ερωτήσεις σε $$\mathcal{O}(1)$$ 
ενός bucket, κρατάμε μια "τεμπέλικη" (lazy) τιμή για το bucket στον πίνακα $$L$$ και το άθροισμα του bucket στον πίνακα $$S$$. 
Αν $$L_i=-1$$ το bucket $$i$$ δεν έχει lazy τιμή. Για να υπολογίσουμε το άθροισμα των στοιχείων του κάνουμε *brute force*. 
Αν $$L_i=1$$ όλα τα στοιχεία του bucket θεωρείται ότι έχουν τιμή $$1$$ (αλλά δεν ξοδεύουμε χρόνο για να τα κάνουμε $$1$$) 
οπότε το $$S_i$$ υπολογίζεται αμέσως καθώς ισούτε με τον αριθμό στοιχείων του bucket. 
Αν $$L_i=0$$ τότε όλα τα στοιχεία του bucket θεωρείται ότι έχουν τιμή $$0$$ 
και το άθροισμα των στοιχείων του bucket είναι $$S_i=0$$. 
 
{% include code.md solution_name='sqrtdecomp_NsqrtNlogN.cc' start=13 end=50 %}

Μπορούμε να απαντάμε τα ερωτήματα του προβλήματος με τη λύση της δυαδικής αναζήτησης για να βρούμε τη μεγαλύτερη τιμή (νησί) που 
μπορούμε να φτάσουμε με $$b$$ εισιτήρια. Ο απαιτούμενος χρόνος είναι της τάξης  $$\mathcal{O}(Q\cdot \sqrt{N} \cdot log{N})$$.

{% include code.md solution_name='sqrtdecomp_NsqrtNlogN.cc' start=103 end=114 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='sqrtdecomp_NsqrtNlogN.cc' %})

## Πλήρης λύση με sqrt decomposition (buckets) (100%) 

Με μια τροποποίηση του κώδικα του sqrt decomposition μπορούμε να καταργήσουμε τη δυαδική αναζήτηση και να γλυτώσουμε από το 
λογαριθμικό παράγοντα στην τάξη χρόνου καταλήγοντας σε $$\mathcal{O}(Q\cdot \sqrt{N})$$.

{% include code.md solution_name='sqrtdecomp_NsqrtN.cc' start=71 end=96 %}
Δείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='sqrtdecomp_NsqrtN.cc' %})

