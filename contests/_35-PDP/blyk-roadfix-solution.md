---
layout: solution
codename: roadfix
---

## Επεξήγηση εκφώνησης
Μας δίνονται $$N$$ ευθύγραμμα τμήματα πάνω σε μία ευθεία, κι ένα κόστος για το κάθε ευθύγραμμο τμήμα. Κατόπιν μας δίνονται $$M$$ ερωτήματα. Το κάθε ερώτημα είναι ένα νέο ευθύγραμμο τμήμα. Καλούμαστε να βρούμε ένα υποσύνολο των $$N$$ ευθυγράμμων τμημάτων που να καλύπτει πλήρως το υπό ερώτηση ευθύγραμμο τμήμα, και ταυτόχρονα να ελαχιστοποιεί το άθροισμα των κοστών.

Το $$i$$-οστό από τα $$N$$ ευθύγραμμα τμήματα έχει το αριστερό του άκρο στη θέση $$X_i$$, μήκος $$L_i$$ (άρα το δεξί του άκρο βρίσκεται στη θέση $$Y_i=X_i+L_i$$), και κόστος $$C_i$$. Για χάρην ευκολίας στην παρουσίαση θα θεωρήσουμε ότι έχουμε μόνο ένα ερώτημα: το αριστερό άκρο του υπό ερώτηση ευθύγραμμου τμήματος βρίσκεται στη θέση $$qX$$, και έχει μήκος $$K$$ (άρα το δεξί του άκρο βρίσκεται στη θέση $$qY=qX+K$$).

Από εδώ και πέρα, όταν γράφουμε "ευθύγραμμο τμήμα [5,11]" θα εννοούμε το ευθύγραμμο τμήμα που ξεκινάει από τη θέση 5 και έχει μήκος 6. Ο λόγος είναι ότι το δεξί άκρο είναι εν προκειμένω πιο ενδιαφέρουσα πληροφορία από το μήκος.

## Άπληστες λύσεις που δεν λειτουργούν (και μία γενικότερη συμβουλή)

Ας ξεκινήσουμε με μία παρατήρηση/συμβουλή. Στο συγκεκριμένο πρόβλημα η σειρά με την οποία μας δίνουν τα ευθύγραμμα τμήματα στην είσοδο δεν επηρεάζει το πρόβλημα. Φανταστείτε, για παράδειγμα, δύο διαφορετικές εισόδους. Στην μία μας δίνονται $$2$$ ευθύγραμμα τμήματα, το $$[5,10]$$ με κόστος $$20$$, και το $$[15,25]$$ με κόστος $$50$$. Στην άλλη μας δίνονται $$2$$ ευθύγραμμα τμήματα, το $$[15,25]$$ με κόστος $$50$$, και το $$[5,10]$$ με κόστος $$20$$. Καταλαβαίνουμε εύκολα ότι στην ουσία πρόκειται για την ίδια είσοδο με αλλαγμένη σειρά. Η απάντηση σε οποιοδήποτε ερώτημα θα είναι ακριβώς η ίδια και στις δύο περιπτώσεις.

Σε προβλήματα με αυτή την ιδιότητα το πρώτο πράγμα που σκεφτόμαστε είναι **πάντα ταξινόμηση**. Ως προς τι όμως; Αριστερό άκρο, δεξί άκρο, μήκος, κόστος; Θα το δούμε σύντομα. Στη συνέχεια η πρώτη μας σκέψη είναι οι *άπληστοι αλγόριθμοι*. Εδώ πέρα δε θα λειτουργούσαν, κι επομένως στρέφουμε την προσοχή μας σε αλγορίθμους δυναμικού προγραμματισμού (dynamic programming ή, όπως γράφουμε συνήθως, dp). Πριν περάσουμε στην λύση με δυναμικό προγραμματισμό, ας δώσουμε πρώτα μία διαίσθηση σχετικά με το γιατί οι άπληστοι αλγόριθμοι δε βοηθάνε. Η ίδια συζήτηση θα μας καθοδηγήσει σχετικά με τον τρόπο που θέλουμε να ταξινομήσουμε.

Ένας απλός άπληστος αλγόριθμος θα ήταν να παίρνουμε κάθε φορά το φθηνότερο τμήμα που καλύπτει κάτι ακάλυπτο από το ερώτημα. Για να υλοποιήσουμε αυτό τον αλγόριθμο, θα ταξινομούσαμε κατά κόστος. Όμως αυτός ο αλγόριθμος είναι λάθος. Σκεφτείτε το πολύ απλό παράδειγμα όπου στην είσοδο μας δίνονται τα τμήματα $$[0,10]$$ με κόστος $$5$$, $$[10,21]$$ με κόστος $$6$$, και $$[6,12]$$ με κόστος $$1$$. Ζητάμε να καλύψουμε το τμήμα $$[0,20]$$.

![Οπτική αναπαράσταση προβλήματος](/assets/35pdpBlykDP320.svg){:width="750px"}

Ο παραπάνω άπληστος αλγόριθμος αυτός θα ξεκινούσε με το τμήμα $$[6,12]$$, μετά με το $$[0,10]$$, και τέλος με το $$[10,21]$$: συνολικό κόστος $$1+5+6=12$$. Όμως αν παραλείπαμε το τμήμα $$[6,12]$$ θα παίρναμε έγκυρη λύση συνολικού κόστους $$5+6=11$$.

Ας φανταστούμε έναν άλλο άπληστο αλγόριθμο: αυτόν που διαλέγει το ευθύγραμμο τμήμα που ελαχιστοποιεί τον λόγο μεταξύ του κόστους και του μήκους που ήταν ακάλυπτο και πλέον θα καλυφθεί. Το παραπάνω παράδειγμα δείχνει ότι και αυτός ο αλγόριθμος είναι λάθος: αρχικά θα διάλεγε το $$[6,12]$$ γιατί ο λόγος κόστους ανά κάλυψη είναι $$1/6$$, ενώ του $$[0,10]$$ είναι $$5/10$$ και του $$[10,21]$$ είναι $$6/10$$ (προσέξτε ότι δε διαιρούμε με 11, που είναι το μήκος του τμήματος $$[10,21]$$, αλλά με $$10$$, που είναι το μήκος που θα καλύψει (ενώ ήταν ακάλυπτο) από το $$[0,20]$$). Κατόπιν θα επιλέξει το $$[10,21]$$, που έχει λόγο $$6/8$$ (το τμήμα $$[10,12]$$ είναι ήδη καλυμμένο, άρα θα καλύψει μήκος $$8$$), αντί του $$[0,10]$$ που έχει λόγο $$5/6$$. Τέλος, αφού δεν έχει καλυφθεί ολόκληρο το $$[0,20]$$ θα επιλέξει και το $$[0,10]$$. Όπως προηγουμένως, η λύση αυτή έχει κόστος $$12$$, ενώ η βέλτιστη έχει κόστος $$11$$.

Ένας τελευταίος άπληστος αλγόριθμος που θα συζητήσουμε θα επέλεγε κάθε φορά το τμήμα που καλύπτει όσο το δυνατόν περισσότερο ακάλυπτο κομμάτι του ερωτήματος. Κι αυτός ο αλγόριθμος είναι λάθος: Αν στο παραπάνω παράδειγμα υπήρχε κι ένα τμήμα [0,20] με κόστος 100, θα το επιλέγαμε πρώτο, και θα πληρώναμε πάρα πολύ.

## Λύση 1Α - Δυναμικός προγραμματισμός - $$\mathcal{O}(MN^2)$$

Αφού οι άπληστες λύσεις δεν λειτούργησαν, μπορούμε να σκεφτούμε λύσεις δυναμικού προγραμματισμού. Επιπλέον είδαμε ότι ταξινομήσεις ως προς μήκος ή/και κόστος δεν φαίνεται να μας βοηθάνε. Δοκιμάζουμε λοιπόν να ταξινομήσουμε με βάση το δεξί άκρο. Θα μπορούσαμε να ταξινομήσουμε και με βάση το αριστερό άκρο, αφού το πρόβλημα είναι συμμετρικό. Επιλέξαμε το δεξί άκρο επειδή θεωρούμε ότι κάνει κατανοητότερη την παρουσίαση.

Θα δοκιμάσουμε μία κλασική προσέγγιση δυναμικού προγραμματισμού, να λύσουμε προθέματα του προβλήματός μας. Για παράδειγμα να περιοριστούμε στα πρώτα $$i$$ ευθύγραμμα τμήματα (αντί για όλα τα $$N$$), ή να προσποιηθούμε ότι το ερώτημα είναι το $$[qX,Y']$$ αντί για $$[qX,qY]$$, όπου $$Y'\le qY$$. Σε αυτή τη λύση, δοκιμάζουμε ταυτόχρονα και τις δύο προσεγγίσεις.

Εδώ θα κάνουμε μια παύση, γιατί βρισκόμαστε ακριβώς στο σημείο που μπερδεύει τον περισσότερο κόσμο που δεν είναι εξοικειωμένος με το δυναμικό προγραμματισμό. Κι ο λόγος που δημιουργείται μπέρδεμα είναι επειδή ακούγεται τόσο χαζή η προσέγγιση, που όλοι θεωρούν ότι κάτι δεν κατάλαβαν. Κι όμως...

Ας σκεφτούμε λοιπόν ότι το πρόβλημά μας είναι το εξής.

![Οπτική αναπαράσταση προβλήματος](/assets/35pdpBlykDP320.svg){:width="750px"}

Για συντομία, θα ονομάσουμε αυτό το πρόβλημα $$(3,20)$$. Εννοούμε ότι μας ενδιαφέρουν τα πρώτα $$3$$ (δηλαδή όλα!) τα ευθύγραμμα τμήματα, και το ερώτημά μας τελειώνει στο σημείο $$20$$. Αντίστοιχα μπορούμε να ορίσουμε το υποπρόβλημα $$(2,10)$$, όπου μας δίνονται μόνο τα πρώτα $$2$$ ευθύγραμμα τμήματα, και το ερώτημά μας τελειώνει στο σημείο $$10$$. Λέγοντας δηλαδή $$(2,10)$$ αναφερόμαστε στο εξής υποπρόβλημα:

![Οπτική αναπαράσταση υποπροβλήματος](/assets/35pdpBlykDP210.svg){:width="750px"}

Ο δυναμικός προγραμματισμός λέει κάτι που αρχικά ακούγεται εντελώς ανόητο. Αντί να λύσουμε απευθείας μόνο το $$(3,20)$$ (που ήδη δεν ξέρουμε πώς να το λύσουμε), ας λύσουμε όλα τα εξής υποπροβλήματα:

| [(0,0)](/assets/35pdpBlykDP00.svg) | [(1,0)](/assets/35pdpBlykDP10.svg) | [(2,0)](/assets/35pdpBlykDP20.svg) | [(3,0)](/assets/35pdpBlykDP30.svg) |
| [(0,6)](/assets/35pdpBlykDP06.svg) | [(1,6)](/assets/35pdpBlykDP16.svg) | [(2,6)](/assets/35pdpBlykDP26.svg) | [(3,6)](/assets/35pdpBlykDP36.svg) |
| [(0,10)](/assets/35pdpBlykDP010.svg) | [(1,10)](/assets/35pdpBlykDP110.svg) | [(2,10)](/assets/35pdpBlykDP210.svg) | [(3,10)](/assets/35pdpBlykDP310.svg) |
| [(0,12)](/assets/35pdpBlykDP012.svg) | [(1,12)](/assets/35pdpBlykDP112.svg) | [(2,12)](/assets/35pdpBlykDP212.svg) | [(3,12)](/assets/35pdpBlykDP312.svg) |
| [(0,20)](/assets/35pdpBlykDP020.svg) | [(1,20)](/assets/35pdpBlykDP120.svg) | [(2,20)](/assets/35pdpBlykDP220.svg) | [(3,20)](/assets/35pdpBlykDP320.svg) |

(πατώντας πάνω σε κάθε υποπρόβλημα μπορείτε να δείτε και μία οπτική αναπαράστασή του)

Παρότι αυτό φαίνεται εντελώς χαζό, υπάρχει μια λογική από πίσω. Σκεφτείτε να αναθέσετε σε ένα μαθητή δευτέρας δημοτικού να αθροίσει μία λίστα με $$100$$ αριθμούς. Σίγουρα θα τρομάξει και θα φύγει. Αν όμως του πείτε ποιο είναι το άθροισμα των πρώτων $$99$$, τότε του μένει μόνο μία πρόσθεση: αυτή του $$100$$ου αριθμού με το άθροισμα των υπόλοιπων $$99$$. Η λύση δηλαδή ενός πιο εύκολου *σχετικού* υποπροβλήματος (αυτό των $$99$$ αριθμών) βοήθησε στη λύση του αρχικού προβλήματος.

Ας γυρίσουμε στο δικό μας πρόβλημα, κι ας προσπαθήσουμε να καταλάβουμε πώς λειτουργεί ο δυναμικός προγραμματισμός.

Προσπαθούμε να βρούμε το βέλτιστο κόστος $$\texttt{ans}(i,Y')$$ για να καλύψουμε με τα πρώτα $$i$$ τμήματα το τμήμα $$[qX,Y']$$, για κάθε $$i\le N$$ και κάθε $$Y'\in [qX,qY]$$. Εν τέλει η απάντησή μας θα είναι απλώς το $$\texttt{ans}(N,qY)$$.

Έχουμε το αρχικό μας πρόβλημα, δηλαδή το $$(3,20)$$.

![Οπτική αναπαράσταση προβλήματος](/assets/35pdpBlykDP320.svg){:width="750px"}

Υποθέτουμε ότι το τελευταίο μας τμήμα (εν προκειμένω το τρίτο) τέμνει το $$[0,20]$$ (αλλιώς απλώς θα το αγνοούσαμε) και μάλιστα περιλαμβάνει το $$20$$ (αλλιώς λόγω της ταξινόμησης κανένα τμήμα δεν θα κάλυπτε το $$20$$, κι επομένως δεν θα υπήρχε τρόπος να καλύψουμε το $$[0,20]$$). Αν αποφασίσουμε να χρησιμοποιήσουμε αυτό το τμήμα, τότε αρκεί με τα υπόλοιπα $$2$$ τμήματα να καλύψουμε ό,τι έχει μείνει ακάλυπτο (δηλαδή το $$[0,10]$$). Έτσι πληρώνουμε για το τμήμα που χρησιμοποιήσαμε (κόστος $$6$$), και αρκεί με τα υπόλοιπα $$2$$ τμήματα να καλύψουμε το $$[0,10]$$.

Πώς καλύπτουμε το $$[0,10]$$ με δύο τμήματα; Λύνοντας το εξής υποπρόβλημα:

![Οπτική αναπαράσταση υποπροβλήματος](/assets/35pdpBlykDP210.svg){:width="750px"}

Υπάρχει βέβαια και η επιλογή να μη χρησιμοποιήσουμε καθόλου το $$3$$ο τμήμα (πχ επειδή είναι πολύ ακριβό) κι έτσι να πρέπει με τα $$2$$ τμήματα να καλύψουμε όλο το $$[0,20]$$. Η μία περίπτωση δηλαδή πληρώνει για το $$3$$ο τμήμα αλλά τουλάχιστον καλύπτει και λίγο από το ερώτημα, ενώ η άλλη δεν πληρώνει αλλά δεν καλύπτει και τίποτα. Επειδή δεν είμαστε σίγουροι ποια είναι η καλύτερη, δοκιμάζουμε και τις δύο. Καταλήγουμε, δεδομένων των υποθέσεων που κάναμε στην αρχή της παραγράφου, ότι

$$ans(N,qY) = min\{C_N+ans(N-1,X_N), ans(N-1,qY)\}$$

και γενικότερα για οποιοδήποτε i,Y':

$$ans(i,Y') = min\{C_i+ans(i-1,X_i), ans(i-1,Y')\}$$

Η παραπάνω λύση θα ήταν δραματικά αργή, γιατί το πλήθος των πιθανών $$Y'$$ που καλούμαστε να υπολογίσουμε είναι τεράστιο. Όμως προσέξτε ότι τα $$Y'$$ που πραγματικά μας ενδιαφέρουν είναι πάντα είτε τα αριστερά άκρα κάποιου τμήματος, είτε το $$qY$$. Επομένως υπάρχουν $$\mathcal{O}(N)$$ επιλογές για το $$Y'$$, και $$N$$ επιλογές για το $$i$$. Συμπεραίνουμε ότι υπάρχουν $$\mathcal{O}(N^2)$$ πιθανές καταστάσεις του $$\texttt{ans}(i,Y')$$ που μας ενδιαφέρουν ανά ερώτημα, και για κάθε μία χρειάζεται να ξοδέψουμε $$\mathcal{O}(1)$$ χρόνο. Συνεπώς η πολυπλοκότητα είναι $$\mathcal{O}(MN^2)$$.


Ενδεικτικά δίνουμε τον παρακάτω κώδικα για το πρόβλημα. Χρησιμοποιεί ακριβώς την παραπάνω σχέση, και κάνει τους σχετικούς ελέγχους που αναφέραμε (πχ ότι το $$i$$-οστό τμήμα έχει τομή με το $$[qX,Y']$$). Δίνουμε τόσο την αναδρομική όσο και την επαναληπτική λύση. Δεν έχουν κάποια αξιοσημείωτη διαφορά στην ταχύτητα, επιλέξτε όποια προτιμάτε. Προσέξτε ότι ο κώδικας είναι σχεδόν ίδιος. Η μόνη αλλαγή είναι ότι ο κώδικας της αναδρομικής συνάρτησης έχει μπει μέσα στην επανάληψη, με ελάχιστες (τυπικές) αλλαγές.

Βασικές σημειώσεις για τον κώδικα (ισχύουν γενικά για τον δυναμικό προγραμματισμό):
* Στην αναδρομική λύση, φροντίζουμε να μην ξαναϋπολογίζουμε πράγματα που ήδη έχουμε υπολογίσει. Απλώς αποθηκεύουμε την απάντησή τους την πρώτη φορά που την υπολογίζουμε, ώστε να την επιστρέψουμε απευθείας όταν μας ξαναζητηθεί.
* Στην επαναληπτική λύση, αρκεί να υπολογίζουμε τα υποπροβλήματα με κάποια λογική σειρά. Δηλαδή όταν υπολογίζουμε κάποιο υποπρόβλημα $$\texttt{ans}(i,Y')$$, θα πρέπει ήδη να έχουμε υπολογίσει τόσο το $$\texttt{ans}(i-1,Y')$$ όσο και το $$\texttt{ans}(i,Y'-1)$$. Στην πράξη, ακόμα και να μην το θυμάστε αυτό, κατά $$99\%$$ ο τρόπος με τον οποίο διατρέχετε όλα τα υποπροβλήματα θα έχει από μόνος του αυτή την ιδιότητα. 

{% include code.md solution_name='roadfix_dp_recursive.cc' %}
{% include code.md solution_name='roadfix_dp.cc' %}

## Λύση 1Β - Δυναμικός προγραμματισμός - $$\mathcal{O}(MN^2)$$

Εδώ παρουσιάζουμε μία ακόμα λύση πολυπλοκότητας $$\mathcal{O}(MN^2)$$. Ο βασικός λόγος είναι ότι η παρούσα λύση μπορεί να βελτιωθεί περαιτέρω, αρκεί να χρησιμοποιήσουμε κάποιες έξυπνες δομές δεδομένων. Επιπλέον, η εμπειρία μας μας έχει διδάξει ότι άλλοι μαθητές κατανοούν καλύτερα την 1Α κι άλλοι την 1Β, οπότε αποφασίσαμε να παραθέσουμε και τις δύο.

Ας προσπαθήσουμε να κατανοήσουμε γιατί η προηγούμενη λύση είναι αργή. Για κάθε πιθανό τμήμα $$i$$, δοκιμάζουμε πολλές διαφορετικές τιμές για το $$Y'$$. Θα περίμενε κανείς ότι θα μας ενδιέφερε μόνο η $$Y'=Y_i$$, επειδή αν πάρουμε το τμήμα $$i$$ τότε θα φτάσουμε ως τη θέση $$Y_i$$. Το πρόβλημα είναι ότι ορίσαμε την $$\texttt{ans}(Y',i)$$ ως τον βέλτιστο τρόπο να καλύψουμε το $$[qX, Y']$$ χρησιμοποιώντας *οποιαδήποτε* από τα πρώτα $$i$$ τμήματα. Επειδή όμως δεν έχουμε την εγγύηση ότι το $$i$$-οστό τμήμα θα χρησιμοποιηθεί απαραίτητα, πρέπει να δοκιμάσουμε και άλλες τιμές του $$Y'$$ πέρα από την $$Y_i$$.

Για να αποφύγουμε αυτό το πρόβλημα, τώρα θα ορίσουμε $$\texttt{ans'}(i)$$ ως το βέλτιστο κόστος να καλύψουμε το $$[qX, Y_i]$$ παίρνοντας οπωσδήποτε το $$i$$-οστο τμήμα, και ίσως και κάποια από τα προηγούμενα τμήματα. Έτσι για κάθε $$i$$ έχουμε μόνο ένα $$Y'$$ που μας ενδιαφέρει (το $$Y_i$$, όπως θα περιμέναμε). Αρκεί αυτή η πληροφορία; Αν μαγικά μας δινόντουσαν όλα τα $$\texttt{ans'}(i)$$, πώς θα υπολογίζαμε την τελική απάντηση;

Είναι απλό. Η τελική απάντηση σίγουρα θα περιλαμβάνει ένα τμήμα (και μάλιστα μοναδικό) το οποίο καλύπτει το $$qY$$. Αν μαντέψω ποιο είναι αυτό το τμήμα, τότε η $$\texttt{ans'}$$ αυτού θα είναι η σωστή απάντηση. Μαντεύουμε απλώς δοκιμάζοντας όλα τα πιθανά τμήματα που καλύπτουν το $$qY$$ και κρατώντας το καλύτερο. Καλό είναι να προσπαθήσετε τουλάχιστον πέντε λεπτά να καταλάβετε γιατί ισχύουν οι ισχυρισμοί αυτής της παραγράφου, πριν προχωρήσετε παρακάτω.

Προσπαθούμε λοιπόν πλέον να υπολογίσουμε όλες τις $$\texttt{ans'}$$ τιμές. Ας φανταστούμε ότι θέλουμε να χρησιμοποιήσουμε το $$i$$-οστό τμήμα. Τότε θα καλύψουμε το $$[X_i,Y_i]$$. Επιτρέπεται με τα υπόλοιπα τμήματα να καλύψουμε ξανά κάτι από το $$[X_i,Y_i]$$, αλλά δεν είναι απαραίτητο. Αυτό που επιβάλλεται είναι να καλύψουμε το διάστημα $$[qX,X_i]$$. Αν μπορούσαμε να μαντέψουμε ακριβώς μέχρι ποιο σημείο $$J$$ του (προαιρετικού) διαστήματος $$[X_i,Y_i]$$ θα καλύψουμε, τότε θα ζητούσαμε μία λύση που καλύπτει το $$[qX,J]$$ και τίποτα πέρα από το $$J$$. Επειδή δεν μπορούμε να μαντέψουμε το $$J$$, δοκιμάζουμε όλες τις πιθανές εκδοχές, και κρατάμε την καλύτερη. Δηλαδή:

$$ans'(i) = C_i + min_{j: Y_j\ge X_i} ans'(j)$$

Τι κερδίσαμε; Υπολογίζουμε $$\mathcal{O}(N)$$ αντί για $$\mathcal{O}(N^2)$$ καταστάσεις. Τι χάσαμε; Η μαντεψιά για το $$j$$ είναι πολύ ακριβή, και παίρνει $$\mathcal{O}(N)$$ χρόνο. Εν τέλει η πολυπλοκότητα είναι ακριβώς η ίδια.

Παρακάτω θα δούμε τα θετικά αυτής της λύσης, και συγκεκριμένα ότι μπορεί να βελτιωθεί περαιτέρω. Μπορείτε να βρείτε τον κώδικα για την παρούσα λύση  [εδώ]({% include link_to_source.md solution_name='roadfix_dp2.cc' %}).

## Λύση 2 - Βελτιωμένος δυναμικός προγραμματισμός - $$\mathcal{O}(MN\log{N})$$

Μήπως μπορούμε να βελτιώσουμε τον χρόνο που μας παίρνει η μαντεψιά του $$j$$ στην προηγούμενη λύση; Ψάχνουμε το

$$min_{j: Y_j\ge X_i} ans'(j)$$

Η κρίσιμη (και όχι τόσο προφανής) ιδέα εδώ πέρα είναι η εξής: αν φανταστούμε έναν πίνακα που στη θέση $$Y_j$$ περιέχει την τιμή $$\texttt{ans'}(j)$$, τότε ζητάμε την ελάχιστη τιμή του πίνακα στο διάστημα που ξεκινάει από το $$X_i$$ και εκτείνεται μέχρι το τέλος. Το πρόβλημα αυτό είναι γνωστό: λέγεται Range Minimum Query (RMQ, δείτε [εδώ](https://cp-algorithms.com/sequences/rmq.html) για προτάσεις σχετικά με το πώς λύνεται). Χρησιμοποιώντας μια καλή λύση για αυτό το πρόβλημα (πχ με δυαδικά δέντρα) μπορούμε να πάρουμε απάντηση σε $$\mathcal{O}(\log{N})$$ χρόνο, αντί για $$\mathcal{O}(N)$$.

Καταλήγουμε ότι υπάρχουν $$N$$ καταστάσεις να υπολογίσουμε ανά ερώτημα, και για την κάθε μία χρειαζόμαστε $$\mathcal{O}(\log{N})$$ χρόνο. Η τελική πολυπλοκότητα είναι $$\mathcal{O}(MN\log{N})$$. Μπορείτε να βρείτε τον κώδικα για την παρούσα λύση  [εδώ]({% include link_to_source.md solution_name='roadfix_dp_improved.cc' %}).

## Λύση 3 - $$\mathcal{O}(MN\log{N}/\log{\log{N}})$$

Αν χρησιμοποιήσουμε αποδοτικότερες λύσεις για το RMQ πρόβλημα, παίρνουμε καλύτερη συνολική πολυπλοκότητα. Μία τέτοια λύση χρησιμοποιεί Fusion Trees. Στην ουσία τα Fusion Trees είναι παρόμοια με τα κλασικά δυαδικά δέντρα, αλλά έχουν περίπου $$\log{N}$$ παιδιά ανά κόμβο. Αυτό που πετυχαίνουν είναι ο χρόνος να γίνεται (θεωρητικά) καλύτερος κατά $$\log{\log{N}}$$. Δυστυχώς η κατανόηση της λειτουργίας τους ξεφεύγει από τα όρια των διαγωνισμών, και ο κώδικάς τους είναι πολύ πιο περίπλοκος. Το πιο αστείο είναι ότι στην πράξη ούτε ο χρόνος που δίνουν είναι καλύτερος, γιατί κρύβουν μεγαλύτερους σταθερούς παράγοντες μέσα στο $$\mathcal{O}(\log{N}/\log{\log{N}})$$. Επομένως δεν θα δώσουμε κώδικα για αυτή τη λύση.

## Ανοιχτό ερώτημα - Υπάρχει καλύτερη λύση;

Γενικά το RMQ δεν μπορεί να λυθεί σε χρόνο καλύτερο από $$\mathcal{O}(\log{N}/\log{\log{N}})$$, όταν δεν έχουμε καμμία γνώση για τα επερχόμενα ερωτήματα/ανανεώσεις, και μπορεί να έρθει οποιοδήποτε ερώτημα/ανανέωση. Στη συγκεκριμένη περίπτωση δεν είναι όμως σαφές αν χρειαζόμαστε τόσο χρόνο. Ίσως για παράδειγμα μπορούμε να αξιοποιήσουμε ότι τα επερχόμενα ερωτήματα/ανανεώσεις δεν μας είναι παντελώς άγνωστα, αλλά σχετίζονται με την είσοδο την οποία έχουμε διαβάσει ολόκληρη από την αρχή. Επιπλέον τα ερωτήματα/ανανεώσεις δεν μπορούν να είναι εντελώς αυθαίρετα (πχ στα ερωτήματα που καλούμαστε να λύσουμε εν προκειμένω, το δεξί άκρο είναι πάντα απεριόριστο). Δε θα μας εξέπληττε λοιπόν στο συγκεκριμένο πρόβλημα το RMQ να μπορεί να υλοποιηθεί και σε $$\mathcal{O}(1)$$ χρόνο, και να παίρναμε συνολική πολυπλοκότητα $$\mathcal{O}(MN)$$.

Επιπλέον, ίσως να υπάρχουν και ακόμα καλύτερες λύσεις, που να ακολουθούν εντελώς διαφορετική προσέγγιση. Το πιο ενδιαφέρον θα ήταν να καταφέρναμε με κάποια προεργασία να λύσουμε το πρόβλημα σε χρόνο ταχύτερο από γραμμικό ανά ερώτημα, πχ σε συνολικό χρόνο $$\mathcal{O}(N+M\log{N})$$.