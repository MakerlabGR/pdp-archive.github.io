---
layout: solution
codename: coupon
---

## Επεξήγηση εκφώνησης
Μας δίνονται $$N$$ ευθύγραμμα τμήματα πάνω σε μία ευθεία, κι ένα κόστος για το κάθε ευθύγραμμο τμήμα. Κατόπιν μας δίνονται $$M$$ ερωτήματα. Το κάθε ερώτημα είναι ένα νέο ευθύγραμμο τμήμα. Καλούμαστε να βρούμε ένα υποσύνολο των $$N$$ ευθυγράμμων τμημάτων που να καλύπτει πλήρως το υπό ερώτηση ευθύγραμμο τμήμα, και ταυτόχρονα να ελαχιστοποιεί το άθροισμα των κοστών.

Το $$i$$-οστό από τα $$N$$ ευθύγραμμα τμήματα έχει το αριστερό του άκρο στη θέση $$X_i$$, μήκος $$L_i$$ (άρα το δεξί του άκρο βρίσκεται στη θέση $$Y_i=X_i+L_i$$), και κόστος $$C_i$$. Για χάρην ευκολίας στην παρουσίαση θα θεωρήσουμε ότι έχουμε μόνο ένα ερώτημα: το αριστερό άκρο του υπό ερώτηση ευθύγραμμου τμήματος βρίσκεται στη θέση $$qX$$, και έχει μήκος $$K$$ (άρα το δεξί του άκρο βρίσκεται στη θέση $$qY=qX+K$$).

Από εδώ και πέρα, όταν γράφουμε "ευθύγραμμο τμήμα [5,11]" θα εννοούμε το ευθύγραμμο τμήμα που ξεκινάει από τη θέση 5 και έχει μήκος 6. Ο λόγος είναι ότι το δεξί άκρο είναι εν προκειμένω πιο ενδιαφέρουσα πληροφορία από το μήκος.

## Άπληστες λύσεις που δεν λειτουργούν (και μία γενικότερη συμβουλή)

Ας ξεκινήσουμε με μία παρατήρηση/συμβουλή. Στο συγκεκριμένο πρόβλημα η σειρά με την οποία μας δίνουν τα ευθύγραμμα τμήματα στην είσοδο δεν επηρεάζει το πρόβλημα. Φανταστείτε, για παράδειγμα, δύο διαφορετικές εισόδους. Στην μία μας δίνονται τα ευθύγραμμα τμήματα $$[5,10]$$ με κόστος $$20$$, και $$[15,25]$$ με κόστος $$50$$. Στην άλλη μας δίνονται τα ευθύγραμμα τμήματα $$[15,25]$$ με κόστος $$50$$, και $$[5,10]$$ με κόστος $$20$$. Καταλαβαίνουμε εύκολα ότι στην ουσία πρόκειται για την ίδια είσοδο με αλλαγμένη σειρά. Η απάντηση σε οποιοδήποτε ερώτημα θα είναι ακριβώς η ίδια και στις δύο περιπτώσεις.

Σε προβλήματα με αυτή την ιδιότητα το πρώτο πράγμα που σκεφτόμαστε είναι **πάντα ταξινόμηση**. Ως προς τι όμως; Αριστερό άκρο, δεξί άκρο, μήκος, κόστος; Θα το δούμε σύντομα. Στη συνέχεια η πρώτη μας σκέψη είναι οι *άπληστοι αλγόριθμοι*. Εδώ πέρα δε θα λειτουργούσαν, κι επομένως στρέφουμε την προσοχή μας σε αλγορίθμους δυναμικού προγραμματισμού (dynamic programming ή, όπως γράφουμε συνήθως, dp). Πριν περάσουμε στην λύση με δυναμικό προγραμματισμό, ας δώσουμε πρώτα μία διαίσθηση σχετικά με το γιατί οι άπληστοι αλγόριθμοι δε βοηθάνε. Η ίδια συζήτηση θα μας καθοδηγήσει σχετικά με τον τρόπο που θέλουμε να ταξινομήσουμε.

Ένας απλός άπληστος αλγόριθμος θα ήταν να παίρνουμε κάθε φορά το φθηνότερο τμήμα που καλύπτει κάτι ακάλυπτο από το ερώτημα. Για να υλοποιήσουμε αυτό τον αλγόριθμο, θα ταξινομούσαμε κατά κόστος. Όμως αυτός ο αλγόριθμος είναι λάθος. Σκεφτείτε το πολύ απλό παράδειγμα όπου στην είσοδο μας δίνονται τα τμήματα $$[0,10]$$ με κόστος $$5$$, $$[10,21]$$ με κόστος $$6$$, και $$[6,12]$$ με κόστος $$1$$. Ζητάμε να καλύψουμε το τμήμα $$[0,20]$$. Ο αλγόριθμος αυτός θα ξεκινούσε με το τμήμα $$[6,12]$$, μετά με το $$[0,10]$$, και τέλος με το $$[10,21]$$: συνολικό κόστος $$1+5+6=12$$. Όμως αν παραλείπαμε το τμήμα $$[6,12]$$ θα παίρναμε έγκυρη λύση συνολικού κόστους $$5+6=11$$.

Ας φανταστούμε έναν άλλο άπληστο αλγόριθμο: αυτόν που διαλέγει το ευθύγραμμο τμήμα που ελαχιστοποιεί τον λόγο μεταξύ του κόστους και του μήκους που ήταν ακάλυπτο και πλέον θα καλυφθεί. Το παραπάνω παράδειγμα δείχνει ότι και αυτός ο αλγόριθμος είναι λάθος: αρχικά θα διάλεγε το $$[6,12]$$ γιατί ο λόγος κόστους ανά κάλυψη είναι $$1/6$$, ενώ του $$[0,10]$$ είναι $$5/10$$ και του $$[10,21]$$ είναι $$6/10$$ (προσέξτε ότι δε διαιρούμε με 11, που είναι το μήκος του τμήματος $$[10,21]$$, αλλά με $$10$$, που είναι το μήκος που θα καλύψει (ενώ ήταν ακάλυπτο) από το $$[0,20]$$). Κατόπιν θα επιλέξει το $$[10,21]$$, που έχει λόγο $$6/8$$ (το τμήμα $$[10,12]$$ είναι ήδη καλυμμένο, άρα θα καλύψει μήκος $$8$$), αντί του $$[0,10]$$ που έχει λόγο $$5/6$$. Τέλος, αφού δεν έχει καλυφθεί ολόκληρο το $$[0,20]$$ θα επιλέξει και το $$[0,10]$$. Όπως προηγουμένως, η λύση αυτή έχει κόστος $$12$$, ενώ η βέλτιστη έχει κόστος $$11$$.

Ένας τελευταίος άπληστος αλγόριθμος που θα συζητήσουμε θα επέλεγε κάθε φορά το τμήμα που καλύπτει όσο το δυνατόν περισσότερο ακάλυπτο κομμάτι του ερωτήματος. Κι αυτός ο αλγόριθμος είναι λάθος: Αν στο παραπάνω παράδειγμα υπήρχε κι ένα τμήμα [0,20] με κόστος 100, θα το επιλέγαμε πρώτο, και θα πληρώναμε πάρα πολύ.

## Λύση 1Α - Δυναμικός προγραμματισμός - $$\mathcal{O}(MN^2)$$

Αφού οι άπληστες λύσεις δεν λειτούργησαν, μπορούμε να σκεφτούμε λύσεις δυναμικού προγραμματισμού. Επιπλέον είδαμε ότι ταξινομήσεις ως προς μήκος ή/και κόστος δεν φαίνεται να μας βοηθάνε. Δοκιμάζουμε λοιπόν να ταξινομήσουμε με βάση το δεξί άκρο. Θα μπορούσαμε να ταξινομήσουμε και με βάση το αριστερό άκρο, αφού το πρόβλημα είναι συμμετρικό. Επιλέξαμε το δεξί άκρο επειδή θεωρούμε ότι κάνει κατανοητότερη την παρουσίαση.

Θα δοκιμάσουμε μία κλασική προσέγγιση δυναμικού προγραμματισμού, να λύσουμε προθέματα του προβλήματός μας. Για παράδειγμα να περιοριστούμε στα πρώτα $$i$$ ευθύγραμμα τμήματα (αντί για όλα τα $$N$$), ή να προσποιηθούμε ότι το ερώτημα είναι το $$[qX,Y']$$ αντί για $$[qX,qY]$$, όπου $$Y'\le qY$$. Σε αυτή τη λύση, δοκιμάζουμε ταυτόχρονα και τις δύο προσεγγίσεις.

Προσπαθούμε λοιπόν να βρούμε το βέλτιστο κόστος $$\texttt{ans}(Y',i)$$ για να καλύψουμε το τμήμα $$[qX,Y']$$ χρησιμοποιώντας τα πρώτα $$i$$ τμήματα, για κάθε $$Y'\in [qX,qY]$$ και κάθε $$i\le N$$. Εν τέλει η απάντησή μας θα είναι απλώς το $$\texttt{ans}(qY,N)$$.

Φανταστείτε ότι ενδιαφερόμαστε για το βέλτιστο κόστος κάλυψης του $$[qX,Y']$$. Υποθέτουμε ότι το τελευταίο μας τμήμα τέμνει το $$[qX,Y']$$ (αλλιώς απλώς θα το αγνοούσαμε) και μάλιστα περιλαμβάνει το $$Y'$$ (αλλιώς λόγω της ταξινόμησης κανένα τμήμα δεν θα κάλυπτε το $$Y'$$, κι επομένως δεν θα υπήρχε τρόπος να καλύψουμε το $$[qX,Y']$$). Αν αποφασίσουμε να χρησιμοποιήσουμε αυτό το τμήμα, τότε αρκεί με τα υπόλοιπα $$N-1$$ τμήματα να καλύψουμε ό,τι έχει μείνει ακάλυπτο. Με βάση τις παραπάνω παρατηρήσεις και 5 λεπτά σκέψης, μπορούμε να δούμε ότι είτε έχει καλυφθεί ολόκληρο το $$[qX,Y']$$, είτε μένει ακάλυπτο το $$[qX,X_N]$$. Στην δεύτερη περίπτωση, πληρώνουμε για το $$N$$-οστό τμήμα, και αρκεί με τα υπόλοιπα $$N-1$$ τμήματα να καλύψουμε το $$[qX,X_N]$$. Υπάρχει βέβαια και η επιλογή να μη χρησιμοποιήσουμε καθόλου το $$N$$-οστό τμήμα (πχ επειδή είναι πολύ ακριβό) κι έτσι να πρέπει με τα $$N-1$$ τμήματα να καλύψουμε όλο το $$[qX,Y']$$. Η μία περίπτωση δηλαδή πληρώνει για το $$N$$-οστό τμήμα αλλά καλύπτει και λίγο από το ερώτημα, ενώ η άλλη δεν πληρώνει αλλά δεν καλύπτει και τίποτα. Επειδή δεν είμαστε σίγουροι ποια είναι η καλύτερη, δοκιμάζουμε και τις δύο. Καταλήγουμε, δεδομένων των υποθέσεων που κάναμε στην αρχή της παραγράφου, ότι

$$ans(Y',N) = min\{C_N+ans(X_N,N-1), ans(Y',N-1)\}$$

και γενικότερα για οποιοδήποτε i

$$ans(Y',i) = min\{C_i+ans(X_i,i-1), ans(Y',i-1)\}$$

Η παραπάνω λύση θα ήταν δραματικά αργή, γιατί το πλήθος των πιθανών $$Y'$$ είναι τεράστιο. Όμως προσέξτε ότι τα $$Y'$$ που πραγματικά μας ενδιαφέρουν είναι πάντα είτε τα αριστερά άκρα κάποιου τμήματος, είτε το $$qY$$. Επομένως υπάρχουν $$\mathcal{O}(N)$$ επιλογές για το $$Y'$$, και $$N$$ επιλογές για το $$i$$. Συμπεραίνουμε ότι υπάρχουν $$\mathcal{O}(N^2)$$ πιθανές καταστάσεις του $$\texttt{ans}(Y',i)$$ που μας ενδιαφέρουν ανά ερώτημα, και για κάθε μία χρειάζεται να ξοδέψουμε $$\mathcal{O}(1)$$ χρόνο. Συνεπώς η πολυπλοκότητα είναι $$\mathcal{O}(MN^2)$$.


Ενδεικτικά δίνουμε τον παρακάτω κώδικα για το πρόβλημα. Χρησιμοποιεί ακριβώς την παραπάνω σχέση, και κάνει τους σχετικούς ελέγχους που αναφέραμε (πχ ότι το $$i$$-οστό τμήμα έχει τομή με το $$[qX,Y']$$). Δίνουμε τόσο την αναδρομική όσο και την επαναληπτική λύση. Δεν έχουν κάποια αξιοσημείωτη διαφορά στην ταχύτητα, επιλέξτε όποια προτιμάτε. Προσέξτε ότι ο κώδικας είναι σχεδόν ίδιος. Η μόνη αλλαγή είναι ότι ο κώδικας της αναδρομικής συνάρτησης έχει μπει μέσα στην επανάληψη, με ελάχιστες (τυπικές) αλλαγές.



## Λύση 1Β - Δυναμικός προγραμματισμός - $$\mathcal{O}(MN^2)$$

Εδώ παρουσιάζουμε μία ακόμα λύση πολυπλοκότητας $$\mathcal{O}(MN^2)$$. Ο βασικός λόγος είναι ότι η παρούσα λύση μπορεί να βελτιωθεί περαιτέρω, αρκεί να χρησιμοποιήσουμε κάποιες έξυπνες δομές δεδομένων. Επιπλέον, η εμπειρία μας μας έχει διδάξει ότι άλλοι μαθητές κατανοούν καλύτερα την 1Α κι άλλοι την 1Β, οπότε αποφασίσαμε να παραθέσουμε και τις δύο.

Ας προσπαθήσουμε να κατανοήσουμε γιατί η προηγούμενη λύση είναι αργή. Για κάθε πιθανό τμήμα $$i$$, δοκιμάζουμε πολλές διαφορετικές τιμές για το $$Y'$$. Θα περίμενε κανείς ότι θα μας ενδιέφερε μόνο η $$Y'=Y_i$$, επειδή αν πάρουμε το τμήμα $$i$$ τότε θα φτάσουμε ως τη θέση $$Y_i$$. Το πρόβλημα είναι ότι ορίσαμε την $$\texttt{ans}(Y',i)$$ ως τον βέλτιστο τρόπο να καλύψουμε το $$[qX, Y']$$ χρησιμοποιώντας *οποιαδήποτε* από τα πρώτα $$i$$ τμήματα. Επειδή όμως δεν έχουμε την εγγύηση ότι το $$i$$-οστό τμήμα θα χρησιμοποιηθεί απαραίτητα, πρέπει να δοκιμάσουμε και άλλες τιμές του $$Y'$$ πέρα από την $$Y_i$$.

Για να αποφύγουμε αυτό το πρόβλημα, τώρα θα ορίσουμε $$\texttt{ans'}(i)$$ ως το βέλτιστο κόστος να καλύψουμε το $$[qX, Y_i]$$ παίρνοντας οπωσδήποτε το $$i$$-οστο τμήμα, και ίσως και κάποια από τα προηγούμενα τμήματα. Έτσι για κάθε $$i$$ έχουμε μόνο ένα $$Y'$$ που μας ενδιαφέρει (το $$Y_i$$, όπως θα περιμέναμε). Αρκεί αυτή η πληροφορία; Αν μαγικά μας δινόντουσαν όλα τα $$\texttt{ans'}(i)$$, πώς θα υπολογίζαμε την τελική απάντηση;

Είναι απλό. Η τελική απάντηση σίγουρα θα περιλαμβάνει ένα τμήμα (και μάλιστα μοναδικό) το οποίο καλύπτει το $$qY$$. Αν μαντέψω ποιο είναι αυτό το τμήμα, τότε η $$\texttt{ans'}$$ αυτού θα είναι η σωστή απάντηση. Μαντεύουμε απλώς δοκιμάζοντας όλα τα πιθανά τμήματα που καλύπτουν το $$qY$$ και κρατώντας το καλύτερο. Καλό είναι να προσπαθήσετε τουλάχιστον πέντε λεπτά να καταλάβετε γιατί ισχύουν οι ισχυρισμοί αυτής της παραγράφου, πριν προχωρήσετε παρακάτω.

Προσπαθούμε λοιπόν πλέον να υπολογίσουμε όλες τις $$\texttt{ans'}$$ τιμές. Ας φανταστούμε ότι θέλουμε να χρησιμοποιήσουμε το $$i$$-οστό τμήμα. Τότε θα καλύψουμε το $$[X_i,Y_i]$$. Επιτρέπεται με τα υπόλοιπα τμήματα να καλύψουμε ξανά κάτι από το $$[X_i,Y_i]$$, αλλά δεν είναι απαραίτητο. Αυτό που επιβάλλεται είναι να καλύψουμε το διάστημα $$[qX,X_i]$$. Αν μπορούσαμε να μαντέψουμε ακριβώς μέχρι ποιο σημείο $$J$$ του (προαιρετικού) διαστήματος $$[X_i,Y_i]$$ θα καλύψουμε, τότε θα ζητούσαμε μία λύση που καλύπτει το $$[qX,J]$$ και τίποτα πέρα από το $$J$$. Επειδή δεν μπορούμε να μαντέψουμε το $$J$$, δοκιμάζουμε όλες τις πιθανές εκδοχές, και κρατάμε την καλύτερη. Δηλαδή:

$$ans'(i) = C_i + min_{j: Y_j\ge X_i} ans'(j)$$

Τι κερδίσαμε; Υπολογίζουμε $$\mathcal{O}(N)$$ αντί για $$\mathcal{O}(N^2)$$ καταστάσεις. Τι χάσαμε; Η μαντεψιά για το $$j$$ είναι πολύ ακριβή, και παίρνει $$\mathcal{O}(N)$$ χρόνο. Εν τέλει η πολυπλοκότητα είναι ακριβώς η ίδια.

Παρακάτω θα δούμε τα θετικά αυτής της λύσης, και συγκεκριμένα ότι μπορεί να βελτιωθεί περαιτέρω. ΕΔΩΩΩΩΩΩΩΩΩΩΩΩΩΩΩΩΩ δίνουμε τον κώδικα για την παρούσα λύση.

## Λύση 2 - Βελτιωμένος δυναμικός προγραμματισμός - $$\mathcal{O}(MN\log{N})$$

Μήπως μπορούμε να βελτιώσουμε τον χρόνο που μας παίρνει η μαντεψιά του $$j$$ στην προηγούμενη λύση; Ψάχνουμε το

$$min_{j: Y_j\ge X_i} ans'(j)$$

Η κρίσιμη (και όχι τόσο προφανής) ιδέα εδώ πέρα είναι η εξής: αν φανταστούμε έναν πίνακα που στη θέση $$Y_j$$ περιέχει την τιμή $$\texttt{ans'}(j)$$, τότε ζητάμε την ελάχιστη τιμή του πίνακα στο διάστημα που ξεκινάει από το $$X_i$$ και εκτείνεται μέχρι το τέλος. Το πρόβλημα αυτό είναι γνωστό: λέγεται Range Minimum Query (RMQ, δείτε [!εδώ]()) για προτάσεις σχετικά με το πώς λύνεται). Χρησιμοποιώντας μια καλή λύση για αυτό το πρόβλημα (πχ με δυαδικά δέντρα) μπορούμε να πάρουμε απάντηση σε $$\mathcal{O}(\log{N})$$ χρόνο, αντί για $$\mathcal{O}(N)$$.

Καταλήγουμε ότι υπάρχουν $$N$$ καταστάσεις να υπολογίσουμε ανά ερώτημα, και για την κάθε μία χρειαζόμαστε $$\mathcal{O}(\log{N})$$ χρόνο. Η τελική πολυπλοκότητα είναι $$\mathcal{O}(MN\log{N})$$. Παρακάτω δίνουμε κώδικα που λύνει το πρόβλημα.

## Λύση 3 - $$\mathcal{O}(MN\log{N}/\log{\log{N}})$$

Αν χρησιμοποιήσουμε αποδοτικότερες λύσεις για το RMQ πρόβλημα, παίρνουμε καλύτερη συνολική πολυπλοκότητα. Μία τέτοια λύση χρησιμοποιεί Fusion Trees. Στην ουσία τα Fusion Trees είναι παρόμοια με τα κλασικά δυαδικά δέντρα, αλλά έχουν περίπου $$\log{N}$$ παιδιά ανά κόμβο. Αυτό που πετυχαίνουν είναι ο χρόνος να γίνεται (θεωρητικά) καλύτερος κατά $$\log{\log{N}}$$. Δυστυχώς η κατανόηση της λειτουργίας τους ξεφεύγει από τα όρια των διαγωνισμών, και ο κώδικάς τους είναι πολύ πιο περίπλοκος. Το πιο αστείο είναι ότι στην πράξη ούτε ο χρόνος που δίνουν είναι καλύτερος, γιατί κρύβουν μεγαλύτερους σταθερούς παράγοντες μέσα στο $$\mathcal{O}(\log{N}/\log{\log{N}})$$. Επομένως δεν θα δώσουμε κώδικα για αυτή τη λύση.

## Ανοιχτό ερώτημα - Υπάρχει καλύτερη λύση;

Γενικά το RMQ δεν μπορεί να λυθεί σε χρόνο καλύτερο από $$\mathcal{O}(\log{N}/\log{\log{N}})$$, όταν δεν έχουμε καμμία γνώση για τα επερχόμενα ερωτήματα/ανανεώσεις, και μπορεί να έρθει οποιοδήποτε ερώτημα/ανανέωση. Στη συγκεκριμένη περίπτωση δεν είναι όμως σαφές αν χρειαζόμαστε τόσο χρόνο. Ίσως για παράδειγμα μπορούμε να αξιοποιήσουμε ότι τα επερχόμενα ερωτήματα/ανανεώσεις δεν μας είναι παντελώς άγνωστα, αλλά σχετίζονται με την είσοδο την οποία έχουμε διαβάσει ολόκληρη από την αρχή. Επιπλέον τα ερωτήματα/ανανεώσεις δεν μπορούν να είναι εντελώς αυθαίρετα (πχ στα ερωτήματα που καλούμαστε να λύσουμε εν προκειμένω, το δεξί άκρο είναι πάντα απεριόριστο). Δε θα μας εξέπληττε λοιπόν στο συγκεκριμένο πρόβλημα το RMQ να μπορεί να υλοποιηθεί και σε $$\mathcal{O}(1)$$ χρόνο, και να παίρναμε συνολική πολυπλοκότητα $$\mathcal{O}(MN)$$.

Επιπλέον, ίσως να υπάρχουν και ακόμα καλύτερες λύσεις, που να ακολουθούν εντελώς διαφορετική προσέγγιση. Το πιο ενδιαφέρον θα ήταν να καταφέρναμε με κάποια προεργασία να λύσουμε το πρόβλημα σε χρόνο ταχύτερο από γραμμικό ανά ερώτημα, πχ σε συνολικό χρόνο $$\mathcal{O}(N+M\log{N})$$.