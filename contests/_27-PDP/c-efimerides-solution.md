---
layout: solution
codename: efimerides
---

## Επεξήγηση εκφώνησης

Μας δίνεται ένας κυκλικός πίνακας $$A$$ με $$N$$ ακεραίους και ένας ακέραιος $$K$$. Διαλέγουμε μία αρχική θέση στον πίνακα και κάθε φορά βρίσκουμε τον $$K$$-οστό γείτονά του, μέχρι να επιστρέψουμε σε μία θέση που έχουμε ήδη επισκεφθεί. Μας ζητείται να βρούμε το μέγιστο άθροισμα των στοιχείων που μπορούμε να επισκεφτούμε από κάποια αρχική θέση με αυτή τη διαδικασία.

Ξεκινούμε με την βασική παρατήρηση ότι αυτή η διαδικασία τελειώνει μετά από το πολύ $$N$$ βήματα, αφού υπάρχουν το πολύ $$N$$ πιθανά στοιχεία που μπορούμε να επισκεφτούμε. Για την γρήγορη λύση θα δούμε ότι κάθε διαδικασία τελειώνει εκεί που ξεκίνησε.

## Προσομοίωση με hash set

Μπορούμε να δοκιμάσουμε να ξεκινήσουμε από κάθε δυνατή θέση και να βρούμε και να αθροίσουμε τα στοιχεία που θα επισκεφθούμε. Σε κάθε διαδρομή κρατάμε σε ένα hash set τις θέσεις τις οποίες επισκεπτόμαστε, ώστε όταν δούμε κάποια από αυτές ξανά, να ολοκληρώσουμε τη διαδικασία. 

{% include code.md solution_name='efimerides_slow.cc' %}

Στην χειρότερη περίπτωση από κάθε αρχική θέση, θα πρέπει να επισκεφθούμε όλες τις $$N$$ άλλες. Επομένως ο αλγόριθμος χρειάζεται $$\mathcal{O}(N^2)$$ χρόνο και $$\mathcal{O}(N)$$ μνήμη.

## Προσομοίωση με πίνακα

Αντί για set (ή hash set), μπορούμε να χρησιμοποιήσουμε έναν boolean πίνακα $$\textit{seen}$$ με $$N$$ θέσεις, όπου το $$\textit{seen}[i]$$ μας λέει αν είδαμε το $$i$$ στην τελευταία διαδρομή. Για να μπορέσουμε να επαναχρησιμοποιήσουμε τον ίδιο πίνακα στην επόμενη διαδρομή, στο τέλος της κάθε διαδρομής ανατρέχουμε στα στοιχεία που επισκεφθήκαμε και θέτουμε την τιμή σε $$0$$. Ο κώδικας χρειάζεται τις εξής αλλαγές:

{% include code.md solution_name='efimerides_slow_table.cc' start=19 end=34 %}

Ο αλγόριθμος ακόμα χρειάζεται $$\mathcal{O}(N^2)$$ χρόνο, αλλά περνάει δύο παραπάνω testcases από την λύση με το hash set.

## Γρήγορη λύση

**Παρατήρηση:** Κάθε διαδικασία τελειώνει στο στοιχείο από το οποίο ξεκίνησε.

*Αιτιολόγηση:* Παρατηρήστε ότι για το $$i$$-οστό στοιχείο υπάρχει μόνο ένα που μπορεί να οδηγήσει σε αυτό, συγκεκριμένα αυτό στην θέση $$(i - K) \pmod{N}$$. Επομένως, αν μία διαδικασία τελείωνει σε κάποιο στοιχείο διαφορετικό από αυτό που ξεκίνησε, τότε υπάρχουν δύο διαφορετικά στοιχεία που οδηγούν σε αυτό (δείτε το παρακάτω σχήμα), άρα άτοπο.

<center>
<img alt="Αν μία διαδρομή δεν είναι κύκλος, τότε υπάρχουν δύο στοιχεία που δείχνουν στο ίδιο" src="/assets/27-c-efimerides-non-cycle.svg" width="300px">
</center>

Αυτό σημαίνει ότι όλες οι διαδρομές είναι κυκλικές. Στο πρώτο παράδειγμα της εκφώνησης υπάρχει ένας κύκλος που περιλαμβάνει όλα τα στοιχεία, ενώ στο δεύτερο υπάρχουν τρεις κύκλοι από δύο στοιχεία.

<center>
<img alt="Οι κύκλοι για τα δύο παραδείγματα της εκφώνησης" src="/assets/27-c-efimerides-cycles.svg" width="450px">
</center>

Αρα από όποιο στοιχείο και να ξεκινήσουμε στον ίδιο κύκλο, θα επισκεφτούμε τα ίδια στοιχεία και άρα θα έχουν το ίδιο άθροισμα. Επομένως, αρκεί να επισκεφθούμε το κάθε στοιχείο μία φορά, δηλαδή ξεκινάμε την διαδρομή αν το $$\textit{seen}[i] = 0$$. Ο παρακάτω κώδικας υλοποιεί αυτή τη λύση:

{% include code.md solution_name='efimerides_fast.cc' %}

Ο αλγόριθμος χρειάζεται $$\mathcal{O}(N)$$ χρόνο και μνήμη, και περνάει όλα τα testcases.
