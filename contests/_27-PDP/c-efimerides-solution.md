---
layout: solution
codename: efimerides
---

## Επεξήγηση εκφώνησης

Μας δίνεται ένας κυκλικός πίνακας $$A$$ με $$N$$ ακεραίους και ένας ακέραιος $$K$$. Διαλέγουμε μία αρχική θέση στον πίνακα και κάθε φορά βρίσκουμε τον $$K$$-οστό γείτονά του, μέχρι να επιστρέψουμε σε μία θέση που έχουμε ήδη επισκεφθεί. Μας ζητείται να βρούμε το μέγιστο άθροισμα των στοιχείων που μπορούμε να επισκεφτούμε, ξεκινώντας αυτή τη διαδικασία από κάποια αρχική θέση.

Ξεκινούμε με την βασική παρατήρηση ότι αυτή η διαδικασία τελειώνει μετά από το πολύ $$N$$ βήματα, αφού υπάρχουν το πολύ $$N$$ πιθανά στοιχεία που μπορούμε να επισκεφτούμε. Για τη γρήγορη λύση θα δούμε ότι κάθε διαδικασία τελειώνει εκεί που ξεκίνησε.

## Προσομοίωση με set ή hash set

Σε αυτή τη λύση, ξεκινάμε τη διαδικασία από κάθε δυνατή θέση, βρίσκουμε τα στοιχεία που επισκεπτόμαστε και τα αθροίζουμε. Σε κάθε διαδρομή κρατάμε σε ένα set (ή σε hash set ώστε το find/insert να γίνονται σε $$\mathcal{O}(1)$$ χρόνο) τις θέσεις τις οποίες επισκεπτόμαστε, ώστε όταν δούμε κάποια από αυτές ξανά, να ολοκληρώσουμε τη διαδικασία. Από όλες τις διαδρομές, κρατάμε αυτή με το μεγαλύτερο άθροισμα.

{% include code.md solution_name='efimerides_slow.cc' %}

Στην χειρότερη περίπτωση από κάθε αρχική θέση, θα πρέπει να επισκεφθούμε όλες τις $$N$$ άλλες. Επομένως, ο αλγόριθμος χρειάζεται $$\mathcal{O}(N^2)$$ χρόνο και $$\mathcal{O}(N)$$ μνήμη.

## Προσομοίωση με πίνακα

Αντί για set (ή hash set), μπορούμε να χρησιμοποιήσουμε έναν boolean πίνακα $$\textit{seen}$$ με $$N$$ θέσεις, όπου το $$\textit{seen}[i]$$ μας λέει αν είδαμε το $$i$$ στην τελευταία διαδρομή. Για να μπορέσουμε να επαναχρησιμοποιήσουμε τον ίδιο πίνακα στην επόμενη διαδρομή, στο τέλος της κάθε διαδρομής ανατρέχουμε στα στοιχεία που επισκεφθήκαμε και θέτουμε την τιμή σε `false`. Ο κώδικας χρειάζεται τις εξής αλλαγές:

{% include code.md solution_name='efimerides_slow_table.cc' start=19 end=34 %}

Ο αλγόριθμος ακόμα χρειάζεται $$\mathcal{O}(N^2)$$ χρόνο, αλλά περνάει δύο παραπάνω testcases από την λύση με το hash set. Μπορείτε να βρείτε ολόκληρο τον κώδικα [εδώ]({% include link_to_source.md solution_name='efimerides_slow_table.cc' %}).

## Γρήγορη λύση

Για την γρήγορη λύση, κάνουμε την εξής παρατήρηση.

**Παρατήρηση:** Κάθε διαδικασία τελειώνει στο στοιχείο από το οποίο ξεκίνησε.

*Αιτιολόγηση:* Παρατηρήστε ότι για το $$i$$-οστό στοιχείο υπάρχει μόνο ένα που μπορεί να οδηγήσει σε αυτό, συγκεκριμένα αυτό στην θέση $$(i - K) \pmod{N}$$. Επομένως, αν μία διαδικασία τελείωνε σε κάποιο στοιχείο διαφορετικό από αυτό που ξεκίνησε, τότε θα υπήρχαν δύο διαφορετικά στοιχεία που οδηγούν σε αυτό (δείτε το παρακάτω σχήμα), άρα άτοπο.

<center>
<img alt="Αν μία διαδρομή δεν είναι κύκλος, τότε υπάρχουν δύο στοιχεία που δείχνουν στο ίδιο." src="/assets/27-c-efimerides-non-cycle.svg" width="300px">
</center>

Αυτό σημαίνει ότι όλες οι διαδρομές είναι κυκλικές. Στο πρώτο παράδειγμα της εκφώνησης υπάρχει ένας κύκλος που περιλαμβάνει όλα τα στοιχεία, ενώ στο δεύτερο υπάρχουν τρεις κύκλοι από δύο στοιχεία.

<center>
<img alt="Οι κύκλοι στα δύο παραδείγματα της εκφώνησης." src="/assets/27-c-efimerides-cycles.svg" width="450px">
</center>

Άρα, σε έναν κύκλο από όποιο στοιχείο του και να ξεκινήσουμε, θα επισκεφτούμε τα ίδια στοιχεία και άρα θα οδηγήσουν στο ίδιο άθροισμα. Επομένως, αρκεί να επισκεφθούμε το κάθε στοιχείο μία φορά, δηλαδή ξεκινάμε την διαδρομή αν το $$\textit{seen}[i] = \texttt{false}$$. Ο παρακάτω κώδικας υλοποιεί αυτή τη λύση:

{% include code.md solution_name='efimerides_fast.cc' %}

Ο αλγόριθμος χρειάζεται $$\mathcal{O}(N)$$ χρόνο και μνήμη, και περνάει όλα τα testcases.
