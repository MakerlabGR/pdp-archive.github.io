---
layout: solution
codename: share
---

## Brute force λύση

Πρέπει να διαμερίσουμε την ακολουθία των προβλεπόμενων κερδών σε τρία διαδοχικά τμήματα που το καθένα από αυτά θα αντιστοιχεί σε έναν αδέρφό, ώστε το μέγιστο άθροισμα των προβλεπόμενων κερδών σε κάποιο τμήμα να είναι το ελάχιστο δυνατό, δηλαδή ο πιο ευνοημένος αδερφός να έχει το ελάχιστο δυνατό κέρδος.

Μία brute force λύση είναι να δοκιμάσουμε όλες τις διαφορετικές διαμερίσεις για τις ημέρες και για κάθε διαμέριση να υπολογίζουμε το προβλεπόμενο κέρδος για κάθε αδερφό διατρέχοντας γραμμικά το αντίστοιχο τμήμα. Έπειτα μπορούμε άμεσα να δούμε ποιο είναι το κέρδος του πιο ευνοημένου αδερφού και να το συγκρίνουμε με το ελάχιστο μέγιστο κέρδος που θα έχουμε συναντήσει μέχρι στιγμής. Το τρέχον ελάχιστο μέγιστο κέρδος μπορούμε να το διατηρούμε λοιπόν σε μία μεταβλητή, έστω $$ans$$, και να το ενημερώνουμε όπως αναφέραμε. Η μεταβλητή αυτή μπορεί να αρχικοποιηθεί σε $$10^9$$ καθώς δεν μπορεί να πάρει μεγαλύτερη τιμή σύμφωνα με τους περιορισμούς της εκφώνησης. Μετά από την εξέταση όλων των διαμερίσεων η μεταβλητή $$ans$$ θα περιέχει την τελική απάντηση την οποία και θα εκτυπώνουμε.

Η εξέταση όλων των διαμερίσεων μπορεί να γίνει με χρήση δύο εμφωλευμένων for loops, έστω με μεταβλητές $$i$$ και $$j$$. Ο πρώτος αδερφός θα λάβει τα κέρδη από τη μέρα 1 (αρίθμηση από 1) μέχρι και τη μέρα $$i$$, ο δεύτερος από τη μέρα $$i + 1$$ μέχρι και τη μέρα $$j$$ και ο τρίτος από τη μέρα $$j + 1$$ μέχρι και τη μέρα $$N$$. Ακόμη επειδή τα προβλεπόμενα κέρδη είναι ακέραιοι αριθμοί και οι μέρες τουλάχιστον τρεις ($$N \geq 3$$), κάθε τμήμα θα περιέχει τουλάχιστον μία ημέρα. Επομένως θα ισχύει ότι $$1 \leq i < j \leq N - 1$$.

Επειδή συνολικά υπάρχουν $$O(N^2)$$ διαμερίσεις των ημερών σε διαδοχικά τμήματα και ο υπολογισμός του κέρδους κάθε αδερφού γίνεται σε χρόνο $$O(N)$$, η χρονική πολυπλοκότητα του αλγορίθμου θα είναι $$O(N^3)$$. Επειδή σύμφωνα με τους περιορισμούς $$N \leq 10^6$$ το πρόγραμμα θα υπερβεί το χρονικό όριο του ενός δευτερολέπτου για τα περισσότερα testcases. Η χωρική πολυπλοκότητα του αλγορίθμου είναι $$O(N)$$ καθώς πρέπει να αποθηκεύσουμε τα προβλεπόμενα κέρδη σε έναν πίνακα.

```c++
#include <cstdio>
#include <algorithm>

#define MAXN 1000005

using namespace std;

long A[MAXN];
// Επιστρέφει το άθροισμα των κερδών στο διάστημα [a, b]
long sum(long a, long b)
{
    long res = 0;
    for (long k = a; k <= b; k++) {
        res += A[k];
    }
    return(res);
}
int main() {
    freopen("share.in", "r", stdin);
    freopen("share.out", "w", stdout);
    long N;
    scanf("%ld", &N);
    for (long i = 1; i <= N; i++) {
        scanf("%ld", &A[i]);
    }
    long ans = 1000 * 1000 * 1000;  // Αρχικοποίηση ελάχιστου μεγίστου στο μέγιστο δυνατό
    for (long i = 1; i < N - 1; i++) {
        for (long j = i + 1; j <= N - 1; j++) {
            // Υπολογισμός προβλεπόμενων κερδών
            long v1 = sum(1, i), v2 = sum(i + 1, j), v3 = sum(j + 1, N);
            // Υπολογισμός μέγιστου κέρδους
            long mx = max(v1, v2);
            mx = max(mx, v3);
            // Έλεγχος αν το τρέχον μέγιστο κέρδος είναι ελάχιστο μέγιστο μέχρι στιγμής
            if (mx < ans)
                ans = mx;
        }
    }
    printf("%ld\n", ans);
    return(0);
}
```

## Καλύτερη brute force λύση με μερικά αθροίσματα
Η χρονική πολυπλοκότητα του προηγούμενου αλγορίθμου είχε επιβάρυνση ενός παράγοντα $$O(N)$$ λόγω του ότι για κάθε διαμέριση ο υπολογισμός του προβλεπόμενου κέρδους κάθε αδερφού γινόταν σε γραμμικό χρόνο. Ο υπολογισμός αυτός όμως μπορεί να γίνει σε σταθερό χρόνο εάν χρησιμοποιήσουμε τη μέθοδο των μερικών αθροισμάτων. Συγκεκριμένα ισχύει ότι $$\sum_{k = a}^b A[k]= \sum_{k = 1}^b A[k] - \sum_{k = 1}^{a - 1} A[k]$$. Μπορούμε λοιπόν να χρησιμοποιήσουμε έναν πίνακα ακεραίων, έστω $$S$$, μεγέθους $$N + 1$$, για να αποθηκεύσουμε τις τιμές των μερικών αθροισμάτων ώστε $$S[i] = \sum_{k = 1}^i A[k]$$. Ο υπολογισμός των στοιχείων του πίνακα αυτού μπορεί να γίνει καθώς διαβάζουμε τα προβλεπόμενα κέρδη σε γραμμικό χρόνο με βάση τον αναδρομικό τύπο $$S[k] = S[k - 1] + A[k]$$ και την αρχική συνθήκη $$S[0] = 0$$. Μπορούμε λοιπόν, δεδομένης μίας διαμέρισης, να υπολογίζουμε το προβλεπόμενο κέρδος κάθε αδερφού όπως αναφέραμε προηγουμένως σε σταθερό χρόνο, καθώς $$\sum_{k = a}^b A[k] = S[b] - S[a - 1]$$.

Χάρη στην προηγούμενη τεχνική η χρονική πολυπλοκότητα του αλγορίθμου μειώνεται κατά έναν παράγοντα $$O(N)$$ και πλέον είναι $$O(N^2)$$ λόγω των δύο εμφωλευμένων for loops για τον υπολογισμό των δυνατών διαμερήσεων των ημερών σε τρία διαδοχικά τμήματα. Και αυτή η πολυπλοκότητα δεν είναι αρκετά καλή για να περάσει όλα τα testcases ωστόσο είναι σαφώς καλύτερη από την προηγούμενη. Η χωρική πολυπλοκότητα του αλγορίθμου δε μεταβάλλεται και έτσι παραμένει ίση με $$O(N)$$.

```c++
#include <cstdio>
#include <algorithm>

#define MAXN 1000005

using namespace std;

long A[MAXN], S[MAXN];
int main() {
    freopen("share.in", "r", stdin);
    freopen("share.out", "w", stdout);
    long N;
    scanf("%ld", &N);
    // Διάβασμα προβλεπόμενων κερδών και υπολογισμός μερικών αθροισμάτων
    S[0] = 0;
    for (long i = 1; i <= N; i++) {
        scanf("%ld", &A[i]);
        S[i] = S[i - 1] + A[i];
    }
    long ans = 1000 * 1000 * 1000;  // Αρχικοποίηση ελάχιστου μεγίστου στο μέγιστο δυνατό
    for (long i = 1; i < N - 1; i++) {
        for (long j = i + 1; j <= N - 1; j++) {
            // Υπολογισμός προβλεπόμενων κερδών
            long v1 = S[i], v2 = S[j] - S[i], v3 = S[N] - S[j];
            // Υπολογισμός μέγιστου κέρδους
            long mx = max(v1, v2);
            mx = max(mx, v3);
            // Έλεγχος αν το τρέχον μέγιστο κέρδος είναι ελάχιστο μέγιστο μέχρι στιγμής
            if (mx < ans)
                ans = mx;
        }
    }
    printf("%ld\n", ans);
    return(0);
}
```

## Καλύτερη λύση με δυαδική αναζήτηση

Υπάρχει η δυνατότητα να κατασκευάσουμε έναν ακόμη πιο γρήγορο αλγόριθμο εάν κάνουμε μία απλή παρατήρηση.

**Παρατήρηση**: Εάν δε γίνεται το πιο ευνοημένο από τα αδέρφια να έχει προβλεπόμενο κέρδος μικρότερο ή ίσο με $$K$$, τότε δε γίνεται να έχει κέρδος μικρότερο ή ίσο με $$K'$$ για κανένα $$K' \leq K$$.

Εάν αρχίσουμε λοιπόν να δοκιμάζουμε με τη σειρά τα διαφορετικά $$K$$ στο διάστημα ακεραίων $$[0, 10^9]$$ (επαρκές διάστημα λόγω των περιορισμών της εκφώνησης) ή ακόμη καλύτερα στο $$[0, S[N]]$$, ελέγχοντας με κάποιον τρόπο (θα τον δούμε στη συνέχεια) για το καθένα από αυτά αν γίνεται να διαμερίσουμε τις μέρες ώστε ο πιο ευνοημένος αδερφός να έχει προβλεπόμενο κέρδος μικρότερο ή ίσο από το εκάστοτε $$K$$, τότε από την αρχή μέχρι κάποιο σημείο θα λαμβάνουμε αρνητικές απαντήσεις, ενώ από το σημείο αυτό και μετά θα λαμβάνουμε θετικές απαντήσεις. Το πρώτο $$K$$ για το οποίο θα λάβουμε θετική απάντηση είναι το ελάχιστο μέγιστο κέρδος αδερφιού, δηλαδή η απάντηση που ψάχνουμε. Η μορφή λοιπόν που έχουν οι έλεγχοι στο διάστημα ακεραίων που αναφέραμε ως προς την ικανοποιησιμότητα (πρώτα μόνο αρνητικές απαντήσεις και μετά μόνο θετικές) μας επιτρέπει να κάνουμε δυαδική αναζήτηση για να υπολογίσουμε την απάντηση. Να σημειώσουμε ότι συχνά, προβλήματα στα οποία αναζητούμε το ελάχιστο μέγιστο μίας ποσότητας (ή το μέγιστο ελάχιστο) μπορούν να προσεγγιστούν με δυαδική αναζήτηση.

Τώρα μένει να δούμε πώς θα γίνονται οι έλεγχοι που αναφέραμε, δηλαδή πώς δεδομένου ενός $$K$$ θα εξετάζουμε εάν γίνεται ο πιο ευνοημένος αδερφός να έχει κέρδος μικρότερο ή ίσο από αυτό το $$K$$. Ο έλεγχος αυτός μπορεί να γίνει άπληστα λαμβάνοντας υπόψην ότι αν ο πιο ευνοημένος αδερφός έχει κέρδος μικρότερο ή ίσο από $$K$$, τότε κάθε ένας από τους τρεις αδερφούς έχει κέρδος μικρότερο ή ίσο από $$K$$, καθώς και ότι κάθε αδερφός αναλαμβάνει κάποιες διαδοχικές μέρες ώστε τα τρία τμήματα ημερών να διαμερίζουν το σύνολό των $$N$$ ημερών. Επομένως δεδομένου του $$K$$ μπορούμε να αρχίσουμε από την πρώτη ημέρα και να θεωρούμε ότι οι μέρες αντιστοιχούν στο πρώτο αδερφό όσο το προβλεπόμενο κέρδος του είναι μικρότερο ή ίσο του $$K$$, έπειτα θα συνεχίσουμε από το σημείο που μείναμε και θα αντιστοιχίζουμε τις ημέρες στο δεύτερο αδερφό όσο το προβλεπόμενο κέρδος και αυτού δεν υπερβαίνει το $$K$$. Ανν μετά από αυτήν τη διαδικασία οι μέρες που έχουν περισσέψει έχουν συνολικό προβλεπόμενο κέρδος μικρότερο ή ίσο του $$K$$, τότε μπορούν να αντιστοιχιθούν στο τρίτο αδερφό και να έχουμε θετική απάντηση στον έλεγχο, διαφορετικά δεν μπορεί να γίνει αποδεκτή διαμέριση και έχουμε αρνητική απάντηση. Η ορθότητα της διαδικασίας αυτής μπορεί να αποδειχθεί εύκολα και τυπικά με χρήση του επιχειρήματος ανταλλαγής, μίας κλασικής αποδεικτικής μεθόδου για την ορθότητα άπληστων αλγορίθμων.

Ο αλγόριθμος αυτός απαιτεί την εκτέλεση $$O(\log{S[N]})$$ ελέγχων για τη διαδική αναζήτηση κάθε ένας από τους οποίους χρειάζεται χρόνο $$O(N)$$ για να εκτελέσει την άπληστη διαδικασία που περιγράψαμε. Συνεπώς η χρονική πολυπλοκότητα αυτού του αλγρίθμου είναι $$O(N \logS[N])$$. Η χωρική πολυπλοκότητα είναι $$O(N)$$. Η λύση αυτή είναι αποδεκτή και περνάει τα testcases.

Να σημειώσουμε ότι ο αλγόριθμος αυτός μπορεί να γενικευτεί εύκολα και για περισσότερα από τρία αδέρφια χωρίς να αυξηθεί η πολυπλοκότητά του εάν οι περιορισμοί διατηρηθούν σταθεροί, σε αντίθεση με τους δύο προηγούμενους αλγορίθμους που είδαμε οι οποίοι δεν έχουν αποδοτικές γενικεύσεις.

```c++
#include <cstdio>
using namespace std;
#define MAXN 1000005
long N;
long A[MAXN], S[MAXN];
// Συνάρτηση άπληστου ελέγχου με γραμμική διάσχιση
bool check(long K) {
    long p = 0, sum = 0;
    // Αντιστοιχία ημερών στον πρώτο αδερφό
    while (p < N && sum + A[p + 1] <= K) {
        sum += A[++p];
    }
    sum = 0;
    // Αντιστοιχία ημερών στο δεύτερο αδερφό
    while (p < N && sum + A[p + 1] <= K) {
        sum += A[++p];
    }
    // Απάντηση ελέγχου ανάλογα με το κέρδος των υπόλοιπων ημερών
    return(S[N] - S[p] <= K);
}
int main() {
    freopen("share.in", "r", stdin);
    freopen("share.out", "w", stdout);
    scanf("%ld", &N);
    // Διάβασμα προβλεπόμενων κερδών και υπολογισμός μερικών αθροισμάτων
    S[0] = 0;
    for (long i = 1; i <= N; i++) {
        scanf("%ld", &A[i]);
        S[i] = S[i - 1] + A[i];
    }
    long lo = 0, hi = S[N];  // Αρχικοποίηση ορίων δυαδικής αναζήτησης
    // Δυαδική αναζήτηση
    while (lo < hi) {
        long mid = lo + (hi - lo) / 2;
        if (check(mid)) hi = mid;
        else lo = mid + 1;
    }
    long ans = lo;
    printf("%ld\n", ans);
    return(0);
}
```

## Ουσιαστικά βέλτιστη λύση με δύο δυαδικές αναζητήσεις

Η προηγούμενη λύση μπορεί να βελτιωθεί ασυμπτωτικά εάν μειώσουμε την πολυπλοκότητα του άπληστου ελέγχου που κάνει σε κάθε βήμα της δυαδικής αναζήτησης σε υπογραμμική. Αυτό μπορούμε να το επιτύχουμε διατηρώντας την απληστότητα της διαδικασίας όμοια με πριν αλλά μειώνοντας το κόστος της κάθε εκτέλεσης της άπληστης διαδικασίας στηριζόμενοι στην ακόλουθη παρατήρηση.

**Παρατήρηση**: Δεδομένου ενός $$K$$ για την άπληστη διαδικασία ελέγχου της δυαδικής αναζήτησης, ο διαμερισμός των ημερών μπορεί να γίνει με δυαδική αναζήτηση για τα όρια μεταξύ των τμημάτων.

Συγκεκριμένα ο πρώτος αδερφός θα αναλάβει όπως είπαμε μέρες αρχίζοντας από την πρώτη και συνεχίζοντας όσο το προβλεπόμενο κέρδος του δεν υπερβαίνει το $$K$$. Η αναζήτηση του σημείου αυτού μπορεί να γίνει όμως όχι γραμμικά αλλά με δυαδική αναζήτηση στον πίνακα $$S$$, ψάχνοντας το μέγιστο $$i$$ για το οποίο $$S[i] \leq K$$ (ο πίνακας $$S$$ είναι γνησίως αύξων).Έστω ότι αυτό το μέγιστο $$i$$ είναι το $$a$$. Ομοίως για το δεύτερο αδερφό η τελευταία ημέρα που θα αναλάβει μπορεί να βρεθεί με δυαδική αναζήτηση, ψάχνοντας το μέγιστο $$i$$ για το οποίο $$S[i] - S[a] \leq K$$.

Η πολυπλοκότητα λοιπόν καθενός από τους $$O(\log S[N])$$ άπληστους ελέγχους έπεσε σε $$O(\log N)$$. Έτσι η πολυπλοκότητα της δυαδικής αναζήτησης είναι πλέον $$\log{N} \cdot \log{S[N]}$$ αντί για $$N \log{S[N]}$$. Έτσι η χρονική πολυπλοκότητα του αλγορίθμου είναι $$O(N + \log{N} \cdot \log{S[N]})$$. Με βάση τους περιορισμούς εισόδου που ισχύουν η ποσότητα $$O(\log{N} \cdot \log{S[N]})$$ είναι αμελητέα συγκριτικά με την $$O(N)$$ για αρκετά μεγάλες τιμές του $$N$$, οπότε η χρονική πολυπλοκότητα είναι ουσιαστικά γραμμική και επιτρέπει να απαντηθούν με επιτυχία όλα τα testcases. Η χωρική πολυπλοκότητα είναι $$O(N)$$.

Ο αλγόριθμος αυτός γενικεύεται εύκολα για $$M$$ αδέρφια και η γενίκευση έχει χρονική πολυπλοκότητα $$O(N + K \log{N} \cdot \log{S[N]})$$. Ο παράγοντας $$K$$ οφείλεται στο ότι κάθε άπληστος έλεγχος απαιτεί $$O(k)$$ δυαδικές αναζητήσεις.

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
#define MAXN 1000005
long N;
long A[MAXN], S[MAXN];
// Συνάρτηση άπληστου ελέγχου με δυαδικές αναζητήσεις
bool check(long K) {
    long lo = 0, hi = N;
    // Υπολογισμός πρώτου ορίου
    while (lo < hi) {
        long mid = lo + (hi - lo + 1) / 2;
        if (S[mid] <= K) lo = mid;
        else hi = mid - 1;
    }
    long a = lo;
    hi = N;
    // Υπολογισμός δεύτερου ορίου
    while (lo < hi) {
        long mid = lo + (hi - lo + 1) / 2;
        if (S[mid] - S[a] <= K) lo = mid;
        else hi = mid - 1;
    }
    long b = lo;
    // Απάντηση ελέγχου ανάλογα με το κέρδος των υπόλοιπων ημερών
    return(S[N] - S[b] <= K);
}
int main() {
    freopen("share.in", "r", stdin);
    freopen("share.out", "w", stdout);
    scanf("%ld", &N);
    // Διάβασμα προβλεπόμενων κερδών και υπολογισμός μερικών αθροισμάτων
    S[0] = 0;
    for (long i = 1; i <= N; i++) {
        scanf("%ld", &A[i]);
        S[i] = S[i - 1] + A[i];
    }
    long lo = 0, hi = S[N];  // Αρχικοποίηση ορίων δυαδικής αναζήτησης
    // Δυαδική αναζήτηση
    while (lo < hi) {
        long mid = lo + (hi - lo) / 2;
        if (check(mid)) hi = mid;
        else lo = mid + 1;
    }
    long ans = lo;
    printf("%ld\n", ans);
    return(0);
}
```

## Βέλτιστη λύση με two pointers

Μία διαφορετική προσέγγιση αυτού του προβλήματος η οποία δίνει βέλτιστη πολυπλοκότητα μπορεί να γίνει με τη μέθοδο των two pointers. Συγκεκριμένα μπορούμε να αρχικοποιήσουμε τα τρία τμήματα ημερών ώστε ο πρώτος αδερφός και ο τρίτος αδερφός να έχουν αναλάβει αρχικά μία ημέρα ο καθένας (ημέρες $$1$$ και $$N$$ αντίστοιχα) και στη συνέχεια να μεταφέρουμε επαναληπτικά μέρες από το δεύτερο αδερφό προς όποιον από τους άλλους δύο πρόκειται να έχει μικρότερο προβλεπόμενο κέρδος μετά από τη μεταφορά αυτήν, όσο το μέγιστο προβλεπόμενο κέρδος μετά από την κάθε μεταφορά ημέρας μειώνεται. Τελικά δε θα μπορεί να επιτευχθεί μέγιστο κέρδος μικρότερο από αυτό που θα έχει ο πιο ευνοημένος αδερφός μετά από αυτήν τη διαδικασία.

Τώρα θα αποδείξουμε ότι η παραπάνω διαδικασία επιτυγχάνει βέλτιστο αποτέλεσμα. Έστω ότι ο πιο ευνοημένος αδερφός από μετά την προηγούμενη διαδικασία έχει προβλεπόμενο κέρδος $$K$$, ενώ το ελάχιστο δυνατό είναι $$K' < K$$.
* Αν ο πιο ευνοημένος αδερφός που υπολογίστηκε είναι ο δεύτερος, τότε η υποτιθέμενη βέλτιστη λύση είχε μεταγενέστερη ημέρα έναρξης ή προγενέστερη ημέρα λήξης για το δεύτερο αδερφό. Όμως αν είχε μεταγενέστερη ημερομηνία έναρξης αυτό θα έκανε το προβλεπόμενο κέρδος του πρώτου μεγαλύτερο του $$K$$ (αλλιώς δε θα είχε σταματήσει η διαδικασία και θα είχε γίνει μεταφορά ημέρας προς τον πρώτο). Ομοίως απορρίπτεται η περίπτωση της προγενέστερης ημέρας λήξης. 
* Αν ο πιο ευνοημένος αδερφός που υπολογίστηκε είναι ο πρώτος, τότε η υποτιθέμενη βέλτιστη λύση είχε προγενέστερη ημερομηνία λήξης για τον πρώτο και άρα προγενέστερη ημερομηνία έναρξης για το δεύτερο. Αν όμως πάμε έστω και μία ημέρα πίσω την ημέρα έναρξης του δεύτερου, τότε το προβλεπόμενο κέρδος του θα γίνει μεγαλύτερο του $$K$$ (αλλιώς δε θα είχε γίνει η μεταφορά ημέρας προς τον πρώτο) και δε θα μπορεί να γίνει μικρότερο του $$K$$ είτε για αυτόν είτε για τον τρίτο (αλλιώς θα είχε γίνει μεταφορά ημέρας προς τον τρίτο). Έτσι απορρίπτεται και αυτή η περίπτωση.
* Ομοίως με την περίπτωση του πρώτου απορρίπτεται και η περίπτωση ο τρίτος αδερφός να είναι ο πιο ευνοημένος αδερφός από τον αλγόριθμό μας, με προβλεπόμενο κέρδος $$K > K'$$.

Η χρονική πολυπλοκότητα αυτού του αλγορίθμου είναι $$O(N)$$ (ελάχιστη δυνατή) καθώς μπορεί να χρειαστούν $$O(N)$$ μεταφορές ημερών, ενώ καθεμία από αυτές γίνεται σε σταθερό χρόνο. Η χωρική πολυπλοκότητα του αλγορίθμου είναι $$O(N)$$. Όλα τα testcases επιτυγχάνουν με πρόγραμμα που υλοποιεί τον αλγόριθμο αυτόν.

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
#define MAXN 1000005
long A[MAXN];
int main() {
    freopen("share.in", "r", stdin);
    freopen("share.out", "w", stdout);
    long N, sum = 0;
    scanf("%ld", &N);
    // Διάβασμα προβλεπόμενων κερδών και υπολογισμός αθροίσματός τους
    for (long i = 1; i <= N; i++) {
        scanf("%ld", &A[i]);
        sum += A[i];
    }
    // Υπολογισμός αρχικών προβλεπόμενων κερδών για τα τρία αδέρφια
    long sum1 = A[1], sum3 = A[N], sum2 = sum - sum1 - sum3;
    // Αρχικοποίηση ορίων τμημάτων ημερών
    long a = 1, b = N - 1;
    while (sum2 > sum1 && sum2 > sum3) {
        // Υπολογισμός νέων προβλεπόμενων κερδών μετά από μεταφορά ημέρας
        long inc_sum1 = sum1 + A[a + 1], inc_sum3 = sum3 + A[b];
        if (inc_sum1 < sum2 && inc_sum1 <= inc_sum3) {
            // Μεταφορά ημέρας προς τον πρώτο αδερφό
            sum1 = inc_sum1;
            sum2 -= A[++a];
        }
        else if (inc_sum3 < sum2 && inc_sum3 <= inc_sum1) {
            // Μεταφορά ημέρας προς τον τρίτο αδερφό
            sum3 = inc_sum3;
            sum2 -= A[b--];
        }
        else
            break;
    }
    // Υπολογισμός μέγιστου κέρδους
    long ans = max(sum1, sum2);
    ans = max(ans, sum3);
    printf("%ld\n", ans);
    return(0);
}
```
